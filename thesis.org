# -*- eval: (org-indent-mode +1) -*-
# -*- eval: (visual-line-mode +1) -*-

#+TITLE: RTIC Scope — Real-Time Tracing Support for the RTIC RTOS Framework
#+AUTHOR: Viktor Vilhelm Sonesten
#+EMAIL: vikson-6@student.ltu.se
#+LANGUAGE: en
#+OPTIONS: ':t toc:nil title:nil todo:nil H:6

#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: thesis
#+LATEX_CLASS_OPTIONS: [a4paper,10pt]
#+latex_header: \usepackage{kpfonts}[maths]
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{inconsolata}
#+latex_header: \usepackage[style=apa,hyperref=true,url=true,backend=biber]{biblatex}
#+latex_header: \addbibresource{./ref.bib}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{newfloat}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{frame=lines,breaklines,breakafter=/.,fontsize=\footnotesize,linenos}
#+LATEX_HEADER: \usepackage[inline]{enumitem}
#+LATEX_HEADER: \usepackage{multicol}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks=true,urlcolor=blue,linkcolor={red!50!black},citecolor=blue,breaklinks=true}
#+LATEX_HEADER: \usepackage{glossaries-extra}
#+latex_header: \usepackage{microtype}
#+latex_header: \usepackage{tocbibind}
#+latex_header: \usepackage{todonotes}
#+latex_header: \usepackage[capitalize]{cleveref}
#+latex_header: \usepackage{csquotes}
#+latex_header: \usepackage{svg}
#+latex_header: \usepackage{caption}
#+LATEX_HEADER: \makeglossaries

# NOTE auto linebreaks / : - and _ inside \textttBreak. Adapted from <https://tex.stackexchange.com/a/219497>.
#+latex_header: \catcode`_=12 %
#+latex_header: \newcommand{\textttBreak}[1]{%
#+latex_header:   \begingroup
#+latex_header:   \ttfamily
#+latex_header:   \begingroup\lccode`~=`/\lowercase{\endgroup\def~}{/\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`-\lowercase{\endgroup\def~}{-\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`_\lowercase{\endgroup\def~}{_\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`:\lowercase{\endgroup\def~}{:\discretionary{}{}{}}%
#+latex_header:   \catcode`/=\active\catcode`-=\active\catcode`_=\active\catcode`:=\active
#+latex_header:   \scantokens{#1\noexpand}%
#+latex_header:   \endgroup
#+latex_header: }
#+latex_header: \catcode`_=8 %

#+latex_header: \usepackage[htt]{hyphenat}

#+latex_header: \usepackage{tikz}
#+latex_header: \usetikzlibrary{automata, positioning, arrows, shapes, calc}
#+latex_header: \tikzset{
#+latex_header:   block/.style = {draw, rectangle, minimum height=1cm, minimum width=2cm},
#+latex_header:   ->, % make edges directed
#+latex_header:   >=latex,
#+latex_header:   every text node part/.style={align=center}, % allow multiline node descriptions
#+latex_header: }

#+latex_header: \loadglsentries{glossary}
# TODO fix long-em on first use only?
#+latex_header: \setabbreviationstyle[acronym]{long-em-short-em}

# Allow \ref for description environments
#+latex_header: \makeatletter
#+latex_header: \def\namedlabel#1#2{\begingroup
#+latex_header:     #2%
#+latex_header:     \def\@currentlabel{#2}%
#+latex_header:     \phantomsection\label{#1}\endgroup
#+latex_header: }
#+latex_header: \makeatother

# TODO verify software versions with Cargo.lock from v0.3.0 tag.
# TODO fix hbox overflows on texttt in list of listings, bibliography, glossary
# TODO fix second list of listings page saying "list of figures"
# TODO tweak geometry for last overfull hboxes
# TODO fix memoir page header to use H:3
# TODO ask ARM about permission to copy figures/tables?
# TODO copy more relevant images from ARM spec.

* Org setup                                                        :noexport:
  #+begin_src emacs-lisp :result output :session :exports both
    ;; ignore some headlines
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines))

    ;; minted code listings
    (require 'ox-latex)
    (setq org-latex-listings 'minted)

    ;; use the book class, but without any \parts
    (add-to-list 'org-latex-classes
                 '("thesis"
                   "\\documentclass{memoir}"
                   ("\\chapter{%s}" . "\\chapter*{%s}")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    ;; use \cref instead of \ref, for cleveref
    (setq org-ref-default-ref-type "cref")
    (setq org-latex-prefer-user-labels t)

    ;; setup org-ref
    (setq bibtex-completion-bibliography '("./ref.bib")
          org-export-before-parsing-hook '(org-ref-glossary-before-parsing
                                           org-ref-acronyms-before-parsing))

    ;; make so that =some text= yield \textttBreak{some text} instead of
    ;; \texttt{some text}.
    ;;
    ;; NOTE do not use =some text= in section headings or captions.
    (defun org-latex--protect-texttt (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\texttt{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&_#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--protect-textttbreak (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\textttBreak{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--text-markup (text markup info)
      "Format TEXT depending on MARKUP text markup.
       INFO is a plist used as a communication channel.  See
       `org-latex-text-markup-alist' for details."
      (let ((fmt (cdr (assq markup (plist-get info :latex-text-markup-alist)))))
        (cl-case fmt
          ;; No format string: Return raw text.
          ((nil) text)
          ;; Handle the `verb' special case: Find an appropriate separator
          ;; and use "\\verb" command.
          (verb
           (let ((separator (org-latex--find-verb-separator text)))
             (concat "\\verb"
                     separator
                     (replace-regexp-in-string "\n" " " text)
                     separator)))
          (protectedtexttt (org-latex--protect-texttt text))
          (protectedtextttbreak (org-latex--protect-textttbreak text))
          ;; Else use format string.
          (t (format fmt text)))))
    (setq org-latex-text-markup-alist
          '((bold . "\\textbf{%s}")
            (code . protectedtexttt)
            (italic . "\\emph{%s}")
            (strike-through . "\\sout{%s}")
            (underline . "\\uline{%s}")
            (verbatim . protectedtextttbreak)))

    (org-babel-do-load-languages
     'org-babel-load-languages '((latex . t)
                                 (python . t)))

    ;; Dont require confirmation when babel-ing latex or python code in this document
    (defun my-org-confirm-babel-eval (lang body)
      (not (member lang '("latex" "python"))))
    (setq org-confirm-babel-evaluate 'my-org-confirm-babel-eval)
  #+end_src
#+RESULTS:

* Frontmatter                                                        :ignore:
#+LATEX: \frontmatter
# Make this a single paragraph; use unambiguous terms; aim for 250 words; 3-5 keywords.
#+begin_abstract
Here be an abstract...
#+end_abstract
#+begin_export latex
\newlist{inline-enum}{enumerate*}{1}
\setlist[inline-enum]{label=(\roman*)}

% Include "List of Listings" in the TOC
\renewcommand{\listoflistings}{
  \cleardoublepage
  \addcontentsline{toc}{chapter}{\listoflistingscaption}
  \listof{listing}{\listoflistingscaption}
}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\newpage
\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage
\listoflistings
\newpage

% Start counting with arabic numbers
\mainmatter

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Fix todonotes behavior
\setlength{\marginparwidth}{2cm}
\reversemarginpar
#+end_export

* *The Paper*                                                        :ignore:
** Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:
# What are embedded systems, regulators, and how do they relate?
Embedded systems --- a unit combination of a central processing unit, system memory, and input/output peripheral devices (commonly known as [[glspl:MCU]]) --- serve a key role in the operation of systems with electronic components where computations must be made.
Prime examples of such systems are digital control systems which regulate one or more control quantities such that they adhere to design characteristics.
Often the goal is to track a reference signal; such a control system is known as a [[gls:regulator]].
For example, one may wish to keep a rocket on a set path to reach orbit, or control the internals of a nuclear power plant to maximize electrical power output while keeping the plant within safe operation boundaries.

# On the real-time restrictions of control systems; exponential complexity phenomena.
A key design parameter of digital controllers is the [[gls:sample-rate][sample rate]]: if too low or inconsistent, the controlled system will end up unstable [[parencite:&franklin]]:
The rocket may thus fly off course, or the nuclear reactor reach a meltdown.
This puts a [[gls:real-time]] constraint on the digital controller which greatly limits how it can be implemented.
Further, a digital controller under implementation must be debugged so that the engineers can verify its correct operation and realize the real-time constraint.
This task grows exponentially in difficulty as the number of [[glspl:system-state]], inputs, and outputs increase.
Similar phenomena are observed for embedded systems with an increasing number of responsibilities, such as handling firmware updates or switching modes of operation on a button press.

# The observer effect; data emission.
Unfortunately, embedded systems are subject to the observer effect: to observe the system state (i.e., variables in memory) its operation must be affected.
# A proper implementation would not block on a serial write.
This observation is often realized by emitting data via serial communication which in the best case is subject to bus contention and full output queues.
It is not uncommon that a program blocks until the data has been serialized, severely affecting the regulation properties of the system if the payload is large.
In a perfect implementation the user application --- the program that executes on the embedded system --- would only concern itself with its regulation procedure and leave data emission to a completely disjoint system, minimizing the observer effect and thus the effect on the underlying control system.

# ARM, tracing subsystem and possible exploitation.
ARM is a company that licenses out designs of [[glspl:CPU]] for embedded systems.
ARM CPUs are available via a number of vendors; e.g., STMicroelectrics, Microchip Technology Inc., and Nordic Semiconductors.
The ARMv7-M platform standard offers debugging facilities that enables the developer to trace the system.
From [[textcite:&arm-cortex-learn]]: "Trace refers to the process of capturing data that illustrates how the components in a design are operating, executing, and performing".
Additionally, "[Trace generation is] almost entirely non-invasive. [Trace generation] does not influence the wider system".
These trace facilities allow for an event-based monitoring of
- [[gls:interrupt]] handler enters and exits;
- read and write access to in-memory address spaces; and
- [[gls:PC]] samples, among other features.
The generated trace is then emitted via asynchronous serial using a packet protocol (described in [[cref:debug-periphs]] and [[cref:theory:itm-proto]]), henceforth referred to as the [[gls:trace-stream]].
These facilities are not wholly disjoint (if they were, no insight into the system could be offered) but because the generation of the trace stream does not influence the wider system, the trace stream with system-external collection is a suitable candidate for exploitation to realize insight into a control system with minimal observer effect.

# Less work, more sleep.
Further, with non-invasive trace generation, less code must be executed by the [[gls:CPU]], allowing a shorter duty-cycle of the user application.
With a decreased duty-cycle the system can be put to sleep longer, and thus conserve energy.

# On real-time implementation restrictions, embedded implementation difficulties in general.
The development of embedded systems in general is non-trivial.
In comparison to general-purpose computers, where one often must not worry about resource limitations, embedded systems are constrained in all manners such that costs can be minimized for their non-general applications.
# No rich OS; no two embedded platforms are the same.
An embedded developer seldom have access to a rich operating systems --- a Linux-based distribution, for example --- which offers general-purpose facilities based on dynamic allocations and a common environment to simplify the program implementation.
Two embedded platforms usually differ significantly (even if both platforms are based upon ARMv7-M, due to the different peripherals) and porting a program to another platform is no small task.
This compares to general-purpose computers where a program written on one computer can be executed on another one, as long as the operating environment remains the same or are compatible.
# Side effects and priority inversions.
Embedded platforms are much more subject to side effects where peripherals are operated by writing data to memory-mapped registers.
Of certain importance is the problem of priority inversions, where a task of lower priority executes instead of a higher prioritized task because of an implementation error.
In summary, it is easy to put an embedded system in an incorrect or unknown state.
# Enter RTIC.
In order to lighten the implementation burden one may employ [[gls:RTIC]] (see [[cref:rtic]]).

# Project aim
The aim of this thesis is to employ and extend upon [[gls:RTIC]] with a toolset, aptly named RTIC Scope, to trace [[glspl:task][tasks]] --- recording their states over time off-target --- by leveraging [[Citeauthor:&arm-cortex-learn][ARM]]'s non-intrusive tracing facilities and thus provide a suite of software convenient for embedded control system engineers to verify design characteristic adherence.
RTIC Scope will aim for minimal user [[gls:overhead]] in order to apply the toolset, and allow the replay of traces postmortem (after the system has executed and is no longer active).

# Thesis summary
This thesis covers the theory behind relevant ARM peripherals and protocols upon which RTIC Scope relies, a close-to exhaustive enumerations of the contributions made during the project and a detailed description of its implementation, along with discussions on approaches taken and topics of interests regarding the future work that can be done to improve upon the toolset.
The toolset is applied to a trivial RTIC application for demonstration purposes.

*** Background
This introductory section covers the software components that have realized RTIC Scope.

**** The Rust programming language
:PROPERTIES:
:CUSTOM_ID: rust
:END:
Rust is a system programming language that guarantees defined run-time behavior and the absence of mutable aliasing as long as code is written in a [[gls:safe]] context.
Throughout this text the following Rust terminology is used:
[[gls:crate]], [[gls:enum]], [[gls:struct]], [[gls:function]], [[gls:macro]], [[gls:manifest]], [[gls:feature]], and [[gls:trait]].
For sake of decreasing typesetting noise, the relevant glossary entries for these fundamental terms will not be referred to again henceforth.
Further, it is presumed that Rust's build system, =cargo=, is understood by the reader; it is not covered in this text.
For a more detailed description of this terminology, and the Rust programming language and ecosystem in general, refer to [[textcite:&rust-lang]].

Refer to [[textcite:&tjader2021rtic 6--8]] for a summary of Rust in an embedded context.

**** \glsxtrfullpl{PAC}
:PROPERTIES:
:CUSTOM_ID: background:PAC
:END:
# What is a PAC and what are they used for?
A [[gls:PAC]] is a Rust library crate which exposes a convenient and standardized [[gls:API]] to read and write to memory-mapped registers in order to mutate (in order to configure) and query (in order to poll the status of) hardware peripherals.

# Differentiate {architecture,device}-specific PACs
In the embedded Rust ecosystems, there are two kinds of [[glspl:PAC]]:
- Architecture-specific :: PACs expose an API for hardware peripherals common to all [[glspl:MCU]] that share the same architecture, commonly termed /family/.
  For example, =cortex-m= [[parencite:&cortex-m]] is a PAC that targets the ARM Cortex-M family of embedded systems.
  Of note are the Cortex-M4 and Cortex-M7 families which are based upon ARMv7-M and includes the hardware peripherals that RTIC Scope requires.
- Device-specific :: PACs expose an API for hardware peripherals available on a smaller subset family of embedded systems.
  For example, =stm32-rs= [[parencite:&stm32-pac]] is a collection of PACs targeting all microcontrollers in the STMicroelectronics STM32 family.

# Quick note on HALs
The ecosystem also contains [[glspl:HAL]].
These crates are built upon PACs in order to provide a further abstracted hardware [[gls:API]].

# svd2rust
Device-specific PACs are generated via =svd2rust= [[parencite:&svd2rust]].
HALs, on the other hand, are written by hand.

An important component of device-specific PACs for RTIC Scope is the [[gls:interrupt]] enum.
An example declaration of such an enum can be seen in [[cref:lst:pac-interrupt-example]].
Refer to [[cref:impl:cargo-rtic-scope:generating-metadata-maps]] on how this enum is utilized.
#+NAME: lst:pac-interrupt-example
#+CAPTION: Example declaration of a ~PAC::Interrupt~ (interpreted as per the last paragraph of [[cref:reading-guidelines]]) enum. Left-hand side of ~Interrupt~ is the [[gls:IRQ]] label; right-hand is $N$ in [[cref:tbl:irqns]].
#+begin_src rust
  pub mod PAC {
      #[derive(Debug)]
      #[repr(u16)]
      pub enum Interrupt {
          PVD = 1,
          EXTI0 = 6,
          EXTI1 = 7,
          // ...
      }

      unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
          #[inline(always)]
          fn number(self) -> u16 {
              self as u16
          }
      }
  }
#+end_src

**** The \glsxtrfull{RTIC} [[gls:RTOS]]
:PROPERTIES:
:CUSTOM_ID: rtic
:END:
[[gls:RTIC]] [[parencite:&rtic]] is a novel [[gls:RTOS]] targeting the ARM Cortex-M platform.
It began development at Luleå Technical University[fn:: Under the previous name of "RTFM".] based on the extensively studied [[gls:SRP]][fn:: Refer to [[textcite:&srp]].], which
- prevents deadlocks;
- mitigates priority inversions; and
- is compatible with [[gls:EDF]] scheduling.
RTIC removes some embedded programming burden out-of-the-box while also
- implementing message passing between [[glspl:task]];
- incurring a minimal scheduling overhead;
- being amenable to [[gls:WCET]] analysis [[parencite:&rauk]].

# Oh yeah, and Rust
RTIC is written in Rust which removes additional developer overhead (see [[cref:rust]]).

An RTIC application is implemented by statically declaring a set of atomic tasks which are executed and scheduled by help of Cortex-M hardware features.
This section summarizes the two different task types --- [[glspl:hardware-task]] and [[glspl:software-task]] --- that together constitute an RTIC application.
Refer to [[textcite:&rtic]] and [[textcite:&tjader2021rtic]] for more details on RTIC and how it is implemented.

Hardware tasks are regular Rust functions that are bound to [[glspl:interrupt]].
When this interrupt is made pending in hardware, and no interrupt handler of higher priority is currently executing, the task function executes.
An example hardware task is declared via [[cref:rtic-hw-task-example]].
With this declaration, =app::foo= will be executed when =EXTI0= is pending.
When =app::foo= returns, the interrupt has been handled and =EXTI0= is no longer pending.
#+name: rtic-hw-task-example
#+CAPTION: [[gls:RTIC]] [[gls:hardware-task]] bound to the ~EXTI0~ [[gls:interrupt]].
#+begin_src rust
  #[rtic::app]
  mod app {
      // ...

      #[task(bound = EXTI0)]
      fn foo(_ctx: foo::Context) {
          // ...
      }
  }
#+end_src

Software tasks are also regular Rust functions that are bound to hardware interrupts, but the bound interrupt is not exclusively associated to the task in question:
a single hardware interrupt can be associated with multiple software tasks.
For this reason the interrupt used to dispatch software tasks is termed a [[gls:task-dispatcher]].
An example of two software tasks are declared via [[cref:rtic-sw-task-example]].
Multiple task dispatchers can be declared, but as of writing it is not possible to declare which tasks a task dispatcher should handle; this is done automatically.
#+name: rtic-sw-task-example
#+caption: [[gls:RTIC]] [[glspl:software-task]], bound to the ~EXTI0~ [[gls:task-dispatcher]].
#+begin_src rust
  #[rtic::app(dispatchers = [EXTI0])]
  mod app {
      // ...

      #[task]
      fn foo(_ctx: foo::Context) {
          // ...
      }

      #[task]
      fn bar(_ctx: bar::Context) {
          // ...
      }
  }
#+end_src

The purpose of hardware tasks is to respond to external stimuli: e.g., a button press, a hardware timer trigger, or incoming communication.
The purpose of software tasks is to provide a task implementation that is scheduled by software via the RTIC [[gls:API]] instead of being triggered by external stimuli.
Example usage of a software task may be to send a response over a line of communication after a hardware task executed to read a message on the same line.
**** Hardware debuggers
:PROPERTIES:
:CUSTOM_ID: background:probes
:END:
Hardware debuggers, also known as [[glspl:probe]], are dedicated hardware that provide a debugging interface between the host and target.
The probe itself is an embedded system used to program and debug the embedded system that is considered the target.
A probe usually provides a [[gls:USB]] interface for the host and a [[gls:SWD]] and/or a [[gls:JTAG]] interface for the target.
An embedded system may provide its own probe which is usually the case for evaluation kits[fn:: One such kit is the Microchip SAM V71 Xplained Ultra.] or expose headers on which to attach a probe for programming and debugging.

In order to interface with a probe a software suite is required on the host.
Examples of such suites are =openocd=, [[textcite:&openocd]]; and =probe-rs=, [[textcite:&probe-rs]].

*** Motivation
Both [[gls:RTIC]] and the debug peripherals of ARMv7-M operate in an event-based context where RTIC events trigger the debug peripherals to emit [[glspl:trace-packet]].
Exploiting this relationship is thus sensible; certainly so because these peripherals do not affect the wider system as covered in [[cref:introduction]].
Hardware-wise, this approach is very cheap to utilize on a supporting [[gls:MCU]]:
only the [[gls:SWO]] pin needs to be exposed, and a general-purpose bridge provided to deserialize the [[gls:trace-stream]] signal for the host system ([[cref:theory:swo]]).

The motivation of RTIC Scope is then to provide the necessary software to configure the target for [[gls:tracing]] and interpret the byte stream received on the host.
With available software, embedded developers can then quickly garner insight into their system to verify that the software behaves as expected, and trivially find out when and where it does not.

*** Problem definition
:PROPERTIES:
:CUSTOM_ID: requirements
:END:
This thesis covers the development of an embedded system analysis toolset, RTIC Scope, that enables an [[gls:RTIC]] application developer to gain non-invasive insight into the run-time of said application.
The toolset accomplishes this by exploiting the [[gls:trace-stream]] generated and emitted by debug facilities made available by the ARMv7-M standard[fn:: See [[cref:debug-periphs]].] which RTIC supports by targeting the Cortex-M platforms.

The set of requirements RTIC Scope must fulfill within the scope of this thesis follows:
RTIC Scope *MUST* adhere to, and thus be able to
- \namedlabel{req:itm-gen}{Requirement 1}: :: <<req:itm-gen>> enable trace stream generation of [[glspl:hardware-task]] and [[glspl:software-task]] --- as defined by RTIC, [[cref:rtic]] --- and enable emission of said trace stream from the device, by help of a target-side tracing library crate;
- \namedlabel{req:input}{Requirement 2}: :: <<req:input>> read the generated trace stream via a hardware debugger or a serial device;
- \namedlabel{req:decode}{Requirement 3}: :: <<req:decode>> decode the trace stream;
- \namedlabel{req:rtic}{Requirement 4}: :: <<req:rtic>> recover RTIC application metadata not contained within the trace stream;
- \namedlabel{req:timestamps}{Requirement 5}: :: <<req:timestamps>> associate timestamps to RTIC task events;
- \namedlabel{req:protocol}{Requirement 6}: :: <<req:protocol>> report RTIC task events to the RTIC Scope end-user by use of a defined communication protocol.
- \namedlabel{req:dummy}{Requirement 7}: :: <<req:dummy>> offer a reference implementation of a [[gls:frontend]] which implements the protocol described in [[req:protocol]];
- \namedlabel{req:record}{Requirement 8}: :: <<req:record>> record a trace to file which can be replayed offline (i.e. without executing code on the target) by use of a host-side [[gls:daemon]]; and
- \namedlabel{req:cargo}{Requirement 9}: :: <<req:cargo>> be invoked as a =cargo= subcommand.

Delimitations to the above requirements apply, see [[cref:delimitations]].
*** Delimitations
:PROPERTIES:
:CUSTOM_ID: delimitations
:END:
In order to focus on the delivery of a robust toolset with proper implementation and documentation the scope of this thesis have been limited.
These delimitations are related to the requirements described in [[cref:requirements]] and are below enumerated.
1. [[req:itm-gen]]: RTIC Scope *MUST* apply the device configuration that are common to all ARMv7-M [[glspl:MCU]] in order to enable [[gls:trace-stream]] generation and emission.
   RTIC Scope *SHOULD NOT* apply device-specific configurations.
2. [[req:input]]: RTIC Scope *SHOULD NOT* have to ensure that a trace stream is actually read from the device:
   it falls on the RTIC Scope end-user to establish a connection between the target and the host.
   However, RTIC Scope *MUST* fail or warn the end-user if it is unable to correctly decode the read data stream.
3. [[req:rtic]]: RTIC Scope *MUST* only support [[gls:RTIC]] version 1;
   refer to [[textcite:&rtic]].
   RTIC Scope *MUST* recover the RTIC application metadata necessary to report the timestamped state changes of hardware and software tasks as declared by the user's RTIC application and supplied metadata.
4. [[req:protocol]]: The defined communication protocol *MUST* enable one-way communication from the =cargo= subcommand [[gls:backend]] to the reference [[gls:frontend]].
   The protocol *SHOULD NOT* enable two-way communication.

Following the above delimitations allows this thesis to be finished within an acceptable time frame and also yield a documented code base which allows future development with reduced friction.

*** Contributions
:PROPERTIES:
:CUSTOM_ID: contribs
:END:
The development of RTIC Scope has yielded a number of [[gls:downstream]] contributions, namely a collection of crates:
- =cargo-rtic-scope= :: A =cargo= subcommand acting as the RTIC Scope [[gls:backend]] which fulfills [[req:input]] to [[req:protocol]] and [[req:record]] to [[req:cargo]].
  See [[cref:impl:cargo-rtic-scope]] and [[textcite:&rtic-scope:cargo-rtic-scope]].
- =rtic-scope-frontend-dummy= :: A reference implementation of a RTIC Scope [[gls:frontend]], which fulfills [[req:dummy]].
  See [[cref:impl:rtic-scope-frontend-dummy]] and [[textcite:&rtic-scope:dummy]].
- =rtic-scope-api= :: The protocol that =cargo-rtic-scope= uses to report [[gls:RTIC]] [[gls:task]] events to =rtic-scope-frontend-dummy=, as described by [[req:protocol]].
  See [[textcite:&rtic-scope:api]].
- =cortex-m-rtic-trace= :: An auxiliary target-side crate that properly configures the device for [[gls:trace-stream]] generation and emission, which fulfills [[req:itm-gen]].
  See [[cref:impl:rtic-trace]] and [[textcite:&rtic-scope:rtic-trace]].
- =itm= :: A library crate for decoding the trace stream emitted from the embedded system, which fulfill Requirements [[req:decode]] and [[req:timestamps]] (partially).
  See [[cref:impl:itm]] and [[textcite:&itm]].

Of certain note is =itm= which =cargo-rtic-scope= relies on: its implementation is disjoint from RTIC and can be used independently of RTIC Scope.
=itm= can also be used to decode trace stream generated by a target using an [[gls:RTOS]] other than RTIC.
Because of this general nature and detachment from both RTIC and RTIC Scope it must not necessarily be a part of the RTIC Scope project itself, but is as of writing for reasons of development convenience.
See [[cref:disc:itm-embedded-wg]] for a discussion on under what banner =itm= belongs.

Further, a number of [[gls:upstream]] contributions have been made to the crates which RTIC Scope depends on.
An exhaustive summary of these contributions are described below (listed in no particular order).

- =probe-rs/probe-rs= ::
  A "a modern, embedded debugging toolkit, written in Rust" [[parencite:&probe-rs]] utilized to partially fulfill [[req:input]].
  Contributions are:
  - Reintroduce CargoOptions in mod common\textunderscore options: :: patch set included in a larger refactor [[parencite:&pr:probe-rs:760]].
  - arm: enable exception trace on setup\textunderscore swv: :: improves tracing support for ARM targets [[parencite:&pr:probe-rs:758]].
  - cargo: bump bitvec: :: updates a dependency [[parencite:&pr:probe-rs:757]].
  - arm/itm: doc fields, enable global timestamps: :: improves documentation and tracing support for ARM targets [[parencite:&pr:probe-rs:728]].
  - Add generic probe/session logic from cargo-flash: :: improves composability with RTIC Scope [[parencite:&pr:probe-rs:723]].
  - deprecate internal ITM/DWT packet decoder in favour of itm-decode: :: replaces an unfinished internal trace stream decoder with an =itm= precursor; see [[cref:impl:itm]] [[parencite:&pr:probe-rs:564]].

  Refer to [[cref:impl:cargo-rtic-scope]] for how RTIC Scope applies this toolkit.
- =probe-rs/cargo-flash= ::
  A "cargo extension for programming microcontrollers" [[parencite:&cargo-flash]], functionality of which is used by =cargo-rtic-scope=.
  Contributions are:
  - move probe, session logic, flash downloader to probe-rs-cli-util: :: moves functionality from =cargo-flash= to an auxiliary =probe-rs= library crate such that they can be utilized by =cargo-rtic-scope= [[parencite:&pr:cargo-flash:188]].

- =rust-embedded/cortex-m= :: A library crate that enables "low level access to Cortex-M processors" [[parencite:&cortex-m]], utilized to fulfill [[req:itm-gen]], [[req:decode]] and [[req:record]].
  Contributions are:
  - scb: derive serde, Hash, PartialOrd for VectActive behind gates: :: adds features used by =itm= [[parencite:&pr:cortex-m:363]].
  - Implement various interfaces for trace configuration: :: adds features used by =cortex-m-rtic-trace= [[parencite:&pr:cortex-m:342]].
  - TPIU: swo\textunderscore supports: make struct fields public, improve documentation; :: fixes an issue in a library module and improves documentation [[parencite:&pr:cortex-m:381]].
  - CHANGELOG: add missing items: :: adds documentation about added features [[parencite:&pr:cortex-m:378]].
  - itm: derive serde for LocalTimestampOptions, impl gated TryFrom<u8>: :: adds features used by =cargo-rtic-scope=  [[parencite:&pr:cortex-m:366]].
  - ITM: check feature support during configuration, add busy flag, docs improvement: :: ensures hardware support during trace stream generation configuration [[parencite:&pr:cortex-m:383]].

  Refer to [[cref:impl:rtic-trace]] and [[cref:impl:itm]] for a detailed description of the usage of this library.
- =rtic-rs/rtic-syntax= :: A crate that defines and parses the RTIC meta language [[parencite:&rtic-syntax]], utilized to fulfill [[req:rtic]].
  Contributions are:
  - improve error string if parse\textunderscore binds is not set: :: improves run-time documentation when the crate is used as a library [[parencite:&pr:rtic-syntax:47]].
- =rtic-rs/cortex-m-rtic= :: The RTIC implementation for Cortex-M platforms [[parencite:&rtic]].
  Contributions are:
  - book/migration/v5: update init signature, fix example syntax: :: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:480]].
  - book: detail import resolving for 0.6 migration: :: improves documentation for migration to a now-deprecated version of RTIC [[parencite:&pr:rtic:479]].
  - book: update outdated required init signature: :: improves RTIC examples in documentation [[parencite:&pr:rtic:478]].
- =Michael-F-Bryan/include_dir= :: A crate for embedding file trees in a binary [[parencite:&includedir]], utilized to fulfill [[req:rtic]].
  Contributions are:
  - Dir: add extract-to-filesystem functionality: :: implements functionality for extracting embedded file trees to disk [[parencite:&pr:includedir:57]].
  - dir/extract: add mode for overwriting existing files: :: implements functionality for overwriting existing files when extracting embedded file trees to disk [[parencite:&pr:includedir:65]].

*** Outline
 This paper is structured as follows:
 - [[cref:introduction]], Introduction :: provides a background introduction to Rust, the embedded Rust ecosystem and [[gls:RTIC]].
   Subsequently, covers the project motivation, problem definition, delimitations and contributions made within the scope of this thesis, and guidelines on how to read this text.
 - [[cref:prev-work]], Previous and Related work :: presents work previously done in the same domain, which this thesis builds upon, and some tools with similar feature sets of RTIC Scope.
 - [[cref:theory]], Theory :: covers the ARMv7-M debug facilities, the [[gls:ITM]] packet protocol and how RTIC [[glspl:task]] are traced in theory via RTIC Scope.
 - [[cref:impl]], Implementation :: covers the implementation of RTIC Scope and the auxiliary =itm= crate.
 - [[cref:results]], Results :: covers the results of this thesis and applies RTIC Scope to a trivial RTIC application.
 - [[cref:discussion]], Discussion :: discusses some topics of interests regarding RTIC Scope, and a choice selection of topics for further development.
 - [[cref:conclusion]], Conclusions :: summarizes the work done in this thesis.

*** Reading guidelines
:PROPERTIES:
:CUSTOM_ID: reading-guidelines
:END:
# cover important typesetting such as glossary use. When and why not all terms are linked to the glossary.
Terms that warrant further description in this text are referred to the glossary on its first occurrence in a section, along with their use in the section title and captions of tables, listings, and figures.
In flowing text some occurrences stray from this pattern.
For example, when "[[gls:task]]" links to the glossary the terms "software task" and "hardware task" may not due to the shared relationship between these terms.
For acronyms, the first occurrence is written in full form and subsequent in its short form; e.g.,
#+begin_quote
\glsxtrfull{RTIC} is a \textelp{}

RTIC also \textelp{}
#+end_quote
and in a subsequent section:
#+begin_quote
As previously mentioned, \gls{RTIC} \textelp{}
#+end_quote

There are exceptions to the rules above where a full acronym form or overzealous term definition is warranted.

Throughout this text the keywords *MUST*, *SHOULD*, and *SHOULD NOT* are used to describe requirements levels;
these should be interpreted as covered in [[textcite:&rfc2119]].

When register fields are referred to, their names are /EMPHASIZED/.

When command line arguments are typeset, square brackets indicate that the argument is optional, whereas angle brackets indicate a required argument.
For example, in [[cref:lst:argument-typesetting]]:
=binary= and =feat1= are required arguments, specified without the surrounding angle brackets;
=feat2= and =feat3= are optional arguments, specified without the surrounding square bracket, separated with a comma, where =[...]= indicate that any number of further arguments can be specified;
and =[options...]= are any other arguments the invoker may want to pass.
#+NAME: lst:argument-typesetting
#+CAPTION: Example invocation of ~cargo build~.
#+begin_src shell
  cargo build --bin <binary> --features <feat1>[,feat2[,feat3[...]]] [options...]
#+end_src

Namespaces, typeset with the =::=-separator, are interpreted just as they are in Rust.
For example: =PAC::Interrupt= refers to the =Interrupt= enum in the crate =PAC= (capitalized to denote generalization),
and =foo::bar= can refer to the function =bar= in the crate =foo=.
The context of these notations point out whether a function, enum, or some other language construct is referred to.

** Previous and Related Work
:PROPERTIES:
:CUSTOM_ID: prev-work
:END:
This chapter briefly covers previous work upon which RTIC Scope is based and related work.
*** Previous work
The implementation of RTIC Scope stands of the shoulders of countless developers that have enabled the implementation of the toolset within the frame of this thesis.
Notable libraries are referred to inline throughout this text.
When citing software, the three authors with the most contributions (in decreasing order) at the time of writing are cited as the authors of that software.

*** Related work
Some toolsets similar to RTIC Scope were already available before the start of this thesis, namely:
- orbuculum :: an "[ARM] Cortex-M trace stream demuxer and post-processor" [[parencite:&orbuculum]];
- Percepio Tracealyzer :: a proprietary visual trace diagnostic tool that supports a multitude of platforms and [[glspl:RTOS]] [[parencite:&tracealyzer]].
Neither of the above tools support [[gls:RTIC]] at the time of writing and were not investigated further.

** Theory
:PROPERTIES:
:CUSTOM_ID: theory
:END:
This chapter covers the purpose and usage of the utilized ARMv7-M debug peripherals, relevant sections of the [[gls:ITM]] packet protocol and how [[gls:RTIC]] [[glspl:task]] are traced.
*** ARMv7-M debug facilities
:PROPERTIES:
:CUSTOM_ID: debug-periphs
:END:
This section summarizes the hardware peripherals responsible for the generation and emission of the [[gls:ITM]] packet protocol.
The relationship of these peripherals is also presented.
This section is not exhaustive for the sake of brevity.
For full information on each peripheral, refer to the respective sections in [[textcite:&arm-rm]].
See [[cref:theory:itm-proto]] for a description of the ITM packet protocol.

# DWT -> ITM -> TPIU -> ETB.
RTIC Scope utilizes the [[gls:DWT]], ITM, and [[gls:TPIU]] peripherals for on-target trace generation and emission.
The DWT and ITM peripherals are sources of ITM protocol packets which are forwarded to the TPIU for device emission.
The ITM multiplexes packets emitted by itself and the DWT, and generates timestamp packets in order to establish a time-line of events that occurred on the traced target.
The relationship of these peripherals are visualized in [[cref:fig:debug-relations]].

#+BEGIN_src latex
  \begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, auto]
    \node[block] (clock) {timestamp clock};
    \node[block, below=0.5cm of clock] (itm) {\gls{ITM} \\ (timestamps, \\ multiplexing, etc.), \\ \cref{theory:itm-periph}};
    \node[block, left=of itm] (dwt) {\gls{DWT} \\ (hardware events), \\ \cref{theory:dwt}};
    \node[block, right=of itm] (tpiu) {\gls{TPIU} \\ (serialization), \\ \cref{theory:tpiu}};
    \node[block, above=0.5cm of tpiu] (prescaler) {\gls{prescaler}: $/n$};
    \node[block, above=0.5cm of prescaler] (freq) {reference \\ clock $\left[\text{Hz}\right]$};
    \node[below=of tpiu.south east] (swo) {\gls{SWO}, \\ \cref{theory:swo}};
    \node[below=of tpiu.south west] (parallel) {parallel trace \\ output};
    \path[->]
    (dwt) edge (itm)
    (clock) edge (itm)
    (itm) edge (tpiu)
    (freq) edge (prescaler)
    (prescaler) edge (tpiu);

    %% box
    \node[above=0.5cm of clock] (target) {target configured with \\ \texttt{cortex-m-rtic-trace}, \\ \cref{impl:rtic-trace}};
    \draw[dotted,fill=yellow,fill opacity=0.2] let \p1=($(dwt.west)+(-0.3,0)$), \p2=($(target.north)+(0.0,0.3)$), \p3=($(tpiu.south east)+(0.3,-0.3)$), \p4=($(itm.south)+(0,-0.3)$) in (\x1, \y2) rectangle (\x3, \y4);

    %% anchors
    \node[below=0.2cm of tpiu.south west] (parallel-anchor) {};
    \node[below=0.2cm of tpiu.south east] (swo-anchor) {};
    \draw[-] ($(tpiu.south west)!0.5!(tpiu.south)$) |- (parallel-anchor.center);
    \draw[-] ($(tpiu.south east)!0.5!(tpiu.south)$) |- (swo-anchor.center);
    \path[->] (swo-anchor.center) edge (swo);
    \path[->] (parallel-anchor.center) edge (parallel);

  \end{tikzpicture}
  \caption{\label{fig:debug-relations}\Gls{downstream} relationship between ARMv7-M debug peripherals used for \gls{tracing}.
    \Glspl{hardware-event-packet} from the \gls{DWT} are forwarded to the \gls{ITM} which are subsequently forwarded to the \gls{TPIU} with an attached timestamp generated by the \gls{ITM}.
    The \gls{TPIU} serializes the \gls{ITM} protocol packets over \gls{SWO} or a parallel trace output by help of a reference clock divided by a \gls{prescaler} ($n \geq 1$ is an integer).
    In this text only the \gls{SWO} is considered.}
  \end{figure}
#+END_src

**** \glsxtrfull{DWT}
:PROPERTIES:
:CUSTOM_ID: theory:dwt
:END:
# What does the DWT do and how do we use it?
The [[gls:DWT]] peripheral concerns itself with hardware events and react to these accordingly depending on the applied configuration.
For the purpose of RTIC Scope the DWT is configured to emit [[glspl:hardware-event-packet]] on two types of events: when
- a configured range of memory is accessed (known as [[gls:data-tracing]]); and
- whenever the processor enters, exits, and returns to an [[gls:exception]] handler (known as [[gls:exception-tracing]]).
Within this text the range of memory used for data tracing is referred to as a [[gls:watch-address]]:
when a value is written to a watch address --- the [[gls:watch-variable]] --- a data trace packet is generated containing the written value.

In order to monitor a watch address a DWT hardware comparator must be used.
An ARMv7-M [[gls:MCU]] offers $0 \leq n \leq 15$ such comparators, where $n$ is the index of the comparator in memory and the DWT comparator identity number.
RTIC Scope v0.3 requires two comparators for the purpose of [[gls:tracing]] [[glspl:software-task]].

Refer to [[textcite:&arm-rm Section C1.8]] for more information on the DWT unit.
**** \glsxtrfull{ITM}
:PROPERTIES:
:CUSTOM_ID: theory:itm-periph
:END:
# Summarize ITM functionality
The [[gls:ITM]] is of an auxiliary nature with three functions:
- the multiplexing of [[glspl:hardware-event-packet]] from the [[gls:DWT]] with its own packets which are then forwarded to the [[gls:TPIU]];
- control and generation of timestamp packets; and
- exposure of a memory-mapped register interface that allows logging of arbitrary data via a maximum of 256 stimulus registers[fn:: Not utilized by RTIC Scope.].

# Summarize the timestamp sources
Timestamp packets are sourced from a reference clock which can be seen in [[cref:fig:debug-relations]].
This reference clock is either the [[gls:system-clock]], an asynchronous TPIU reference clock, or a "global timestamp clock"[fn:: See [[cref:fut:review-timestamp-relation]].].
The frequencies and behavior of these reference clocks and how the target clock hierarchy is configured in general is wholly specific to each target and will thus not be covered in further detail.

For more information on the ITM unit, refer to [[parencite:&arm-rm Section C1.7]].
**** \glsxtrfull{TPIU}
:PROPERTIES:
:CUSTOM_ID: theory:tpiu
:END:
# Summarize TPIU functionality
The [[gls:TPIU]] provides external visibility of the trace packet stream by asynchronously serializing them on a single pin --- the [[gls:SWO]] --- by help of a prescaled reference clock, see [[cref:fig:debug-relations]].
In order to communicate over an asynchronous serial channel the [[gls:baud-rate]] must be communicated out-of-band: it must be pre-configured both target-side and host-side.
The signal emitted on the SWO can be configured for either the level-inverted [[gls:RS-232]] serial data-byte protocol or Manchester encoding protocol [[parencite:&art Section 14.7.9]].

For more information on the TPIU, refer to [[parencite:&arm-rm Section C1.10]].
*** The \glsxtrfull{ITM} packet protocol
:PROPERTIES:
:CUSTOM_ID: theory:itm-proto
:END:
The [[gls:ITM]] packet protocol is used by RTIC Scope to garner insight about the executing RTIC application.
This protocol defines packets that contain a one-byte /header/, which describes what type of data a certain packet contains; how long the packet /payload/ is, a byte multiple; and the packet payload.
Some headers also contain payload.
The protocol effectively implements a [[gls:TLV]] encoding scheme.
This section covers the packet types that RTIC Scope exploits and provide graphical representations ([[crefrange:fig:lts1,fig:data-trace-packet]]) of these packets, sourced from [[textcite:&arm-rm]].
Within all of these representations, the /C/ flag indicate whether a decoder should interpret the next byte in the trace stream as a part of the current packet:
if /C/ is not set, the next byte in the stream is a header for the next packet.

For other packet types, and a full description of the protocol, see [[textcite:&arm-rm Part D4]].

RTIC Scope v0.3 concerns itself with six packets:
- [[gls:GTS1]] :: A timestamp packet containing the lower 26 bits of the absolute timestamp.
- [[gls:GTS2]] :: A timestamp packet containing the upper 22 or 38 bits of the absolute timestamp, depending on the hardware implementation.
- [[gls:LTS1]] :: A multi-byte timestamp packet containing the relative timestamp.
- [[gls:LTS2]] :: A single-byte timestamp packet containing the relative timestamp.
- Exception trace packet :: A [[gls:hardware-event-packet]] describing the status of an interrupt handler. See [[cref:theory:itm:exceptions]]
- Data trace data value packet format :: A [[gls:hardware-event-packet]] describing the value read or written to a [[gls:watch-address]] monitored by a [[gls:DWT]] comparator. See [[cref:theory:itm:data-trace]].
For timestamp packets, see [[cref:theory:itm:timestamps]].

**** Timestamp packets
:PROPERTIES:
:CUSTOM_ID: theory:itm:timestamps
:END:
Timestamp packets come in two types: absolute and relative.
Both types derive their timestamps from one or more reference clocks (see [[cref:theory:itm-periph]]):
absolute timestamps denote how many ticks this clock have tocked ever since it was connected to the [[gls:ITM]]; and
relative timestamps denote how many ticks this clock have tocked ever since the last relative timestamp.
When a relative timestamp is generated the relative timestamp counter is reset.
This type separation is done in order to decrease the required bandwidth to communicate the time on the system.
Absolute and relative timestamps are further divided into a total of four different packets, summarized above and detailed below.

Global timestamps come in three flavors: 48-bit, 64-bit, or not at all (omitted).
Whether global timestamp support is implemented, and the size of this timestamp, depends on the hardware implementation of the [[gls:ITM]].

The two packets that constitute a global timestamp, [[gls:GTS1]] and [[gls:GTS2]], are sent separately and not necessarily in order.
A GTS2 packet is not emitted unless any of the bits in the 26--47 or 26--64 range have changed.
The GTS1 packet also contains two flags aside from the lesser significant 25 bits:
- /ClkCh/ :: Set if the system which the ITM is tracing has changed clock input to the processor since the last global timestamp packet.
  A full global timestamp follows in the stream if this flag is set.
- /Wrap/ :: Set if the more significant bits above the 25th have changed since the last GTS2 packets.
If either of the flags are set the GTS1 should be recorded until the next GTS2 is received so that the full timestamp can be decoded.
[[cref:fig:gts1]], [[cref:fig:gts2-48]], and [[cref:fig:gts2-64]] visually describes the GTS1, GTS2 (48-bit) and GTS2 (64-bit) packets, respectively.

Global timestamps can be generated periodically; or after each packet, if space is available in the queue.

#+NAME: fig:gts1
#+CAPTION: \gls{GTS1} packet format, copied from [[textcite:&arm-rm Figure D4-7]].
[[file:svgs/gts1.pdf]]
#+NAME: fig:gts2-48
#+CAPTION: \gls{GTS2} 48-bit packet format, copied from [[textcite:&arm-rm Figure D4-8]].
[[file:svgs/gts2-48.pdf]]
#+NAME: fig:gts2-64
#+CAPTION: \gls{GTS2} 64-bit packet format, copied from [[textcite:&arm-rm Figure D4-9]].
[[file:svgs/gts2-64.pdf]]

The two local timestamps, [[gls:LTS1]] and [[gls:LTS2]], are not complementary:
instead they supply a different maximum relative timestamp.
LTS1 provide a relative timestamp value that can be represented with 28 bits and is between 2--5 bytes long (header included).
LTS2 is a single-byte packet with a relative timestamp that can be represented with 3 bits that are provided in the header.
More specifically, an LTS2 can represent a relative timestamp value of 1--6;
clashes with headers for other types of packets would occur if the value was 0 or 7.
LTS1 also contain a 2-bit /TC/ field which describes the relationship of the timestamp value with the corresponding non-timestamp packet(s).
This flag has four possible values, termed /qualities/ throughout this text, described in decreasing quality:
- /TC/ $=$ 0b00 :: Synchronous: the timestamp value denotes the time when the non-timestamp packet was generated.
- /TC/ $=$ 0b01 :: Delayed relative: the timestamp value denotes the time when the timestamp packet itself was generated.
  The synchronous timestamp is here unknown but must be between the previous and current timestamp values.
- /TC/ $=$ 0b10 :: Synchronous, but the corresponding non-timestamp packet generation was delayed relative to the associated event.
- /TC/ $=$ 0b11 :: Delayed relative, and the corresponding non-timestamp packet generation was delayed relative to the associated event.
LTS2 packets are always synchronous.

Local timestamps are emitted after the corresponding non-timestamp packets.
For example, if the sequence reads
#+begin_export latex
\begin{multicols}{3}
#+end_export
1. data packet 1;
2. LTS1;
3. data packet 2;
4. data packet 3; and
5. LTS2,
#+begin_export latex
\end{multicols}
\noindent
#+end_export
then the LTS1 corresponds to data packet 1;
and LTS2 to data packet 2 and 3.

#+NAME: fig:lts1
#+CAPTION: \gls{LTS1} packet format, copied from [[textcite:&arm-rm Figure D4-4]].
[[file:svgs/lts1.pdf]]
#+NAME: fig:lts2
#+CAPTION: \gls{LTS2} packet format, copied from [[textcite:&arm-rm Figure D4-6]].
[[file:svgs/lts2.pdf]]

**** Exception trace packets
:PROPERTIES:
:CUSTOM_ID: theory:itm:exceptions
:END:
The exception trace packet ([[cref:fig:exception-packet]]) describes the state of the system's interrupt handlers and are emitted upon such a state change.
Its payload contains two fields:
- /ExceptionNumber/ :: A 7-bit field describing which interrupt handler changed state.
  This field it decoded via [[cref:tbl:irqns]].[fn:exception-number-0]
- /FN/ :: A 2-bit field describing the action taken by the processor regarding the interrupt handler.
  This field can have three possible values:
  - /FN/ $=$ 0b01 :: the exception was entered;
  - /FN/ $=$ 0b10 :: the exception was exited; or
  - /FN/ $=$ 0b11 :: the exception was returned to.
    This action indicates that exception was previously preempted by an exception of higher priority which has now exited.

#+NAME: fig:exception-packet
#+CAPTION: Exception trace packet format, copied from [[textcite:&arm-rm Figure D4-16]].
[[file:svgs/exception-trace.pdf]]
#+CAPTION: ARMv7-M [[gls:exception]] numbers their corresponding labels. From [[textcite:&arm-rm Table B1-4]].
#+NAME: tbl:irqns
| Exception number | Exception label        |
|------------------+------------------------|
|                1 | Reset                  |
|                2 | NMI                    |
|                3 | HardFault              |
|                4 | MemManage              |
|                5 | BusFault               |
|             7-10 | Reserved               |
|               11 | SVCall                 |
|               12 | DebugMonitor           |
|               13 | Reserved               |
|               14 | PendSV                 |
|               15 | SysTick                |
|               16 | External interrupt 0   |
|                . | .                      |
|                . | .                      |
|                . | .                      |
|         16 + $N$ | External interrupt $N$ |
|------------------+------------------------|

**** Data trace data value packets
:PROPERTIES:
:CUSTOM_ID: theory:itm:data-trace
:END:
The data trace data value packet format packet ([[cref:fig:data-trace-packet]]), henceforth referred to as the /data trace packet/, are emitted when the processor accesses a [[gls:watch-address]] after appropriate [[gls:DWT]] comparator configuration (see [[cref:impl:rtic-trace]]).
The payload contains three fields of information:
- /CMPN/ :: A 2-bit identifier of the DWT comparator which matched the configured watch address access.
  This identifier is the same as the comparator offset specified in [[cref:impl:rtic-trace]].
- /WnR/ :: A flag describing whether the access was a read (not set) or write (set).
- /VALUE/ :: The value that was written to the address.
  The length of /VALUE/ is the same number of bytes accessed by the target hardware.
  If only a single byte is read/written by the target, then /VALUE/ is also one byte long.

#+NAME: fig:data-trace-packet
#+CAPTION: Data trace data value packet format, copied from [[textcite:&arm-rm Figure D4-22]].
[[file:svgs/data-trace.pdf]]

*** Deserializing the \glsxtrfull{SWO}
:PROPERTIES:
:CUSTOM_ID: theory:swo
:END:

In order to record and interpret the [[gls:trace-stream]] emitted by the target on the host-side the [[gls:RS-232]] on the [[gls:SWO]] pin must be deserialized.
Commonly, this is realized by use of an FT232H [[gls:IC]] (or equivalent) from FTDI which exposes a [[gls:USB]]-interface for the host.
When connected to a Linux host, the interface appears as a serial device under =/dev/ttyUSB*=[fn:: On the author's host system.] which RTIC Scope can configure and read the trace stream from.

The provision of a schematic that constitutes an RS-232-to-USB converter is outside the scope of this thesis[fn:: In part due to the [[gls:MCU]]-specific voltage levels that constitute the RS-232 signal.];
refer instead to [[textcite:&ft232]].

*** Tracing \glsxtrfull{RTIC} tasks
# How tasks are traced, summarized
Because [[gls:RTIC]] implements [[glspl:task]] by use of [[gls:exception]] handlers it is only natural to exploit [[gls:exception-tracing]] in order to trace the tasks abstracted above them.
This approach is however only directly applicable to [[glspl:hardware-task]] which dedicate a handler for each task.
[[Glspl:software-task]] are implemented with an additional layer of abstraction above handlers by use of [[glspl:task-dispatcher]] as covered in [[cref:rtic]].
If exception tracing is employed to trace software tasks such a [[gls:trace-packet]] would only describe that one of the potentially multiple software tasks handled by one dispatcher changed state.
Instead, a [[gls:UTID]] is assigned to each software task and written to a [[gls:watch-address]] when the task enters and exits.
An additional decoding step is then applied to map UTIDs back to their corresponding software tasks. Refer to [[cref:impl]].

** Implementation
:PROPERTIES:
:CUSTOM_ID: impl
:END:
This chapter covers the implementation of =cortex-m-rtic-trace=, =cargo-rtic-scope=, =rtic-scope-api=, and =rtic-scope-frontend-dummy= of RTIC Scope and the implementation of =itm=.
The implementation is presented in a [[gls:downstream]] manner, similar to the order in which the RTIC Scope crates are applied and how the trace data flows.
That is, how
1. =cortex-m-rtic-trace= is applied on the target-side and what it does;
2. =cargo-rtic-scope= recovers metadata from the [[gls:RTIC]] application and how it reads the byte-raw [[gls:trace-stream]] from the source;
3. =itm= decodes this stream into manageable Rust structures;
4. =cargo-rtic-scope= recovers RTIC metadata for the decoded trace stream;
5. this resolved (or previously recorded) trace stream is forwarded to [[glspl:frontend]] as =rtic-scope-api= structures; and
6. how a frontend handles a trace stream.

A graphical representation this data flow can be seen in [[cref:fig:rtic-scope-data-flow]].

As mentioned in [[cref:delimitations]], this chapter covers v0.3 of RTIC Scope.

#+BEGIN_src latex
  \begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 2cm, auto]

    %% record stack
    \node[block] (tpiu) {\gls{TPIU}, \\ \cref{theory:tpiu}; \\ from~\cref{fig:debug-relations}};
    \node[above=0.5cm of tpiu] (target) {target configured with \\ \texttt{cortex-m-rtic-trace}, \\ \cref{impl:rtic-trace}};
    \draw[dotted,fill=yellow,fill opacity=0.2] let \p1=(target.north east), \p2=($(tpiu.south east)+(0.3,-0.3)$) in (target.north west) rectangle (\x1,\y2);
    \node[block, below=of tpiu] (serial-dev) {serial device, \\ \cref{theory:swo}};
    \path[->] (tpiu) edge node {\gls{SWO}, \\ \cref{theory:swo}} (serial-dev);
    \node[block, below=of serial-dev] (itm-crate) {\texttt{itm} crate, \\ \cref{impl:itm}};
    \path[->] (serial-dev) edge node {byte stream; \\ \cref{theory:itm-proto}} (itm-crate);
    \node[block, below left=of tpiu] (rtic-app-crate) {\gls{RTIC} application crate, \\ \crefrange{impl:cargo-rtic-scope:building-rtic-app}{impl:cargo-rtic-scope:read-manifest}};
    \node[block, below=of rtic-app-crate] (recovery-procedure) {recovery procedure, \\ \cref{impl:cargo-rtic-scope:generating-metadata-maps}};
    \path[->] (rtic-app-crate) edge node {crate manifest; \\ \gls{RTIC} application \\ declaration} (recovery-procedure);
    \node[block, below=of recovery-procedure] (record-source) {trace record source, \\ \cref{impl:cargo-rtic-scope:reading-the-trace-stream}};
    \path[->] (recovery-procedure) edge node {recovery maps; \\ trace metadata} (record-source);

    %% replay stack
    \node[block, below right=of tpiu] (replay-file) {replay file, \\ \cref{impl:cargo-rtic-scope:create-trace-file}};
    \node[block, below=of replay-file] (replay-source) {trace replay source, \\ \cref{impl:cargo-rtic-scope:replay}};
    \path[->,dashed] (replay-file) edge node {trace metadata; \\ recovery maps; \\ \texttt{itm} structures} (replay-source);
    \draw[->] (itm-crate.south) |- (record-source.east) node [near start] {\texttt{itm} structures};

    %% trace source anchor
    \node[below=3cm of itm-crate] (mux) {};

    %% run_loop
    \node[block, below=3cm of itm-crate] (run-loop) {\texttt{cargo-rtic-scope}: \\ \cref{impl:cargo-rtic-scope:spawning-frontends}, \\ \cref{impl:cargo-rtic-scope:flush-metadata}, and \\ \cref{impl:cargo-rtic-scope:trace-target}};
    \draw[-] (record-source.south) |- (run-loop.west);
    \draw[->,dashed] (replay-source.south) |- (run-loop.east);

    %% frontend anchors
    \node[below=1.5cm of run-loop] (mux-frontend) {};
    \path[-,dashdotted] (run-loop) edge node [left] {\gls{JSON} of \texttt{rtic-scope-api} \\ structures, \cref{impl:cargo-rtic-scope:trace-target}} (mux-frontend.center);
    \node[below=1cm of mux-frontend] (frontend-anchor) {};

    %% record feedback
    \node[below=0.5cm of run-loop.south east] (feedback1) {};
    \node[right=1.5cm of replay-file] (replay-anchor) {};
    \draw[-] ($(run-loop.south)!0.5!(run-loop.south east)$) |- (feedback1.center);
    \draw[-] (feedback1.center) -| (replay-anchor.center);
    \draw[->] (replay-anchor.center) -- (replay-file.east);

    %% frontends
    \node[block, left=0.5cm of frontend-anchor.center] (frontend2) {$2$nd frontend};
    \node[block, right=0.5cm of frontend-anchor.center] (frontends) {$n-1$th \\ frontend};
    \node[block, left=3.5cm of frontend-anchor.center] (frontend1) {$1$th frontend, \\ \cref{impl:rtic-scope-frontend-dummy}};
    \node[block, right=3.5cm of frontend-anchor.center] (frontendn) {$n$th frontend};
    \draw[->,dashdotted] (mux-frontend.center) -| (frontend1.north);
    \draw[->,dashdotted] ($(frontend2.north)+(0,0.75cm)$) -- (frontend2.north);
    \draw[->,dashdotted] ($(frontends.north)+(0,0.75cm)$) -- (frontends.north);
    \draw[->,dashdotted] (mux-frontend.center) -| (frontendn.north);
    \draw[thin,fill=gray,fill opacity=0.2] ($(frontend2.north west)+(-0.3,0.3)$) rectangle ($(frontendn.south east)+(0.3,-0.3)$);
  \end{tikzpicture}
  \caption{ \label{fig:rtic-scope-data-flow} \Gls{downstream} data flow in RTIC Scope.
    Data flow drawn with solid lines (\protect\tikz[baseline]{\protect\draw[-] (0,.5ex)--++(1,0) ;}) are operational during trace recording;
    dashed lines (\protect\tikz[baseline]{\protect\draw[-,dashed] (0,.5ex)--++(1,0) ;}) during trace replay; and
    dash-dotted lines (\protect\tikz[baseline]{\protect\draw[-,dashdotted] (0,.5ex)--++(1,0) ;}) during both trace recording and replay.
    During recording the trace is saved to a replay file.
    $n \geq 1$: grayed-out frontends (\protect\tikz[baseline]{\protect\draw[thin,fill=gray,fill opacity=0.2] (0,1ex) rectangle (1,0) ;}) are optional.
  }
  \end{figure}
#+END_src

*** ~cortex-m-rtic-trace~ and its application
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace
:END:
=cortex-m-rtic-trace= is an auxiliary target-side crate that configures all relevant Cortex-M peripherals for [[gls:tracing]], namely the [[gls:DCB]][fn:: A component of the [[gls:SCB]] peripheral.], [[gls:TPIU]], [[gls:DWT]], and [[gls:ITM]].
The crate exposes two functions:
- =cortex_m_rtic_trace::configure= :: a regular Rust function for configuration of the peripherals mentioned above; and
- =cortex_m_rtic_trace::trace= :: a Rust macro used to trace [[glspl:software-task]].
Henceforth, within this section these two functions will be referred to as =configure= and =trace=, respectively.

This section is divided into two parts: [[cref:impl:rtic-trace:peripheral-config]], which covers the application of =configure=; and [[cref:impl:rtic-trace:trace-macro]], which covers the application of the =trace= macro.

It is important to point out that =cortex-m-rtic-trace= is a crutch which incurs necessary [[gls:overhead]] in theory for the user.
On the RTIC Scope roadmap is thus the eventual deprecation of this crate. See [[cref:fut:rm-rtic-trace]] for more on this topic.

**** Peripheral configuration
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:peripheral-config
:END:
After applying device-specific configurations for trace generation and querying the frequency of the [[gls:TPIU]] reference clock, =configure= is applied as shown in [[cref:lst:rtic-trace:configure]].
#+NAME: lst:rtic-trace:configure
#+CAPTION: Example application of ~cortex_m_rtic_trace::configure~. Configuration covered in text.
#+begin_src rust
  #[init]
  fn init(mut ctx: init::Context) -> (SharedResources, LocalResources, init::Monotonics()) {
      // device-specific configurations for trace stream generation...

      let freq = {
          // device-specific query for the TPIU reference clock
          // frequency (or simply hard-coded)
      };

      use cortex_m_rtic_trace::{
          self, GlobalTimestampOptions, LocalTimestampOptions, TimestampClkSrc,
          TraceConfiguration, TraceProtocol,
      };

      // configure device-common tracing
      cortex_m_rtic_trace::configure(
          &mut ctx.core.DCB,
          &mut ctx.core.TPIU,
          &mut ctx.core.DWT,
          &mut ctx.core.ITM,
          1, // DWT comparator ID for software task enter events
          2, // DWT comparator ID for software task exit events
          &TraceConfiguration {
              delta_timestamps: LocalTimestampOptions::Enabled,
              absolute_timestamps: GlobalTimestampOptions::Disabled,
              timestamp_clk_src: TimestampClkSrc::AsyncTPIU,
              tpiu_freq: freq, // Hz
              tpiu_baud: 9600, // B/s; the baud rate of the SWO
              protocol: TraceProtocol::AsyncSWONRZ,
          },
      )
      .unwrap();

      // ...
  }
#+end_src

=configure= in [[cref:lst:rtic-trace:configure]] does a number of operations in the following order:
1. <<rtic-trace:conf-protocol>> ensures that the target's TPIU peripheral supports the requested =protocol= by reading the [[gls:TPIU_TYPE]] [[parencite:&arm-rm Section C1.10.6]];
2. ensures that the user did not request an invalid TPIU configuration (i.e. =tpiu_freq: 0= or =tpiu_baud: 0=);
3. <<rtic-trace:conf-exception-trace>> ensures that the target's [[gls:DWT]] peripheral supports exception tracing by reading a zero from the /NOTRCPKT/ bit in the [[gls:DWT_CTRL]] [[parencite:&arm-rm Section C1.8.7]];
4. <<rtic-trace:nofail-conf>> configures the [[gls:DCB]], TPIU, and DWT peripherals (partially):
   1. sets the /TRCENA/ bit in the [[gls:DCB_DEMCR]], a "global enable for all DWT and ITM features";
   2. calculates and writes a prescaler to the /SWOSCALER/ bit-range in the [[gls:TPIU_ACPR]] such that the TPIU communicates with a requested baud rate on the [[gls:SWO]] pin.
      The prescaler is calculated via [[cref:eq:prescaler]] derived from [[textcite:&arm-rm Section C1.10.4]].[fn:: This configuration implementation is error-prone: See [[cref:fut:swoscaler]].]
      #+NAME: eq:prescaler
      \begin{equation}
        \left\lfloor
        \frac{\texttt{tpiu\textunderscore freq}}{\texttt{tpiu\textunderscore baud}}
        \right\rfloor - 1
      \end{equation}
   3. drops any [[gls:ETM]][fn:: A debug facility similar to (but with finer granularity than) the ITM, but outside the scope of this thesis.] packets that the [[gls:TPIU]] would otherwise receive; and
   4. sets the /EXCTRCENA/ bit in [[gls:DWT_CTRL]] which enables the generation of [[gls:exception]] traces from the DWT [[parencite:&arm-rm Section C1.8.7]].
5. <<rtic-trace:itm>> Applies ITM-related options given to =configure= by writing to the [[gls:ITM_TCR]] while also checking for target support for the requested configuration [[parencite:&arm-rm Section C1.7.6]]:
   1. sets the /ITMENA/, /TXENA/, /SWOENA/, and /TSENA/ bits which enables the ITM, forwards trace packets from the DWT to the ITM, "enables asynchronous clocking of the timestamp counter", and enables the generation of local timestamps, respectively;
   2. writes 0 to the /TraceBusID/ field because RTIC Scope does not support multi-source tracing within the scope of this thesis[fn:: Writing 0 to this field is potentially invalid. See [[cref:fut:TraceBusID]].]
   3. writes 0 to the /TSPrescale/ field, using a [[gls:prescaler]] of $n = 1$ for local timestamps; and
   4. writes 0 to the /GTSFREQ/ field, disabling global timestamps.[fn:: Global timestamps are an optional feature, and is not supported by all Cortex-M targets.]
6. <<rtic-trace:dwt>> Configures DWT comparators for software task [[gls:tracing]]:
   1. first, resolves the addresses of two [[glspl:watch-variable]] which reside in scope of the =cortex-m-rtic-trace= crate;
   2. dereferences two DWT comparators as specified by the 5th and 6th arguments to =configure= in [[cref:lst:rtic-trace:configure]];[fn:: The [[gls:API]] for specifying these comparators can be greatly improved by passing them via the =TraceConfiguration= structure. Additionally and ideally, only a single comparator would be required; see [[cref:disc:perf]].]
   3. configures the first comparator to signal a match (and generate an associated [[gls:hardware-event-packet]]) when data is written to the first watch variable:
      1. writes to seven fields in the [[gls:DWT_FUNCTIONn]][fn:dwt-n] [[parencite:&arm-rm Section C1.8.17]], where $n$ is the offset of the comparator (in the context of [[cref:lst:rtic-trace:configure]], $n=1$):
         0b1101 to /FUNCTION/, configuring the comparator to match on address access;
         0 to /EMITRANGE/, disabling trace address packet generation;[fn:: We are not interested in the address that contains the watch variable.]
         0 to /DATAVMATCH/, to disable data value comparison[fn:not-of-concern];
         0 to /CYCMATCH/, to disable cycle counter comparison[fn:not-of-concern];
         and 0 to /DATAVSIZE/, /DATAVADDR0/, and /DATAVADDR1/ because these fields are [[gls:SBZ]] [[parencite:&arm-rm p. Glossary-855]] in address comparison context.
      2. writes the first watch variable address to [[gls:DWT_COMPn]][fn:dwt-n] (with $n = 1$), in order for the comparator to match on that address access; and
      3. writes 0 to [[gls:DWT_MASKn]][fn:dwt-n] ($n=1$), such that the comparator does not match on a range of addresses.
   4. Lastly, the second comparator is configured in the same manner as the first, but with the second watch variable address in mind and $n=2$.

If any step in [[crefrange:rtic-trace:conf-protocol,rtic-trace:conf-exception-trace]] fails =configure= prematurely returns an error that signals what went wrong, and no peripheral configuration will have been applied: the target will be in the same state as before =configure= was called.

Several fields in [[gls:ITM_TCR]] are potentially [[gls:RAZ-WI]], [[gls:RAZ]], or [[gls:RAO]] [[parencite:&arm-rm p. Glossary-854]] in order to signal hardware support.
This requires the field to be read after a write to ensure that a configuration was applied.
During the steps in [[cref:rtic-trace:itm]], if any read-back value does not match what was written, =configure= prematurely returns an error signalling what configuration component was not supported by the target and what components have been successfully applied, notifying the user that a partial configuration has now been applied.
It is up to the user to reset the target to the state before =configure= was called.[fn:: In practice, one would reset the target and iterate on the configuration instead of manually reverting the changes.]
For a discussion on this implementation detail, see [[textcite:&issue:cortex-m:382]].

The steps in \cref{rtic-trace:nofail-conf,rtic-trace:dwt} cannot fail.

Of certain note are the steps in [[cref:rtic-trace:dwt]] because of the dependency of variables in memory to trace software tasks, and how the watch variables in this section are aligned in memory.
The DWT comparators are configured to match on writes to singular addresses which are represented as =u32= variables.
However, due to performance reasons (and in order to reduce implementation complexity), the watch variables are represented as =u8= variables: only a single byte will be written to these 32-bit addresses during run-time tracing (see [[cref:impl:rtic-trace:trace-macro]]).
Further, because of time constrains no experimentation has been done with a non-zero mask: this requires the watch variables to be aligned to 32-bits. For more on the topic of performance, see [[cref:disc:perf]].

**** Tracing [[glspl:software-task]] with ~trace~
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:trace-macro
:END:
=trace= is an optional macro that is only required if [[gls:software-task]] [[gls:tracing]] is wanted.
Its application is trivial but requires that =configure= executed without error.
To trace a software task, consider [[cref:lst:rtic-trace:trace]] which defines two tasks: =task1= and =task2=.
Of the two tasks, =task2= is traced by simply decorating it with =#[trace]=, the invocation of the =trace= macro.
#+NAME: lst:rtic-trace:trace
#+CAPTION: Application example of the ~trace~ macro. ~task2~ is traced; ~task1~ is not.
#+begin_src rust
  // ...

  use cortex_m_rtic_trace::{self, trace};

  #[task]
  fn task1(_: task1::Context) {}

  #[task]
  #[trace]
  fn task2(_: task2::Context) {}

  // ...
#+end_src

Consider now [[cref:lst:rtic-trace:trace-expanded]], which is the result of expanding the macros applied in [[cref:lst:rtic-trace:trace]] via =cargo-expand= [[parencite:&cargo-expand]].
#+NAME: lst:rtic-trace:trace-expanded
#+CAPTION: Application example of the ~trace~ macro after macro expansion via ~cargo-expand~. Unrelated expansions omitted.
#+begin_src rust
  // ...
  use cortex_m_rtic_trace::{self, trace};
  // ...
  #[allow(non_snake_case)]
  fn task1(_: task1::Context) {
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
  }
  #[allow(non_snake_case)]
  fn task2(_: task2::Context) {
      ::cortex_m_rtic_trace::__write_enter_id(0);
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
      ::cortex_m_rtic_trace::__write_exit_id(0);
  }
  // ...
#+end_src

A traced software task writes a [[gls:UTID]]  to two [[glspl:watch-variable]] that signify that a task was entered or exited.
The UTIDs of an [[gls:RTIC]] application are calculated when the =trace= macro is expanded by the Rust compiler.
UTIDs are integers, starts counting from zero, and are incremented by one.

*** Recording a trace
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope
:END:
=cargo-rtic-scope= is a host-side [[gls:daemon]] that fulfills [[req:input]] to [[req:protocol]] and [[req:record]] to [[req:cargo]].
It is run as a =cargo= subcommand, as seen in [[cref:lst:cargo-rtic-scope:summary]], where =<verb>= is either =trace= or =replay=.
As the verbs imply, =trace= is used to record the trace emitted by an [[gls:RTIC]] application when executed on the target and =replay= is used to replay a trace for postmortem analysis.
#+NAME: lst:cargo-rtic-scope:summary
#+CAPTION: Summary of ~cargo-rtic-scope~ invocation as a ~cargo~ subcommand.
#+begin_src shell
  $ cargo rtic-scope [options...] <verb> [options...]
#+end_src

This section covers the options and implementation of the =trace= verb.

**** Section overview
The implementation responsible for recording and presenting a trace to the user is covered in 10 parts:
1. building the [[gls:RTIC]] application, [[cref:impl:cargo-rtic-scope:building-rtic-app]];
2. reading options from the cargo manifest, [[cref:impl:cargo-rtic-scope:read-manifest]];
3. creating a trace file, [[cref:impl:cargo-rtic-scope:create-trace-file]];
4. generating metadata maps, [[cref:impl:cargo-rtic-scope:generating-metadata-maps]];
5. spawning [[glspl:frontend]], [[cref:impl:cargo-rtic-scope:spawning-frontends]];
6. reading the trace from the target, [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]];
7. flashing the target (optional), [[cref:impl:cargo-rtic-scope:flash-target]];
8. flushing trace metadata to file, [[cref:impl:cargo-rtic-scope:flush-metadata]];
9. resetting the target (optional), [[cref:impl:cargo-rtic-scope:reset-target]]; and
10. tracing the target, [[cref:impl:cargo-rtic-scope:trace-target]].

**** Building the [[gls:RTIC]] application
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:building-rtic-app
:END:
The first step is to build the [[gls:RTIC]] application the user wants to trace.
This is done as a preparatory stage for [[crefrange:impl:cargo-rtic-scope:generating-metadata-maps,impl:cargo-rtic-scope:create-trace-file]] and [[cref:impl:cargo-rtic-scope:flash-target]];
and logically, if the application cannot be built, it cannot be traced so the process should prematurely end.
A benefit of building the RTIC application is the possibility of executing =cargo rtic-scope trace= like one would execute =cargo run=.

Upon a =trace=, the application is built via [[cref:lst:cargo-rtic-scope:build]], where =OPTIONS= are optional additional flags forwarded to =cargo build= from the invocation of =cargo rtic-scope trace=.
#+NAME: lst:cargo-rtic-scope:build
#+CAPTION: The build process of RTIC Scope. ~OPTIONS~ is a set of additional flags forwarded by ~cargo-rtic-scope~.
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi [OPTIONS...]
#+end_src
For example, if the crate would yield multiple binaries on build, =cargo rtic-scope trace= must know the singular binary which the user wants to trace.
Specifying this flag is done in the same way as for =cargo build=: via =--bin=.
[[cref:lst:cargo-rtic-scope:build-bin]] contains an example use of this option, which would yield the =cargo build= invocation in [[cref:lst:cargo-rtic-scope:build-bin-forwarded]].
#+NAME: lst:cargo-rtic-scope:build-bin
#+CAPTION: Invocation of ~cargo rtic-scope trace~ with the ~--bin~ option, forwarded to the underlying ~cargo build~ invocation in [[cref:lst:cargo-rtic-scope:build-bin-forwarded]].
#+begin_src shell
  $ cargo rtic-scope trace --bin my-rtic-application
#+end_src
#+NAME: lst:cargo-rtic-scope:build-bin-forwarded
#+CAPTION: The underlying ~cargo build~ invocation as a result of executing [[cref:lst:cargo-rtic-scope:build-bin]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application
#+end_src

Below are a description of the flags and options the user can specify during the invocation of =cargo rtic-scope trace= that are forwarded to the underlying =cargo build= invocation in [[cref:lst:cargo-rtic-scope:build]].
- =--bin <binary>= :: Used to specify which singular binary to build.
- =--example <example>= :: Used to build a singular example binary instead of a non-example binary.
- =--package <package>= :: Used to build a specific crate instead of a singular binary inside the top-level crate context.
  This crate should yield a single binary.
- =--release= :: Used to build the binary in release mode instead of debug mode. Optimizations are applied during build with this flag.
- =--target <target-triple>= :: Used to specify the target platform for which the binary should be built for. This option can be used to override the default target triple, or the one specified via the =/.cargo/config{,toml}= files.
- =--manifest-path <path>= :: Used to override the default path to the crate manifest, =Cargo.toml=.
- =--no-default-features= :: Used to disable all default features of the crate.
- =--all-features= :: Used to enable all features of the crate.
- =--features <feat1>[,feat2[,feat3[...]]]= :: Used to specify the set of features to enable for the crate.

The above flags and options were deemed as the most common flags a user would want to specify when building the RTIC application.
If the user wants to specify an option or flag that is not among the above set the sentinel =--= can be used.
For example, if the user invokes [[cref:lst:cargo-rtic-scope:sentinel]] =cargo-rtic-scope= invokes [[cref:lst:cargo-rtic-scope:sentinel-forwarded]].
#+NAME: lst:cargo-rtic-scope:sentinel
#+CAPTION: Example ~cargo rtic-scope trace~ invocation with an arbitrary ~cargo build~ argument.
#+begin_src shell
    $ cargo rtic-scope trace --bin my-rtic-application -- --some-cargo-build-flag
#+end_src
#+NAME: lst:cargo-rtic-scope:sentinel-forwarded
#+CAPTION: Resulting ~cargo build~ invocation on [[cref:lst:cargo-rtic-scope:sentinel]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application --some-cargo-build-flag
#+end_src
This approach ensures that the user can always build the RTIC application with any set of valid =cargo build= flags and options.

The effect of building with =--message-format=json-diagnostic-rendered-ansi= is that the otherwise human-readable output of =cargo build= is instead in [[gls:JSON]], a machine-readable format.
This JSON output describes build metadata, paths to binaries and their corresponding source files.
The path to the source file of the built application is used in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]];
the root path of the crate (metadata) in [[cref:impl:cargo-rtic-scope:create-trace-file]];
and the crate binary in [[cref:impl:cargo-rtic-scope:flash-target]].
=cargo_metadata= [[parencite:&cargo-metadata]] is used to parse this JSON output.

**** Reading options from the crate manifest
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:read-manifest
:END:
=cargo rtic-scope trace= requires some metadata about the [[gls:RTIC]] application from the user.
These are specified in the metadata block of the crate's manifest, =Cargo.toml=.
cref:lst:cargo-rtic-scope:manifest-metadata-example contains an example.
#+NAME: lst:cargo-rtic-scope:manifest-metadata-example
#+CAPTION: Example of the required user-supplied metadata used by RTIC Scope in the crate's manifest, ~Cargo.toml~.
#+begin_src toml
  [package.metadata.rtic-scope]
  pac_name = "atsamd51n"
  pac_features = []
  pac_version = "0.11"
  interrupt_path = "atsamd51n::Interrupt"
  tpiu_freq = 12000000
  tpiu_baud = 1000000
  dwt_enter_id = 1
  dwt_exit_id = 2
  lts_prescaler = 1
  expect_malformed = false
#+end_src

Of the fields in [[cref:lst:cargo-rtic-scope:manifest-metadata-example]] the below are utilized in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]],
#+begin_export latex
\begin{multicols}{2}
#+end_export
- =pac_name=
- =pac_features=
- =pac_version=
- =interrupt_path=
- =dwt_enter_id=
- =dwt_exit_id=
#+begin_export latex
\end{multicols}
\noindent
#+end_export
and the below in [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]] and [[cref:impl:itm]].
#+begin_export latex
\begin{multicols}{3}
#+end_export
- =tpiu_freq=
- =tpiu_baud=
- =lts_prescaler=
#+begin_export latex
\end{multicols}
\noindent
#+end_export
The last flag, =expect_malformed=, is a debug option utilized in [[cref:impl:cargo-rtic-scope:trace-target]].
Refer to the respective sections for a description of each field.

Manifest metadata is read via =cargo_metadata= [[parencite:&cargo-metadata]] and =serde_json= [[parencite:&serde-json]].

**** Creating a trace file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:create-trace-file
:END:
To enable postmortem analysis of a traced [[gls:RTIC]] application the recorded trace must be saved to disk.
The build step in [[cref:impl:cargo-rtic-scope:building-rtic-app]] yields the crate root of the application.
A natural directory in which to save trace files is then under =/target/= which otherwise contains all build artifacts of the crate.
For purposes of separation trace files are then saved under =/target/rtic-traces/=.

While =/target/= is meant for ephemeral artifacts --- of which recorded traces may not necessarily belong --- saving traces elsewhere could be considered unwanted behavior.
However, =/target/= is removed upon a =cargo clean=;
it is thus up to the user to ensure that traces of interest are saved to a persistent location.
For this purpose the optional =--trace-dir <dir>= option overrides the output directory of the trace files.

The trace filename contains three sections of information:
- the name of the RTIC application :: which associates the trace with the application that generated it, useful when a crate contains more than one application;
- the git revision of the local repository :: to associate the trace with the source code of the application; and
- a second-accurate timestamp :: to associate the trace with environmental factors that cannot be derived from the application name and revision.

For example, after some tracing and development during January 13th and 14th, 2022, the trace directory contains the files in [[cref:lst:cargo-rtic-scope:trace-example-files]].
#+NAME: lst:cargo-rtic-scope:trace-example-files
#+CAPTION: Example of recorded trace filenames after two traces. ~blinky~ is the name of the [[gls:RTIC]] application; ~124b3c5~ the git revision; and the remainder (sans ~.trace~) is the timestamp of the trace. The second trace file was recoded from an RTIC application with uncommitted changes, hence the ~-dirty~ suffix to the git revision.
#+begin_src text
  $ ls -ogh target/rtic-traces
  total 8.0K
  -rw-r--r-- 1 1.5K Jan 13 16:54 blinky-g124b3c5-2022-01-13T16:54:00.trace
  -rw-r--r-- 1 1.3K Jan 14 18:38 blinky-g124b3c5-dirty-2022-01-14T18:37:57.trace
#+end_src

In case two =cargo rtic-scope trace= instances are executed within the span of one second without any changes to the git repository the same filename will be generated twice;
this will be caught during the second instance which will exit with an error[fn:: A virtual limitation. The timestamp granularity can be increased, but from a user standpoint it is unlikely to start a trace twice within the same second using the same target and application.]:
=cargo-rtic-scope= does not overwrite trace files.
Trace files can however be explicitly deleted:
if the user wants to record a trace and remove all previously recorded traces in the trace directory =--clear-traces= can be specified.
This flag only deletes files with the =.trace= file extension.

**** Generating metadata maps
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:generating-metadata-maps
:END:
# Introduction: we must translate raw ITM data to RTIC run-time information.
As covered in [[cref:theory:itm-proto]], the [[gls:ITM]] packet protocol is used to trace [[gls:RTIC]] [[glspl:task]].
This protocol is not designed with RTIC in mind:
instead of information that can be directly associated to RTIC tasks, the protocol describes the identity of the [[gls:DWT]] comparator that signaled a write to a [[gls:watch-address]] along with the data written, used to signal a software task enter or exit.
Additionally, the protocol describes the [[gls:IRQ]] of the hardware tasks that enter or exit.
These pieces of information must be associated back to the tasks responsible for their emission in a preparatory recovery step.
This section covers this step which is divided into two parts:
1. the generation a =recovery::HardwareMap= for hardware tasks association, [[cref:impl:hardware-map]]; and
2. the generation a =recovery::SoftwareMap= for software tasks association, [[cref:impl:software-map]].
Together these two lookup maps constitute a full =recovery::TraceLookupMaps= which is used by =recovery::TraceMetadata= in order to fulfill [[req:rtic]].

***** Generating the ~recovery::HardwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:hardware-map
:END:
# Overview: what to we need?
In order to generate a =recovery::HardwareMap= the [[gls:RTIC]] application declaration must be parsed.
This is first done when the application is built in [[cref:impl:cargo-rtic-scope:building-rtic-app]] via =rtic::app= macro expansion by =rtic_syntax::parse{,2}= [[parencite:&rtic]] which yields an =rtic_syntax::ast::App= [[parencite:&rtic-syntax]] structure used internally to verify the declaration and ultimately yield expanded code.
While the structure contains all the information =cargo rtic-scope trace= requires it is not emitted during the build by =cargo=.
This requires the application declaration to be parsed once more after first reading the source file, the path to which is acquired in [[cref:impl:cargo-rtic-scope:building-rtic-app]].

# We must the source for the ASTs
In order to generate a =rtic_syntax::ast::App= for recovery purposes =rtic_syntax::parse2= must be called with the arguments of =#[rtic::app(..)]= and the macro input.
For example, in [[cref:lst:recovery-example]], =device = stm32f4::stm32f401= is the macro arguments, and =mod app { ... }= is the macro input.
#+CAPTION: Example [[gls:RTIC]] application declaration that can be parsed by ~cargo-rtic-scope~.
#+NAME: lst:recovery-example
#+begin_src rust
  #![no_main]
  #![no_std]

  #[rtic::app(device = stm32f4::stm32f401)] // tokens are skipped until this line is found
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[task(binds = SysTick)]
      fn task1(_: task1::Context) {
          // ...
      }

      #[task(binds = EXTI1)]
      fn task2(_: task2::Context) {
          // ...
      }
  } // this must be the last line of the file
#+end_src

In order to isolate the =#[rtic::app(...)] mod app { ... }= section in [[cref:lst:recovery-example]] the =std::String= that represents the content of the source is first converted to an [[gls:AST]], specifically a =proc_macro2::TokenStream2= [[parencite:&proc-macro2]] via =syn= [[parencite:&syn]].
With a =TokenStream2= structure in hand [[glspl:token]] are skipped until the =proc_macro2::TokenTree::Group(_)= that contains =#[rtic::app(...)]= is found ([[cref:lst:recovery-example]], line 4).
The remainder of the source file is then assumed to be the macro input.

The parsing procedure places a few restrictions on otherwise valid declarations:
1. [[glspl:task]] *SHOULD NOT* be externally declared[fn:: Untested functionality.];
2. the =rtic::app= macro *MUST* be called via =#[rtic::app]= (i.e. [[cref:lst:invalid-recovery-example]] will fail to parse); and
3. the =mod app { ... }= token group terminator *MUST* be the last line of the source file ([[cref:lst:recovery-example]], line 27).
Undiscovered restrictions may apply.
#+NAME: lst:invalid-recovery-example
#+CAPTION: Valid [[gls:RTIC]] application declaration that cannot be parsed by ~cargo rtic-scope trace~.
#+begin_src rust
  // ...
  use rtic::app;

  #[app(device = stm32f4::stm32f401)] // will not parse: #[rtic::app] must be used
  mod app {
      // ...
  }
#+end_src

# known and unknown maps
At this point we have the necessary =rtic_syntax::ast::App= structure to continue:
=App::hardware_tasks= is a collection of \textttBreak{rtic_syntax::HardwareTask}s that lists which [[gls:interrupt]] handler each hardware task is bound to via the =binds= argument in =#[task(binds = ...)]= ([[cref:lst:recovery-example]]; lines 18, 23).
After parsing [[cref:lst:recovery-example]], =hardware_tasks= contains
#+begin_export latex
$$
\langle \text{\texttt{app::task1} binds to \texttt{SysTick}} \rangle,\quad\langle \text{\texttt{app::task2} binds to \texttt{EXTI1}} \rangle\text{.}
$$
#+end_export
Of these, the =app::task1= bind is considered /known/, and the =app::task2= bind is considered /unknown/.
A known bind is one that no more recovery work must be applied on.
This follows from [[cref:tbl:irqns]] in [[cref:theory:itm-proto]] which enumerates all numbers that can be in the exception trace packets' /ExceptionNumber/ field ([[cref:theory:itm:exceptions]]):
$N < 16$ label associations are common to all ARMv7-M targets and can be directly mapped to the RTIC task that binds it.
All $N \geq 16$ associations on the other hand are [[gls:MCU]]-specific and thus unknown without further consulting;
additional recovery must be done to find the /ExceptionNumber/ values associated to these labels.

# PAC::Interrupt and known/unknown partitioning; Rust reflection woes
For any RTIC application the labels of unknown binds are available in the =PAC::Interrupt= enum ([[cref:background:PAC]]).
For [[cref:lst:recovery-example]], =PAC= is =stm32::stm32f401=.
By consulting this =PAC= for the label its [[gls:IRQ]] number offset $N$ association is found;
consider [[cref:lst:pac:extirq]].
#+NAME: lst:pac:extirq
#+CAPTION: Finding $N$ in [[cref:tbl:irqns]] for an external [[gls:interrupt]] via the [[gls:PAC]].
#+begin_src rust
  let label = PAC::Interrupt::EXTI1;
  assert_eq!(label.number(), 7);
#+end_src
This must be done for all unknown binds.

The above process is unfortunately non-trivial: Rust does not support runtime type introspection and an ideal evaluation function such as [[cref:lst:pac:ideal-pseudo]] is not realizeable.
#+NAME: lst:pac:ideal-pseudo
#+CAPTION: Non-realizable Rust pseudocode to dynamically resolve the [[gls:IRQ]] number of an unknown bind via the [[gls:PAC]]. ~quote~ is from [[textcite:&quote]].
#+begin_src rust
  fn resolve_irq_nr(label: &str) -> u16 {
      use quote::quote;
      quote!(PAC::Interrupt::$label).eval().number();
  }
#+end_src

# libadhoc
Enter =recovery::resolve_int_nrs=: given a list of labels, the function
1. extracts an embedded file tree constituting a skeleton crate to the RTIC application crate's =/target/cargo-rtic-trace-libadhoc/= directory by help of [[textcite:&includedir]];
2. writes the user-specified PAC dependency into the skeleton crate's =Cargo.toml=[fn:: By use of the =pac_name=, =pac_version=, =pac_features=, and =interrupt_path= acquired from [[cref:impl:cargo-rtic-scope:read-manifest]].];
3. for each label: writes a non-[[gls:manglfn][mangled function]] with the same name as the label that returns the associated IRQ number offset, $N$, to =/src/lib.rs= (for [[cref:lst:recovery-example]], see [[cref:lst:resolve_int_nrs-example]]);
   #+NAME: lst:resolve_int_nrs-example
   #+CAPTION: Generated [[gls:IRQ]] number recovery functions for [[cref:lst:recovery-example]] with ~interrupt_path = "st32::stm32f401::Interrupt"~ from the [[gls:RTIC]] application's ~Cargo.toml~ metadata.
   #+begin_src rust
     use stm32::st32f401::Interrupt;

     #[no_mangle]
     pub extern fn EXTI1() -> u16 {
         Interrupt::EXTI0.number()
     }
   #+end_src
4. builds the crate as a [[gls:cdylib]];
5. loads the library into memory;
6. for each label: calls the associated function in the library to get the offset $N$; and
7. collects the results.
This collection then merges with the known maps.
For [[cref:lst:recovery-example]] the now-fully-recovered collection of known maps is then
#+begin_export latex
$$
\langle N = 15 \mapsto \texttt{app::task1} \rangle,\quad\langle N = 7 + 16 \mapsto \texttt{app::task2}  \rangle\text{.}
$$
#+end_export

***** Generating the ~recovery::SoftwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:software-map
:END:
The work to generate a =recovery::SoftwareMap= is similar to that of a =recovery::HardwareMap= in the sense that the [[gls:RTIC]] application declaration must be parsed again (for a third, but last time).
This pass is done via =SoftWareMap::parse_ast= instead of =rtic_syntax::parse2=.
As the function name implies the [[gls:AST]] is parsed by skipping [[glspl:token]] until the =TokenTree::Group(_)= describing =#[trace]= is found.
When this token is found the [[gls:software-task]] the macro is used on is associated with the current value of an internal counter for [[glspl:UTID]].
This counter is maintained in the same manner as the internal counter of the expanding =trace=: UTIDs start at zero and increment by one (c.f. [[cref:impl:rtic-trace:trace-macro]]).

To complete the =SoftwareMap= the identities $n$ of the [[gls:DWT]] comparators ([[cref:theory:dwt]]) and the [[glspl:interrupt]] of the [[glspl:task-dispatcher]] must be recorded.
The former are acquired from [[cref:impl:cargo-rtic-scope:read-manifest]] via the =dwt_enter_id= and =dwt_exit_id= fields.
The latter are acquired via =rtic_syntax::ast::AppArgs::extern_interrupts= from the =rtic_syntax::ast::App= acquired in [[cref:impl:hardware-map]].
If the task dispatcher is an unknown bind =recovery::resolve_int_nrs= in [[cref:impl:hardware-map]] is utilized.

For the example in [[cref:lst:rtic-scope:trace-software-task]], =SoftwareMap= would contain the information denoting =EXTI2= as the task dispatcher and
#+begin_export latex
$$
\langle u = 0 \mapsto \texttt{app::task1} \rangle,\quad\langle u = 1 \mapsto \texttt{app::task2} \rangle\text{,}\quad\text{$u$ an UTID.}
$$
#+end_export
#+NAME: lst:rtic-scope:trace-software-task
#+CAPTION: [[gls:RTIC]] application declaration with two traced [[glspl:software-task]]: ~app::task1~ and ~app::task2~. ~EXTI2~ is declared as the [[gls:task-dispatcher]].
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXTI2])]
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[trace] // UTID is 0
      #[task]
      fn task1(_: task1::Context) {
          // ...
      }

      #[trace] // UTID is 1
      #[task]
      fn task2(_: task2::Context) {
          // ...
      }
  }
#+end_src

The restrictions enumerated in [[cref:impl:hardware-map]] also apply when recovering information for traced software tasks.

The =trace= macro can also be applied on regular functions, effectively allowing the user to trace subsections of both software and hardware tasks;
see [[cref:impl:nested-tracing]] for an example.
Severe limitations apply when tracing functions inside tasks and are thus not useful in practise;
see [[cref:disc:nested-tracing-restrictions]] for more on this topic.
#+NAME: impl:nested-tracing
#+CAPTION: [[Gls:tracing]] a function inside a traced [[gls:software-task]].
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXIT2])]
  mod app {
      // ...

      #[trace]
      #[task]
      fn task1(_: task1::Context) {
          // ...

          #[trace]
          fn nested() {
              // ...
          }
      }
  }
#+end_src
**** Spawning frontends
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:spawning-frontends
:END:
The host-side of RTIC Scope is divided into two parts:
the =cargo-rtic-scope= [[gls:backend]] and the [[glspl:frontend]] of which =rtic-scope-frontend-dummy= ([[cref:impl:rtic-scope-frontend-dummy]]) is provided within the scope of this thesis, fulfilling [[req:dummy]] and acting as the frontend reference implementation.
Frontends are separate processes that receive =rtic-scope-api= structures in the form of [[gls:JSON]] messages from the backend over a local [[gls:socket]] connection.
This section covers how frontends are specified, found in the environment, and spawned.

The set of frontends to spawn is specified via the =--frontend= option before the =<verb>= in [[cref:lst:spawn-frontend]].
#+NAME: lst:spawn-frontend
#+CAPTION: Starting the RTIC Scope [[gls:backend]] with an explicit [[gls:frontend]].
#+begin_src shell
  $ cargo rtic-scope --frontend=rtic-scope-frontend-dummy <verb> [OPTIONS...]
#+end_src
Multiple frontends (or multiple instances of a single frontend) can be spawned by specifying the =--frontend= option multiple times.
By default (by not specifying the option) a single instance of =rtic-scope-frontend-dummy= is spawned.

=cargo-rtic-scope= searches for frontends in three locations in the environment.
With =--frontend=rtic-scope-frontend-dummy= the search pattern in decreasing order of priority is
1. in the =PATH= [[gls:envvar][environmental variable]];
2. the relative path: =./rtic-scope-frontend-dummy=; and
3. the absolute path: =/rtic-scope-frontend-dummy=.
If a higher priority location is valid, the search ends.
[[cref:lst:spawn-frontends]] contains an example of spawning three frontends in each of the supported location types.
#+NAME: lst:spawn-frontends
#+CAPTION: Starting the RTIC Scope [[gls:backend]] with three explicit [[glspl:frontend]]: one in ~PATH~, one relative, and one absolute.
#+begin_src shell
  $ cargo rtic-scope --frontend=frontend-in-PATH \
                     --frontend=./path/to/relative/frontend \
                     --frontend=/path/to/absolute/frontend \
                     <verb> [OPTIONS...]
#+end_src
When the frontend(s) have been found in the environment they are spawned as child processes to =cargo-rtic-scope= which handles their eventual termination.

In RTIC Scope v0.3 a frontend takes zero arguments and *MUST* print a path to a socket on [[gls:stdout]] which the backend can use to communicate with the frontend.
**** Sourcing the trace stream from the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reading-the-trace-stream
:END:
# Introduce the two main sources
At this point a line of communication with the target must be established.
Internally, this line of communication is known as a /source/ of which only one is established before =cargo-rtic-scope= traces the target.
In RTIC Scope v0.3 two sources are implemented:
- a serial source :: which configures and reads the trace data from a serial device; and
- a [[gls:probe]] source :: wherein =probe-rs= [[parencite:&probe-rs]] is used to read trace data from supported targets.

A serial source is used if =--serial= is specified to the =trace= verb.
When a serial source is used the [[gls:baud-rate]] of the [[gls:SWO]] must be known so that the serial device can be properly configured.
This is specified via the =tpiu_baud= field in the crate's manifest metadata ([[cref:impl:cargo-rtic-scope:read-manifest]]) but can also be overridden via the =--tpiu-baud= option.
See [[cref:lst:tty-source]] for an example of these options.
#+NAME: lst:tty-source
#+CAPTION: [[Gls:tracing]] a target by reading the [[gls:trace-stream]] from a serial device located at ~/dev/ttyUSB3~ at a [[gls:baud-rate]] of $115200$ bps.
#+begin_src shell
  $ cargo rtic-scope trace --serial /dev/ttyUSB3 --tpiu-baud 115200 [OPTIONS...]
#+end_src

A probe source is used if =--serial= is not specified.
=cargo-rtic-scope= will then use the first probe it can find on the system.
If multiple probes are attached =--probe VID:PID[:Serial]= can be used to specify one.
A list of connected and supported probes can be queried by specifying the =--list-probes= flag.

When the target is traced in [[cref:impl:cargo-rtic-scope:trace-target]] the trace stream is simply read from the serial device if one is used.
If a probe source is used =probe-rs= sends the appropriate commands to the used probe polling for available trace data.
**** Flashing the target (optional)
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flash-target
:END:
If the target is supported by =probe-rs= it can optionally be flashed before tracing begins, given that the memory layout is described.
This is the default behavior in order to simplify an iterative development process but can be disabled by specifying the =--dont-touch-target= flag to the =trace= verb.
The memory layout is described via the =--chip= option; see the example in [[cref:lst:chip-opt-example]].
The list of chips that =probe-rs= supports can be queried by specifying the =--list-chips= flag; [[cref:lst:chips-supported]].
#+NAME: lst:chip-opt-example
#+CAPTION: Flashing and [[gls:tracing]] an [[gls:MCU]] from the STMicroelectronics STM32F401 family.
#+begin_src shell
  $ cargo rtic-scope trace --chip stm32f401ret
#+end_src

#+NAME: lst:chips-supported
#+CAPTION: Listing all chips supported by ~probe-rs~ [[parencite:&probe-rs]].
#+begin_src shell
  $ cargo rtic-scope trace --list-chips
  Available chips:
  [...]
  STM32F4 Series
      Variants:
        STM32F401CBUx
        STM32F401CBYx
        STM32F401CCUx
        STM32F401CCYx
        STM32F401CDUx
        [...]
  [...]
#+end_src

**** Flushing trace metadata to file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flush-metadata
:END:
The next step is flushing all metadata related to the trace to the replay file created in [[cref:impl:cargo-rtic-scope:create-trace-file]].
The metadata is contained in a =recovery::TraceMetadata= structure, seen in [[cref:lst:TraceMetaData]].
Of these fields
- =maps: TraceLookupMaps= :: is described in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]];
- =reset_timestamp= :: is an approximate reset timestamp (optionally done so in [[cref:impl:cargo-rtic-scope:reset-target]]) that also describes the time host-side when tracing began; and
- =comment= :: is an optional field describing the trace which is supplied via the =--comment= option to the =trace= verb.
The data that is flushed to file is a [[gls:JSON]]-representation of the structure, serialized by help of =serde_json= as implied by the derivation of the =Serialize= and =Deserialize= traits [[parencite:&serde-json]].
#+NAME: lst:TraceMetaData
#+CAPTION: ~recovery::TraceMetadata~ structure containing all metadata related to a trace.
#+begin_src rust
  /// Contains all metadata for a single trace.
  #[derive(Clone, Serialize, Deserialize)]
  pub struct TraceMetadata {
      /// Name of the RTIC application that was/is traced.
      pub program_name: String,

      /// Lookup maps for data received over ITM to RTIC application idents.
      maps: TraceLookupMaps,

      /// Timestamp of target reset, after which tracing begins.
      ///
      /// Note: this timestamp is sampled host-side and is approximate.
      reset_timestamp: chrono::DateTime<Local>,

      /// Frequency of the target TPIU clock. Used to generate absolute
      /// timestamps. Set via `tpiu_freq` in
      /// `[{package,workspace}.metadata.rtic-scope]` from `Cargo.toml` or
      /// overridden via the `--tpiu-freq` trace option.
      tpiu_freq: u32,

      /// Optional comment of this particular trace.
      pub comment: Option<String>,
  }
#+end_src

This structure is utilized in [[cref:impl:cargo-rtic-scope:replay]] when a trace is replayed.
**** Resetting the target (optional)
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reset-target
:END:
The last step before [[gls:tracing]] the target is optionally resetting it.
This is the default behavior but can be disabled by specifying the =--dont-touch-target= flag to the =trace= verb.
Resetting the target causes it to begin executing the flashed application from the beginning.

From this point on the target will generate and emit [[gls:ITM]] packets on the [[gls:SWO]] pin according to the configuration applied in [[cref:impl:rtic-trace]].

**** [[Gls:tracing]] the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:trace-target
:END:
With all the preparatory steps concluded its up to =cargo-rtic-scope= to record the [[gls:trace-stream]] host-side.
This is done in a number of steps in the imaginatively named =run_loop= function:
1. A [[gls:sigint][SIGINT handler]] is installed which allows the user to terminate =cargo-rtic-scope=.
   If this signal is not eventually sent =cargo-rtic-scope= will run indefinitely
2. A second [[gls:thread]] is spawned with the mission of polling trace data from the source.
   In order to avoid the generation of overflow packets the thread polls data as fast as possible.
3. In a loop on the main thread:
   1. Asynchronously polls any buffered trace data from the spawned thread and the eventual SIGINT signal for a duration of $100$ ms.
      If trace data has been read it is handled by the aptly named =handle_packet= function (see below).
      If SIGINT is received the loop breaks and =cargo-rtic-trace= terminates.
      If after $100$ ms nothing happens:
   2. a message from the spawned [[glspl:frontend]] is read (if any) and echoed as an error;
   3. a message of the [[gls:tracing]] status is printed to [[gls:stdout]].
      This status message describes:
      - the application under trace;
      - how many [[gls:ITM]] packets that have been recorded;
      - how many of these packets that are malformed or unmappable ([[cref:impl:itm]]);
      - for how long the application has been traced;
      - how many ITM packets per second that are being recorded; and
      - how many /sinks/ that are operational (not marked as broken; see below).

=handle_packet= handles a single =itm::TimestampedTracePacket= (henceforth referred to as a /packet chunk/).
This is done several steps:
1. the packet chunk is converted to an =api::EventChunk= via =TraceMetadata::build_event_chunk= (see below);
2. any unmappable, unknown, or invalid ITM packets in the chunk are printed as warnings for the user; and
3. chunks are flushed to all /sinks/ (the replay file and all spawned frontends).
   If a flush fails for any sink, it is marked as broken and an error is printed for the user.
   As long as at least one sink is not marked as broken tracing continues.
   If all sinks are marked as broken =cargo-rtic-scope= prematurely terminates with an error.

=TraceMetadata::build_event_chunk= is responsible for recovering the [[gls:RTIC]] application metadata acquired in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]] for a packet chunk.
This is done by matching all =itm::TracePacket= structures in the chunk.
If a packet in the chunk is
- a synchronization packet (=TracePacket::Sync=), it is ignored because it does not contain any trace information;
- an exception trace packet (=TracePacket::ExceptionTrace=, [[cref:theory:itm:exceptions]]), the lookup maps previously generated are consulted for the [[gls:task]] matching the packet's [[gls:IRQ]] number.
  If the exception trace corresponds to a hardware task, an =api::EventType::Task= is constructed.
  If the trace corresponds to a software [[gls:task-dispatcher]] it is ignored because it contains redundant trace information.
  If none of these predicates are true the trace is logged as an unmappable event by the construction of an =api::EventType::Unmappable=.
- If the chunk packet is a data trace value (=TracePacket::DataTraceValue=, [[cref:theory:itm:data-trace]]), the lookup maps are again consulted:
  if the comparator ID, $n$, in the packet matches either =dwt_enter_id= or =dwt_exit_id= then the trace is a software task event.
  The packet's data value is matched against the set of RTIC application tasks that were decorated with =#[trace]=.
  If such a match exists an =api::EventType::Task= is constructed with the reported state (enter or exit), otherwise the trace is logged as an unmappable event.
If none of the above predicates were true, the chunk packet is logged as an unknown packet by wrapping it in an =api::EventType::Unknown=.
Last of all are the malformed packets: these are simply wrapped in an =api::EventType::Invalid=.

*** Decoding the [[gls:ITM]] packet stream via ~itm~
:PROPERTIES:
:CUSTOM_ID: impl:itm
:END:
The =itm= library crate, [[textcite:&itm]], is
#+ATTR_LATEX: :environment quotation
#+begin_quote
\noindent
A decoder for the [[gls:ITM]] and [[gls:DWT]] packet protocol[fn:: DWT packets ([[glspl:hardware-event-packet]]) are included in the ITM packet protocol standard.] as specified in [[textcite:&arm-rm Part D4]].

Aside from covering the entirety of the protocol, this crate offers two iterators which reads data from the given =std::io::Read= instance:
- =iter::Singles= :: which decodes each packet in the stream in sequence, yielding =itm::TracePacket= structures.
- =iter::Timestamps= :: which continuously decodes packets from the stream until a local timestamp is encountered yielding \linebreak[4] =itm::TimestampedTracePackets= structures which contains an absolute nanosecond-accurate timestamp associated to the target-side event.
#+end_quote

While the implementation of =itm= has been influenced by the development of RTIC Scope it is logically [[gls:upstream]] of RTIC Scope.
=itm= can thus be considered a wholly separate project, but its inception was a precursor to RTIC Scope in order to fulfill [[req:decode]], and it is thus within the scope of this thesis.

The crate is a green-field implementation of its deprecated v0.3 release branch, [[textcite:&itm-old]], of which this v0.8 (and above) release branch is only trivially influenced[fn:: Namely the implementation of the =std::io::Read= trait.].
Another =itm=-downstream crate is =itm-decode= [[parencite:&itm]] which aims to eventually replace the also deprecated =itm-tools= [[parencite:&itm-tools]], but that task is outside the scope if this thesis (see [[cref:fut:itm-tools]]).
Both =itm-decode= and =itm-tools= are convenient UNIX-like tools for decoding the ITM packet protocol.

=itm= is a packet decoder with state that handles its own data input.
After constructing a new decoder via =itm::Decoder::new= with an implementation of =std::io::Read= ---
e.g. a =std::fs::File= pointing to a preconfigured serial device, or a =probe_rs::architecture::arm::swo::SwoReader= ---
decoded packets are trivially acquired via the exposed iterators summarized above.
RTIC Scope utilizes the =iter::Timestamps= iterator, and is thus the only iterator covered in this text.

As covered in [[cref:theory:itm-proto]] the protocol follows a [[gls:TLV]] encoding scheme which is trivially decoded in Rust via pattern-matching:
the header byte is matched against packet types; subsequent payload bytes are then matched against the format of this type.
On success an =itm::TracePacket= is emitted.
On failure --- if a header or payload contains data that is not covered by [[textcite:&arm-rm Part D4]] --- an =itm::MalformedPacket= is emitted, describing why the decode failed.

=iter::Timestamps= intercepts all global and local timestamps ([[cref:theory:itm:timestamps]]) in order to maintain a monotonically increasing duration from when the reference clock start ticking.
Logically, this duration is initially zero before any timestamp packets have been decoded.
When a local timestamp is intercepted, its value is added to the current duration and its quality recorded.
When a global timestamp is intercepted, the duration is reset to this value, discarding information from previously received timestamps.

Any non-timestamp packets will be buffered until a local timestamp is intercepted, after which they will be associated to this latest timestamp in an emitted =TimestampedTracePackets=.
This structure also contains a field describing how many [[gls:ITM]] packets were consumed to generate it, information that is used in [[cref:impl:cargo-rtic-scope:trace-target]].

The maintained and emitted durations are structures with unit information; the timestamp packets themselves contain unit-less time information.
In order to calculate a duration two pieces of information must be known: the frequency of the reference; and the [[gls:prescaler]] of this clock.
In RTIC Scope, this information is acquired in [[cref:impl:cargo-rtic-scope:read-manifest]].
When a full timestamp has been received the offset to add to the current duration is calculated via =iter::calc_offset= seen in [[cref:lst:calc-offset]].

#+NAME: lst:calc-offset
#+CAPTION: Calculation of the offset to add to the current timestamp in ~itm~ [[parencite:&itm]].
#+begin_src rust
  fn calc_offset(ts: u64, prescaler: Option<LocalTimestampOptions>, freq: u32) -> Duration {
    let prescale = match prescaler {
        None | Some(LocalTimestampOptions::Enabled) => 1,
        Some(LocalTimestampOptions::EnabledDiv4) => 4,
        Some(LocalTimestampOptions::EnabledDiv16) => 16,
        Some(LocalTimestampOptions::EnabledDiv64) => 64,
        Some(LocalTimestampOptions::Disabled) => unreachable!(), // checked in `Timestamps::new`
    };
    let ticks = ts * prescale;
    let seconds = ticks as f64 / freq as f64;

    // NOTE(ceil) we round up so as to not report an event before it
    // occurs on hardware.
    Duration::from_nanos((seconds * 1e9).ceil() as u64)
}
#+end_src

The generation of local timestamps is critical in order to ensure a qualitative trace.
If trace packets are generated faster than they can be emitted from the target a queued packet is dropped in favor of an overflow packet.
One of these packets may be a local timestamp.
For a discussion on how to avoid overflows, see [[cref:disc:overflows]].

*** Handling the resolved trace stream in the frontend
:PROPERTIES:
:CUSTOM_ID: impl:rtic-scope-frontend-dummy
:END:
The purpose of the of =rtic-scope-frontend-dummy= [[gls:frontend]] is to act as a reference implementation upon which more useful frontends can be built.
There is no limit to what a frontend could do:
it could present a real-time graphical representation of the system alike a logic analyzer; it could store the resolved trace in a fully-fledged database; or it could simply print the messages to =stderr=, like the dummy.

The dummy frontend is trivial in implementation: [[cref:lst:dummy-src]] contains its entirety.
#+NAME: lst:dummy-src
#+CAPTION: The full source code of ~rtic-scope-frontend-dummy~.
#+begin_src rust
  #![allow(rustdoc::bare_urls)]
  //! Reference frontend implementation for RTIC Scope.
  #![doc = include_str!("../../docs/profile/README.md")]

  use anyhow::{Context, Result};
  use rtic_scope_api as api;
  use serde_json::Deserializer;

  fn main() -> Result<()> {
      // Create frontend socket in a temporary directory, print it for the parent backend.
      let socket_dir = tempfile::TempDir::new()
          .context("Failed to create temporary directory for frontend socket")?;
      let socket_path = socket_dir.path().join("rtic-scope-frontend.socket");
      let listener = std::os::unix::net::UnixListener::bind(&socket_path)
          .context("Failed to bind frontend socket")?;
      println!("{}", socket_path.display());

      // Deserialize api::EventChunks from socket and print events to
      // stderr along with nanoseconds timestamp.
      let (socket, _addr) = listener.accept().context("Failed to accept()")?;
      let stream = Deserializer::from_reader(socket).into_iter::<api::EventChunk>();
      let mut prev_nanos = 0;
      for chunk in stream {
          let api::EventChunk { timestamp, events } = chunk.context("Failed to deserialize chunk")?;
          let (quality, nanos) = match timestamp {
              api::Timestamp::Sync(offset) | api::Timestamp::AssocEventDelay(offset) => {
                  ("good", offset.as_nanos())
              }
              api::Timestamp::UnknownDelay { prev: _, curr }
              | api::Timestamp::UnknownAssocEventDelay { prev: _, curr } => ("bad!", curr.as_nanos()),
          };
          let diff = nanos - prev_nanos;
          eprintln!("@{nanos} ns (+{diff} ns) [{quality}]: {events:?}");
          prev_nanos = nanos;
      }

      Ok(())
  }
#+end_src

*** Replaying a trace
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:replay
:END:
Replaying a trace is done via the =replay= verb.
The implementation behind replaying a trace is the same as recording one, only that the source is a replay file instead of a serial device or a [[gls:probe]], and no recovery must be done.
A replay file can be specified in two ways: by use of an index of which the =--list= flag lists the indices; or by specifying the path to the trace file.
[[cref:lst:replay-examples]] exemplifies these two methods.
When using an index to replay a file the default directory within which to search for replay files (=/target/rtic-traces/=) can be overridden via =--trace-dir=.

When replaying a file, =cargo-rtic-scope= will terminate when the replay file ends or if the [[gls:sigint][SIGINT handler]] executes.

#+NAME: lst:replay-examples
#+CAPTION: Example commands of listing and replaying recorded traces.
#+begin_src shell
  # listing available replay files
  $ cargo rtic-scope replay --list
  index   trace file
  0       target/rtic-traces/atsamd-demo-g472bc3d-dirty-2022-01-19T17:05:21.trace
  # replaying the trace with index 0
  $ cargo rtic-scope replay 0
  # specifying the path to the replay file
  $ cargo rtic-scope replay --trace-file target/rtic-traces/atsamd-demo-g472bc3d-dirty-2022-01-19T17:05:21.trace
#+end_src

** Results
:PROPERTIES:
:CUSTOM_ID: results
:END:
From [[cref:impl]] it follows that all requirements enumerated in [[cref:requirements]] are fulfilled.
This thesis has yielded a collection of five crates: four of which constitute the RTIC Scope project and the last crate a generally applicable [[gls:trace-stream]] decoding library.
This section covers the application of RTIC Scope to a trivial [[gls:RTIC]] application executing on a Microchip ATSAME51N20A [[gls:MCU]].

We consider the RTIC Scope application example from [[textcite:&rtic-scope:atsame-example]]:
After configuring the device-specific clocks to source [[gls:ITM]] and [[gls:TPIU]], the application configures [[gls:tracing]] via =cortex_m_rtic_trace::configure= and pends a [[gls:hardware-task]], =app::hardware=.
When this task executes it spawns a [[gls:software-task]], =app::software=, with higher priority and is thus preempted.
=app::software= exits after 100 ms and =app::hardware= resumes execution after which it also exits.
The source of this application can be seen in its entirety in [[cref:lst:app-atsame-example-src-main]] in [[cref:app:application-example]].
Note
- the breakpoint at line 49 which is used to escape the transient of the [[gls:SWO]] pin covered in [[cref:disc:swo-transient]];
- the configuration of the MCU-specific trace clock on lines 32--40; and
- the use of the =cortex_m_rtic_trace::trace= macro on the software task.

As mentioned in [[cref:impl:cargo-rtic-scope:read-manifest]] trace and MCU metadata must be provided in the crate's =Cargo.toml=.
This provided metadata can be seen in [[cref:lst:app-atsame-example-manifest]].

To apply RTIC Scope to an existing [[gls:RTIC]] application, the following overhead is thus required:
- configuration of the trace clock which is MCU-specific;
- configuration of tracing via =cortex_m_rtic_trace::configure= and allocation two [[gls:DWT]] comparators for software task tracing;
- application of the =cortex_m_rtic_trace::trace= macro on the software tasks of interest;
- addition of trace and MCU metadata to the crate's =Cargo.toml=; and
- a method to escape the [[gls:SWO]] pin transient.

With this overhead performed, we trace [[textcite:&rtic-scope:atsame-example]] via [[cref:lst:app-atsame-example-trace-scope]].
The recorded traces are then listed via [[cref:lst:app-atsame-example-trace-scope-replay-list]] and replayed via [[cref:lst:app-atsame-example-trace-scope-replay]].

# TODO check if the ATSAME actually spends 100ms in app::software by toggling a pin.

** Discussion
:PROPERTIES:
:CUSTOM_ID: discussion
:END:
*** What project does ~itm~ belong to?
:PROPERTIES:
:CUSTOM_ID: disc:itm-embedded-wg
:END:
As mentioned in [[cref:impl:itm]], =itm= is a re-implementation and feature superset of a deprecated library with the same [[gls:trace-stream]] decoding goal, namely [[textcite:&itm-old]].
During the re-implementation the changes where pushed upstream to the original repository but a consensus regarding the created merge request was not reached.
Subsequently, a [[gls:RFC]] was created [[parencite:&rfc:rust-embedded:move-itm-crate]] initially proposing that the =itm= crate was to be moved out of the then-maintaining Cortex-M team of the Embedded Rust [[gls:WG]] to a repository under my control to continue the development.
When the discussion concluded it was instead decided to simply add a deprecation notice to the =itm= repository pointing towards the new implementation at [[textcite:&itm]].

The reason for the deprecation was that the WG would have to maintain a wholly new code-base that had yet to stabilize.
Changes to both implementation and the [[gls:API]] of the library would then have to be vetted by WG members before merge which would induce development friction.
The RFC then concluded that a new discussion should be held regarding adoption of the new implementation when it reaches API stability.

Another root question that led to the indecision of the merge was whether a host-side crate should ultimately be maintained by a WG focused on the embedded aspect.

As of writing the discussion on the adoption of the reimplementation has yet to begin.
A comment will be appended to [[textcite:&rfc:rust-embedded:move-itm-crate]] pointing to the new discussion when it begins.
*** [[Gls:tracing]] [[gls:overhead]] with RTIC Scope
:PROPERTIES:
:CUSTOM_ID: disc:perf
:END:
[[textcite:&arm-cortex-learn 24]] states:
#+begin_quote
Except for the power that is consumed by the system trace components,
trace is almost entirely non-invasive. This means that performing trace
generation and collection does not influence the wider system.
#+end_quote

The target-side code of RTIC Scope has a hypothesized negligible performance impact during execution:
- the [[gls:ITM]], [[gls:DWT]], and [[gls:TPIU]] peripherals need only be configured once in [[gls:RTIC]]'s =#[init]= or during some other preparatory stage; and
- when [[glspl:software-task]] are traced, an =u8= memory write must be done when entering and exiting the task.

Some hardware resources are also required: two DWT comparators for the [[gls:tracing]] functionality and 64 bits of flash storage for [[glspl:watch-variable]] (see [[cref:lst:watch-variable-impl]]).
These resources are only strictly required if software tasks are traced, but are unconditionally required due to the current [[gls:API]] of =cortex-m-rtic-trace=, implemented as such for simplicity.

#+NAME: lst:watch-variable-impl
#+CAPTION: Implementation of [[gls:watch-variable]] storage in ~cortex-m-rtic-trace~ [[parencite:&rtic-scope:rtic-trace \texttt{src/lib.rs}]]. Two ~u8~, aligned to 32 bits, are used to track the state of [[glspl:software-task]]. The variables are aligned to 32 bits for implementation simplicity.
#+begin_src rust
  // ...

  /// Container of a variable in memory that is watched by a DWT
  /// comparator to enable software task tracing. Word-aligned to help
  /// with address comparison.
  ///
  /// XXX Is word-alignment necessary? Can't we use a mask instead?
  #[repr(align(4))]
  struct WatchVariable {
      /// ID of the software task that was entered or exited.
      pub id: u8,
  }

  /// Watch variable to which the just entered software task ID is written to. Aligned to 32-bit.
  static mut WATCH_VARIABLE_ENTER: WatchVariable = WatchVariable { id: 0 };
  /// Watch variable to which the just exited software task ID is written to. Aligned to 32-bit.
  static mut WATCH_VARIABLE_EXIT: WatchVariable = WatchVariable { id: 0 };

  // ...

  /// Function utilized by [`#[trace]`](trace) to write the unique ID of
  /// the just entered software task to its associated watch address. Only
  /// use this function via [`#[trace]`](trace).
  #[inline]
  pub fn __write_enter_id(id: u8) {
      unsafe {
          core::ptr::write_volatile(&mut WATCH_VARIABLE_ENTER.id, id);
      }
  }

  /// Function utilized by [`#[trace]`](trace) to write the unique ID of
  /// the software task about to exit to its associated watch address.
  /// Only use this function via [`#[trace]`](trace).
  #[inline]
  pub fn __write_exit_id(id: u8) {
      unsafe {
          core::ptr::write_volatile(&mut WATCH_VARIABLE_EXIT.id, id);
      }
  }
#+end_src

Theoretically, a single DWT comparator could be utilized to handle both software task enters and exit by reserving a bit in the written =u8= to denote the new state.
Further, because only 8 of the 32 bits (in conjunction with a change to only use a single comparator) are effectively used, only 8 bit should need to be allocated for the singular watch variable.
This overzealous resource allocation was done for implementation simplicity.
A future release of RTIC Scope can offer a lower resource requirement.

The performance of the host-side =cargo-rtic-scope= and =rtic-scope-frontend-dummy= programs have not been measured.
*** Restrictions of tracing functions inside tasks
:PROPERTIES:
:CUSTOM_ID: disc:nested-tracing-restrictions
:END:
While implementing [[gls:software-task]] [[gls:tracing]] by help of the =trace= macro, support was also added to apply the macro to nested functions.
However, due to how the macro expands a nested function would expand to [[cref:lst:trace-expanded-nested]] (c.f. [[cref:lst:rtic-trace:trace-expanded]]):
the exit state change of the nested function would never be reported due to the return statement just before.

#+NAME: lst:trace-expanded-nested
#+CAPTION: Expanded [[gls:RTIC]] [[gls:task]] declaration with a traced nested function.
#+begin_src rust
  // ...

  #[allow(non_snake_case)]
  fn task(_: task::Context) {
      ::cortex_m_rtic_trace::__write_enter_id(0);
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
      fn nested() {
          ::cortex_m_rtic_trace::__write_enter_id(1);
          // some work
          return // or equivalent
          ::cortex_m_rtic_trace::__write_exit_id(1);
      }
      ::cortex_m_rtic_trace::__write_exit_id(0);
  }

  // ...
#+end_src

This limitation can be side-stepped by implementing =task::nested= such that it only applies side effects to the function's parameters.
Such an approach can be compared to how functions in C are commonly implemented where the returned value is a pointer or an integer signalling if the operation was successful.
However, due to the strict requirement that the function must not return any value in its last statement, any return data or signals must first be intermediately allocated and passed as a mutable reference to the traced function, yielding an ad-hoc [[gls:API]] that not only breaks Rust's implementation guidelines, but is different from a C [[gls:API]].

An alternative implementation of =trace= could instead be used to wrap the call to =task::nested=, allowing the implementation of a pure function[fn:: A function without side effects.], but because =trace= is an attribute macro it cannot be applied to statements in functions [[parencite:&docs:rust-proc-macros]].
If trace was available as a function-like macro, one could in theory wrap and trace any block expression via a theoretical =trace!(|| { nested() + nested() })=, but that would require non-trivial changes to the recovery step of =cargo-rtic-scope= in order to assign a [[gls:UTID]] to each macro invocation.
Furthermore, it would also require the allocation of a key-word to differentiate trace macros from non-trace macros, inducing [[gls:overhead]].

The support for nested function tracing is staged to be removed in a future release of RTIC Scope.
It is thus recommended to only use the =trace= macro on [[gls:RTIC]] task declarations.
*** A fundamental flaw of asynchronous serial trace emission
:PROPERTIES:
:CUSTOM_ID: disc:swo-transient
:END:
During the development of RTIC Scope considerate focus was put on trace emission using asynchronous serial communication.
This approach saw focus due to the minimal hardware design required to enable [[gls:tracing]] of a product based on an ARMv7-M [[gls:MCU]]:
the base requirement is to expose the single [[gls:SWO]] pin, after which the remaining work is done by device-external hardware (in order to convert the electrical signal to a byte stream) and software.
A single MCU pin commonly multiplex features, however.
In theory features be selected via hardware or software:
via a hardware configuration (pulling another pin high or low[fn:: Shorting the pin to a (e.g.) $3.3$ V source, or common ground, respectively.]) the pin in question will expose the wanted feature when the MCU is powered;
via software the pin will expose its default feature on power and software must configure the pin during initialization.
Commonly, most pins can only be configured via software and upon a MCU reset, the pin returns to its default feature.
Unfortunately, software configuration is prone to induce transient noise on the pin until it is fully configured.
If this noise is not accounted for and host-side trace recording starts as the MCU resets (e.g. via [[cref:impl:cargo-rtic-scope:reset-target]]), the recorded noise will put the trace decoder in an unknown state and likely emit malformed packets.
Ultimately, task state changes are likely to be lost and the error induced to the decoder may not necessarily die out.
This behavior is intrinsically MCU-specific: there is unlikely a common model of this noise that can be used to filter the bytes host-side in software.

The ATSAME51N20A is one example of an MCU that displays this noise, seen in [[cref:fig:swo-transient]], as a consequence of the configuration done to pin PC27 in [[cref:lst:atsame51n20a-swo-conf]].

#+NAME: lst:swo-transient-plot
#+begin_src python :results file :exports results
  import pandas as pd
  import matplotlib as mpl
  import matplotlib.pyplot as plt

  rc_fonts = {
      "font.family": "serif",
      "font.size": 12,
      "text.usetex": True,
      'text.latex.preview': True,
      'text.latex.preamble': [
          r"""
          \usepackage{kpfonts}[maths]
          \usepackage{libertine}
          \usepackage{inconsolata}
          """],
  }
  mpl.rcParams.update(rc_fonts)

  df_trans = pd.read_csv('data/swo-transient.txt', sep=' ', skiprows=4, index_col=0)
  df_ground = pd.read_csv('data/swo-transient-grounded.txt', sep=' ', skiprows=4, index_col=0)
  plt.plot(df_ground, label='Signal (probe grounded)')
  plt.plot(df_trans, label='Signal')
  plt.legend()
  plt.ylabel('Signal voltage [V]')
  plt.xlabel('Time [s]')

  plt.savefig('fig.svg')
  return 'fig.svg'
#+end_src

#+NAME: fig:swo-transient
#+CAPTION: Transient seen on the [[Gls:SWO]] pin after the configuration in [[cref:lst:atsame51n20a-swo-conf]] has been applied. Compared with grounded equivalent. When logically interpreted, the signal can yield a malformed [[gls:trace-packet]] where there is none.
#+RESULTS: lst:swo-transient-plot
[[file:fig.svg]]

#+NAME: lst:atsame51n20a-swo-conf
#+CAPTION: Configuration of the PC27 pin for the ATSAME51N20A [[gls:MCU]] to act as the [[gls:SWO]] pin. This configuration induces transient noise on the pin, seen in [[cref:fig:swo-transient]]. Remainder of the [[gls:RTIC]] application omitted for brevity.
#+begin_src rust
  #[init]
  fn init(mut ctx: init::Context) -> (SharedResources, LocalResources, init::Monotonics()) {
      use atsamd_hal as hal;
      use hal::thumbv7em::clock::GenericClockController;
      use hal::gpio::v2::pin::{Alternate, M};

      // configure trace clock
      let mut gcc = GenericClockController::with_internal_32kosc(
          ctx.device.GCLK,
          &mut ctx.device.MCLK,
          &mut ctx.device.OSC32KCTRL,
          &mut ctx.device.OSCCTRL,
          &mut ctx.device.NVMCTRL,
      );
      let gclk0 = gcc.gclk0();
      let _trace_clk = gcc.cm4_trace(&gclk0).unwrap();

      // configure SWO pin; this induces transient noise on the pin.
      let pins = hal::gpio::v2::Pins::new(ctx.device.PORT);
      let _pc27 = pins.pc27.into_mode::<Alternate<M>>();
  }
#+end_src

A few methods of "escaping" this transient that require further investigation are proposed in [[cref:fut:espace-swo-transient]].

*** Avoiding overflows
:PROPERTIES:
:CUSTOM_ID: disc:overflows
:END:
The theory behind overflow avoidance is simple: the [[gls:ITM]] and [[gls:DWT]] may not generate more trace packets than what the [[gls:TPIU]] can serialize.

If overflows are encountered the below description of approaches can be consulted, in order of recommendations.
- Increase TPIU [[gls:baud-rate]] :: The [[gls:SWO]] baud rate is controlled via the /SWOSCALER/ bit-range in [[gls:TPIU_ACPR]] as described in [[cref:impl:rtic-trace:peripheral-config]].
  /SWOSCALER/ can be calculated via [[cref:eq:prescaler]] and may have any value that fits in the field.
  Increasing the baud rate by lowering /SWOSCALER/ gives the TPIU more time to serialize a packet onto the SWO pin, thus increasing the margin until the internal [[gls:FIFO]] queue fills up prompting an overflow on the next packet.

  While the TPIU can communicate with an arbitrary baud rate, the host-side system may not be able to communicate with the same arbitrarity.
  Linux, for example, can only communicate with a set of predefined baud rates as described in =termios.h= [[parencite:&linux:termios]].
  With a sufficiently low error rate, $\left\lvert1 - \frac{\text{Linux baud rate}}{\text{TPIU baud rate}}\right\rvert$, it may be possible to establish a stable communication with non-matched baud rates.

  The baud rate can be selected via =cortex_m_rtic_trace::configure= by appropriately configuring the passed =TraceConfiguration::tpiu_baud= structure field.

- Asynchronously clock the TPIU :: The TPIU can be clocked with the system clock or via an asynchronous clock, configured via the \linebreak[4] =TraceConfiguration::timestamp_clk_src= enum passed to =cortex_m_rtic_trace::configure=.
  If overflows are encountered when using the system clock, it is recommended to use a faster asynchronous clock instead.
  The capabilities of this clock, how it is configured, and whether an asynchronous clock source is supported at all is [[gls:MCU]]-specific.
  In combination with the previous recommendation, this gives a lot more leeway when configuring the baud rate;
  with a dedicated trace clock the baud rate can much more easily match the baud rates the host system can communicate with, without affecting the [[gls:MCU]]'s system clock.

  As the configuration field name implies, this clock is also used to increment the timestamp values --- specifically local timestamps.
  Note also [[textcite:&arm-rm Section C1.7.6]], under /SWOENA/, which the configuration field is equivalent to: "[When an asynchronous clock is used] the timestamp counter is held in reset while the output line is idle."
  This implies that when the system clock is used the timestamp counter will continue to run even if there are no trace packets to serialize.[fn:: Anecdotally, when experimenting with the Atmel ATSAME51N20A, a local timestamp would be emitted before it wrapped when using the system clock.]
  This behavior must be taken into account when changing the clock source.
  It is in any case recommended to always use an asynchronous clock source if available in case the system clock frequency must be changed.

- Lower the system clock :: The frequency at which trace packets are generated is entirely bound to how often tasks are entered and exited, and the frequency of the system clock.
  If the above recommendations have been applied and overflows are still encountered, a last resort before the traced application must be refactored is to lower the system clock frequency.
  This frequency should as per the last recommendation be lower than that of the asynchronous clock frequency which the TPIU sources.

- Generate fewer events :: If all the above recommendations fail to remedy overflows, the remaining option is to refactor the [[gls:RTIC]] application to generate fewer events: that is, decrease the frequency at which tasks are entered and exited.
  The lowest hanging fruit of this approach is to simply disable the tracing of software tasks by omitting all instances of the =trace= macro.
*** Future work
:PROPERTIES:
:CUSTOM_ID: fut
:END:
This section comments on some choice topics of future work planned for RTIC Scope, most sections being referred to previously in this text and being filed as issues in the relevant repository.
This section is not exhaustive:
as of writing 31 issues are open for RTIC Scope[fn:: Refer to [[https://github.com/rtic-scope/cargo-rtic-scope/issues][https://github.com/rtic-scope/cargo-rtic-scope/issues]].];
7 for =itm=[fn:: Refer to [[https://github.com/rtic-scope/itm/issues][https://github.com/rtic-scope/itm/issues]].];
and 10 for =cortex-m=[fn:: Refer to [[https://github.com/rust-embedded/cortex-m/issues?q=is%3Aopen+author%3Atmplt][https://github.com/rust-embedded/cortex-m/issues?q=is%3Aopen+author%3Atmplt]].] (which relate to RTIC Scope functionality).

**** [[gls:TPIU]] [[gls:baud-rate]] configuration
:PROPERTIES:
:CUSTOM_ID: fut:swoscaler
:END:
The [[gls:baud-rate]] of the [[gls:TPIU]] is configured via [[cref:lst:tpiu-baud-rate]] which implements [[cref:eq:prescaler]].
This implementation is error-prone due to integer division and because it does not verify the written [[gls:prescaler]] value by reading it back.
The implementation will also attempt a divide-by-zero if a baud rate of 0 is requested; in the best case, this leads to a panic.
This behavior is not documented.

#+NAME: lst:tpiu-baud-rate
#+CAPTION: [[gls:TPIU]] [[gls:baud-rate]] configuration using the reference clock frequency and requested baud rate, from the ~cortex-m~ crate, that implements [[cref:eq:prescaler]]. ~self~ is a structure representation of the [[gls:TPIU]] configuration registers. This implementation is subject to integer division, divide-by-zero, and does not verify the written [[gls:prescaler]] value; it is thus error-prone.
#+begin_src rust
  impl TPIU {
      /// Sets the prescaler value for a wanted baud rate of the Serial
      /// Wire Output (SWO) in relation to a given asynchronous refernce
      /// clock rate.
      #[inline]
      pub fn set_swo_baud_rate(&mut self, ref_clk_rate: u32, baud_rate: u32) {
          unsafe {
              self.acpr.write((ref_clk_rate / baud_rate) - 1);
          }
      }

      // ...
  }
#+end_src

For example, if the function is called via =tpiu.set_swo_baud_rate(16_000_000, 115_200)= one would expect the prescaler value $137.88$ to be written, but because this prescaler must be an integer $137$ is written instead, configuring the TPIU to use a baud rate of approximately $115942$ bps instead as per [[textcite:&arm-rm Section C1.10.4]]; an error of 6.44%, via [[cref:eq:baud-rate-error]].
A sufficiently large error will induce communication problems.
#+NAME: eq:baud-rate-error
\begin{equation}
  \left\lvert 1 - \left(\frac{115942}{115200}\right)\right\rvert = 0.00644
\end{equation}

An issue that further documents the erroneous implementation and offers improvements is available at [[textcite:&issue:cortex-m:388]].

Ideally, errors such as [[cref:eq:baud-rate-error]] should be caught statically during compilation, but such a feature would require non-trivial changes to the embedded Rust ecosystem because =cortex-m= currently has no idea about the clock configuration of the target device.[fn:: This would require changes to all [[glspl:HAL]] to statically hold information about the device-specific clock hierarchy that can then be passed to and inspected by =cortex-m=.]

**** Trace stream ID configuration
:PROPERTIES:
:CUSTOM_ID: fut:TraceBusID
:END:
[[textcite:&arm-rm p. C1-718]] documents:
#+begin_quote
If a system supports multiple trace streams, the debugger must write a nonzero value to the [[gls:ITM_TCR]].TraceBusID field.
\textelp{} An example of a system with multiple trace streams is an ARMv7-M core with [[gls:ETM]] trace stream.
#+end_quote
However, no documentation covers the use-case when ETM should be disabled and only the [[gls:ITM]] trace stream is of interest.
From brief communication with the ARM errata team, it seems that writing zero to this field is valid if the device does not support [[gls:ETM]], but anecdotally it also seems valid when ETM packets are dropped ([[cref:impl:rtic-trace:peripheral-config]]) on a device that does offer an ETM, particularly the Microchip ATSAME51N20A.
This relationship (validity of a zero trace bus ID when ETM packets are dropped) has not yet been confirmed with ARM.

An issue covering the potential invalidity of a zero trace bus ID is available at [[textcite:&issue:cortex-m:392]].

**** Deprecating ~cortex-m-rtic-trace~
:PROPERTIES:
:CUSTOM_ID: fut:rm-rtic-trace
:END:
=cortex-m-rtic-trace= is an auxiliary library that provides =configure= which configures all relevant peripherals for [[gls:tracing]];
and =trace=, a macro with which [[glspl:software-task]] can be traced after =configure= has been called successfully.
Refer to [[cref:impl:rtic-trace]].

A goal of RTIC Scope is to minimize the user [[gls:overhead]].
The version of RTIC Scope presented in this text requires the user to modify their [[gls:RTIC]] application's =init= function by calling =configure=.
Ideally, the user should be able to enable tracing via flags to RTIC, either for the whole application or tasks of interest.
See [[cref:lst:ideal-trace-enable]] for an example.
Then the =trace= flag is set, RTIC could then inject the code to =configure= into the application.

#+NAME: lst:ideal-trace-enable
#+CAPTION: Ideal methods to enable [[gls:tracing]] of [[gls:RTIC]] applications via flag specification.
#+begin_src rust
  #[rtic::app(trace = true, ...)] // enables tracing of all tasks
  mod app {
      // ...

      #[task(trace = true, ...)] // enables tracing of just this task
      fn task(_: task::Context) {
          // ...
      }
  }
#+end_src

Of note is that only a portion of =configure= is specific to RTIC Scope; other [[glspl:RTOS]] could benefit from its implementation.
It may be apt to [[gls:upstream]] portions of its implementations to [[textcite:&cortex-m]] which =cortex-m-rtic-trace= extends.

Regardless of what the outcome of minimizing overhead is, =cortex-m-rtic-trace= is predicted to eventually be deprecated;
refer to [[textcite:&issue:cargo-rtic-scope:90]].
See also [[textcite:&issue:cargo-rtic-scope:100]], a tracking issue on the realization of zero overhead (i.e., no longer requiring the user to modify the crate's =Cargo.toml=).

**** Supporting other [[glspl:RTOS]] than [[gls:RTIC]]
RTIC Scope v0.3 targets and depends on [[gls:RTIC]] v1.0.0.
This dependency is only required for the recovery step in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]].
RTIC Scope could as well implement support for the user to provide these maps by describing them in an external file passed via a theoretical =cargo rtic-scope trace --maps-file /path/to/extenal-maps-description [...]= invocation.
Such an approach would enable RTIC Scope to be applied on an application that is not written in RTIC.
Additionally, RTIC Scope could then also be applied on an application that is not necessarily written in Rust if =--dont-touch-target= and =--trace-dir= are passed to the =trace=[fn:: =--trace-dir= would be required such that =cargo-rtic-scope= would not search through a crate that does not exist. =--dont-touch-target= is would be required because =cargo-rtic-scope= only knows how to build and flash a Rust application.] verb and provided that =cortex-m-rtic-trace= is substituted.
This would make the toolset more general and drive development from more than a single front.

**** Publishing all crates to the crate registry
In order to publish a crate all of its dependencies must first be published.
When a crate has been published, it can be used as a dependency by specifying the crate name and version alone in =Cargo.toml=, as seen in [[cref:lst:cargo-lib-dep]].
A published crate can also be installed via =cargo= by simply specifying the name of the crate.
This makes it trivial for users to install a Rust program as long as any non-Rust dependencies are installed.
Ideally, a user should be able to install RTIC Scope via [[cref:lst:cargo-install-bins]], but currently the easiest way to install RTIC Scope is via [[cref:lst:cargo-install-git]], simply because RTIC Scope v0.3 has yet to be published.

#+NAME: lst:cargo-lib-dep
#+CAPTION: Declaring ~cortex-m-rtic-trace~, which is here presumed to be published on the crate repository, as a dependency in a ~Cargo.toml~
#+begin_src toml
  # ...

  [dependencies]
  cortex-m-rtic-trace = "0.3"

  # ...
#+end_src

#+NAME: lst:cargo-install-bins
#+CAPTION: Installing RTIC Scope via ~cargo install~, presuming v0.3 has been published on the crate registry.
#+begin_src shell
  $ cargo install cargo-rtic-scope rtic-scope-frontend-dummy --version 0.3
#+end_src

#+NAME: lst:cargo-install-git
#+CAPTION: Installing RTIC Scope via ~cargo install~ from the git repository.
#+begin_src shell
  $ cargo install --git https://github.com/rtic-scope/cargo-rtic-scope cargo-rtic-scope rtic-scope-frontend-dummy --branch v0.3.x
#+end_src

RTIC Scope has yet to be published because of contributions made [[gls:upstream]].
Either these contributions have been merged (but not released) or are awaiting feedback from their respective maintainers.
A tracking issue has been created that documents the effort to publish RTIC Scope; see [[textcite:&issue:cargo-rtic-scope:101]].

**** Replacing ~itm-tools~
:PROPERTIES:
:CUSTOM_ID: fut:itm-tools
:END:
=itm-tools= [[parencite:&itm-tools]] is a toolset for analyzing [[gls:ITM]] trace streams.
As of writing, these tools decode the ITM packet standard and offer interpretation of exception traces ([[cref:theory:itm:exceptions]]), [[gls:PC]] samples (via =pcsampl=), and instrumentation packet port demuxing (via =port-demux=).
Of certain interest is that =pcsampl= can answer the question of "where is my program spending most if its time?"
An example invocation of =pcsampl= would yield [[cref:lst:pcsampl]], describing that the program spent almost 92% of its time sleeping during the time the target was traced.

#+NAME: lst:pcsampl
#+CAPTION: Example invocation of ~pcsampl~ from [[textcite:&itm-tools]].
#+begin_src shell
  $ pcsampl -e target/thumbv7m-none-eabi/release/app itm.bin 2>/dev/null
      % FUNCTION
  91.69 *SLEEP*
   3.70 app::foo_o7xa::h9e4953f3ea6a58d8
   2.87 app::bar_t7fm::hf544b1b6f026d266
   0.95 SysTick
   0.52 EXTI1
   0.26 EXTI0
   0.01 main
  -----
   100% 11692 samples
#+end_src

In comparison to =itm= provided as a result of this thesis, =itm-tools= does not:
configure an optional serial device for direct reading, offer the option to maintain a monotonically increasing timestamp, optionally associates trace packets with such a timestamp, or trivially describes the timestamp quality.
=itm= does on the other hand not offer equivalents to =pcsampl= and =port-demux=.

It would be beneficial to incorporate these features into =itm= in order to collect ITM decoding and interpretation efforts in a singular crate.
For =port-demux= and =pcsampl= equivalence, refer to [[textcite:&issue:itm:5]] and [[textcite:&issue:itm:14]], respectively.

**** Escaping the [[gls:SWO]] transient noise
:PROPERTIES:
:CUSTOM_ID: fut:espace-swo-transient
:END:
Below is a list of possible methods of escaping the transient noise of the [[gls:SWO]] pin described in [[cref:disc:swo-transient]].

- Using the parallel trace port :: [[textcite:&arm-rm Section C1.10]] describes the optional feature of a parallel trace port.
  This is a synchronous trace emission method that uses one pin for the clock and at least one pin for data communication.
  An optional control pin may also be supported by the [[gls:MCU]], but its purpose has not been investigated.

  This approach may remove the noise entirely, but may depend on the order in which the pins are configured.
  It will also require more complex hardware between the target and host in order to adapt the parallel interface to a serial device which =cargo-rtic-scope= can read.
  [[textcite:&orbuculum]] has done some work on this front, and offer hardware designs to demux multiple data pins.

- Using sentinel synchronization packets :: [[textcite:&arm-rm Section D4.2.1]] defines a synchronization packet that "trace capture hardware can [use to] identify the alignment of packet bytes in the bitstream".
  If such a packet is emitted after pin configuration, the decoder may be able to implement support to drop read trace data until this packet is encountered.
  Due to the constitution of this packet (at least 47 zeros followed by a single 1 bit), the possibility of the transient noise generating such a packet may be sufficiently low to ensure a stable trace stream.
  However, this possibility is difficult to find because the induces noise depends on the internal characteristics of the MCU.
  Refer to [[textcite:&issue:itm:11]] for the progress and applicability of this approach.

- Storing trace data on-chip :: [[textcite:&arm-rm Section C1.10]] refers to a [[gls:TPIU]]-alternative dubbed the [[gls:ETB]], described in [[textcite:&coresight]], that stores the trace data in on-chip memory.
  An attached debugger could theoretically read this data, sidestepping the TPIU (and thus any pin transients) completely.
  =cargo-rtic-scope= relies on =probe-rs=, which can be used to read the on-chip memory, but it currently lacks support for the ETB.
  Refer to [[textcite:&issue:cargo-rtic-scope:128]] for the progress of this approach.

**** Review local and global timestamp clock relationship
:PROPERTIES:
:CUSTOM_ID: fut:review-timestamp-relation
:END:
As of writing RTIC Scope assumes that local and global timestamps ([[cref:theory:itm:timestamps]]) are incremented via the same clock.
As per [[textcite:&arm-rm p. C1-710]] this may not necessarily be the case: "[Global timestamps] provide absolute timestamp values, based on a system global timestamp clock" whereas "[Local timestamps are generated] from the timestamp clock in the [[gls:ITM]] unit".
[[textcite:&arm-rm Figure C1-1]] can on the other hand be interpreted to imply that both local and global timestamps are derived from this global timestamp clock, but it is nowhere unambiguously stated as such.
Due to this ambiguity it is presumed that the relationship between the clocks that generate local and global timestamps is unknown and thus [[gls:MCU]]-specific;
=itm= should be adapted to account for this.
Refer to [[textcite:&issue:itm:12]] regarding the progress on this issue.

**** Graphically representing traces
During experimentation with the Microchip ATSAME51N20A [[gls:MCU]] the want to graphically represent a trace result arose.
Subsequently, an ad-hoc fork of =rtic-scope-frontend-dummy= --- =feat/auto-plot= from [[textcite:&rtic-scope:dummy-auto-plot]], =src/main.rs= of chief interest --- was created that converts the trace to a [[gls:CSV]] representation and then plots it.
When the [[gls:RTIC]] application in [[cref:lst:app-atsame-example-src-main]] has been traced and then replayed the dummy produces the plot in [[cref:fig:auto-plot-example]].

From this proof of concept it is immediately clear that a graphical representation of a recorded trace holds great value for system insight;
further work to this end is warranted.
Refer to [[textcite:&issue:cargo-rtic-scope:135]] and [[textcite:&issue:cargo-rtic-scope:89]].

A third-party RTIC Scope [[gls:frontend]] has seen some development that graphically plots [[gls:task]] run-times [[parencite:&racer]], but is not yet compatible with RTIC Scope v0.3.

** Conclusion
:PROPERTIES:
:CUSTOM_ID: conclusion
:END:
The RTIC Scope project fulfills all requirements enumerated in [[cref:requirements]] with the delimitations enumerated in [[cref:delimitations]] in mind.
While user [[gls:overhead]] has been minimized as much as possible within the allotted development time overhead may still be considered significant depending on factors of [[gls:HAL]] availability and complexity of the embedded system.
Future work ([[cref:fut]]) is warranted to improve RTIC Scope.

** Backmatter                                                       :ignore:
[[printglossaries:]]
[[printbibliography:]]
** Appendices                                                       :ignore:
#+begin_export latex
\appendix
\addappheadtotoc
#+end_export
*** The source code of a trivial [[gls:RTIC]] application, traced with RTIC Scope, and the trace result
:PROPERTIES:
:CUSTOM_ID: app:application-example
:END:
This appendix contains the source code of interest in [[textcite:&rtic-scope:atsame-example]] that relates to the application of RTIC Scope, namely
- =src/main.rs= :: in [[cref:lst:app-atsame-example-src-main]]; and
- =Cargo.toml= :: in [[cref:lst:app-atsame-example-manifest]],
but also the trace results, namely
- [[cref:lst:app-atsame-example-trace-itm]] :: when [[gls:tracing]] with =itm-decode= from [[textcite:&itm]];
- [[cref:lst:app-atsame-example-trace-scope]] :: when recording a trace with RTIC Scope;
- [[cref:lst:app-atsame-example-trace-scope-replay-list]] :: when listing the recorded traces; and
- [[cref:lst:app-atsame-example-trace-scope-replay]] :: when replaying the recorded trace.

The output of an experimental fork of =rtic-scope-frontend-dummy=, =feat/auto-plot= from [[textcite:&rtic-scope:dummy-auto-plot]], is also provided that graphically plots the trace replayed in [[cref:lst:app-atsame-example-trace-scope-replay]].
Refer to [[cref:fig:auto-plot-example]].

#+begin_export latex
\inputminted{rust}{rtic-scope-atsame-example/src/main.rs}
\captionof{listing}{Trivial \gls{RTIC} application configured for \gls{tracing} via RTIC Scope (lines 52--68) for execution on the Microship ATSAME51N20A \gls{MCU}. The spawned \gls{software-task}, \texttt{app::software}, preempts the \gls{hardware-task}, \texttt{app::hardware}, and delays further execution for 100 ms. Note the \texttt{trace} macro on \texttt{app::software}. \label{lst:app-atsame-example-src-main}}
#+end_export

#+begin_export latex
\inputminted{toml}{rtic-scope-atsame-example/Cargo.toml}
\captionof{listing}{Crate manifest for the \gls{RTIC} application in \cref{lst:app-atsame-example-src-main}. Lines 7--17 declare the metadata required by RTIC Scope. \label{lst:app-atsame-example-manifest}}
#+end_export

#+NAME: lst:app-atsame-example-trace-itm
#+CAPTION: Trace recorded from the executed \gls{RTIC} application in \cref{lst:app-atsame-example-src-main} via ~itm-decode~ from [[textcite:&itm]].
#+begin_src text
  $ itm-decode /path/to/dev/tty --itm-freq 1000000
  ExceptionTrace { exception: Interrupt { irqn: 12 }, action: Entered }
  ExceptionTrace { exception: Interrupt { irqn: 13 }, action: Entered }
  LocalTimestamp1 { ts: 24, data_relation: Sync }
  DataTraceValue { comparator: 1, access_type: Write, value: [0] }
  LocalTimestamp1 { ts: 45, data_relation: Sync }
  DataTraceValue { comparator: 2, access_type: Write, value: [0] }
  ExceptionTrace { exception: Interrupt { irqn: 13 }, action: Exited }
  LocalTimestamp2 { ts: 5 }
  ExceptionTrace { exception: Interrupt { irqn: 12 }, action: Returned }
  ExceptionTrace { exception: Interrupt { irqn: 12 }, action: Exited }
  LocalTimestamp2 { ts: 2 }
  ExceptionTrace { exception: ThreadMode, action: Returned }
#+end_src

#+NAME: lst:app-atsame-example-trace-scope
#+CAPTION: Trace recorded from the executed \gls{RTIC} application in \cref{lst:app-atsame-example-src-main} via RTIC Scope. The target is traced for ten seconds. ~rtic-scope-frontend-dummy~ is used as the \gls{frontend}.
#+begin_src text
  $ cargo rtic-scope trace --serial /path/to/dev/tty --dont-touch-target
      Building RTIC target application...
    Recovering metadata for rtic-scope-atsame-example (/path/to/rtic-scope-atsame-example/src/main.rs)...
     Recovered 2 task(s) from rtic-scope-atsame-example: 1 hard, 1 soft.
      Frontend dummy: @2000 ns (+2000 ns) [good]: [Task { name: "app::hardware", action: Entered }]
      Frontend dummy: @5750 ns (+3750 ns) [good]: [Task { name: "app::software", action: Entered }]
      Frontend dummy: @6167 ns (+417 ns) [good]: [Task { name: "app::software", action: Exited }]
      Frontend dummy: @6334 ns (+167 ns) [good]: [Task { name: "app::hardware", action: Returned }, Task { name: "app::hardware", action: Exited }]
        Traced rtic-scope-atsame-example: 10 packets processed in 10s (~1.0 packets/s; 0 malformed, 0 non-mappable); 2/2 sinks operational.
#+end_src

#+NAME: lst:app-atsame-example-trace-scope-replay-list
#+CAPTION: Listing of recorded traces after the execution of [[cref:lst:app-atsame-example-trace-scope]]. Only a single trace is available for replay, its index 0.
#+begin_src text
  $ cargo rtic-scope replay --list
  idx     trace file
  0       /path/to/rtic-scope-atsame-example/target/rtic-traces/rtic-scope-atsame-example-gf7dd449-dirty-2022-03-21T11:16:31.trace
#+end_src

#+NAME: lst:app-atsame-example-trace-scope-replay
#+CAPTION: Replay of the trace file of index zero listed in [[cref:lst:app-atsame-example-trace-scope-replay-list]], recorded by executing [[cref:lst:app-atsame-example-trace-scope]]. ~rtic-scope-frontend-dummy~ is used as the \gls{frontend}.
#+begin_src text
  $ cargo rtic-scope replay 0
      Frontend dummy: @2000 ns (+2000 ns) [good]: [Task { name: "app::hardware", action: Entered }]
      Frontend dummy: @5750 ns (+3750 ns) [good]: [Task { name: "app::software", action: Entered }]
      Frontend dummy: @6167 ns (+417 ns) [good]: [Task { name: "app::software", action: Exited }]
      Frontend dummy: @6334 ns (+167 ns) [good]: [Task { name: "app::hardware", action: Returned }, Task { name: "app::hardware", action: Exited }]
      Replayed rtic-scope-atsame-example: 10 packets processed in 0s (~inf packets/s; 0 malformed, 0 non-mappable); 1/1 sinks operational.
#+end_src

#+NAME: fig:auto-plot-example
#+CAPTION: Graphical representation of the trace yielded by [[textcite:&rtic-scope:dummy-auto-plot]], equivalent to [[cref:lst:app-atsame-example-trace-scope-replay]]. ~app::software~ preempts ~app::hardware~ after approximately 5600 ns. At approximately 6100 ns ~app::hardware~ resumes execution. Task context switch overhead not plotted.
[[file:svgs/auto-plot-example.svg]]
* Footnotes
[fn:not-of-concern] Functionality not of concern for RTIC Scope v0.3.1.

[fn:exception-number-0] During experimentation packets with a zero in this field were encountered. [[textcite:&arm-rm Section B1.3.1]] notes that a /Thread mode/ is entered on target reset.  [[gls:RTIC]] executes its task by help of exceptions which warrant an enter into a /Handler mode/. [[textcite:&arm-rm p. B1-517]] comments that a value of [[gls:IPSR]] is zero if no exception handler is executing. These Thread mode changes were always observed before and after non-preempted [[gls:RTIC]] tasks entered and exited. An exception number of 0 is then ultimately ignored by RTIC Scope v0.3.

[fn:dwt-n] $n$ emphasized for reasons of readability.
