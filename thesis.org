# -*- eval: (org-indent-mode +1) -*-
# -*- eval: (visual-line-mode +1) -*-

#+TITLE: RTIC Scope — Real-Time Tracing Support for the RTIC RTOS Framework
#+AUTHOR: Viktor Vilhelm Sonesten
#+EMAIL: vikson-6@student.ltu.se
#+LANGUAGE: en
#+OPTIONS: ':t toc:nil title:nil todo:nil H:6

#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: thesis
#+LATEX_CLASS_OPTIONS: [a4paper,10pt]
#+latex_header: \usepackage{kpfonts}[maths]
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{inconsolata}
#+latex_header: \usepackage[style=apa,hyperref=true,url=true,backend=biber]{biblatex}
#+latex_header: \addbibresource{./ref.bib}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{newfloat}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{frame=lines,breaklines,breakafter=/.,fontsize=\footnotesize,linenos}
#+LATEX_HEADER: \usepackage[inline]{enumitem}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks=true,urlcolor=blue,linkcolor={red!50!black},citecolor=blue,breaklinks=true}
#+LATEX_HEADER: \usepackage{glossaries}
#+latex_header: \usepackage{microtype}
#+latex_header: \usepackage{tocbibind}
#+latex_header: \usepackage{todonotes}
#+latex_header: \usepackage[capitalize]{cleveref}
#+LATEX_HEADER: \makeglossaries

# NOTE auto linebreaks / : - and _ inside \textttBreak. Adapted from <https://tex.stackexchange.com/a/219497>.
#+latex_header: \catcode`_=12 %
#+latex_header: \newcommand{\textttBreak}[1]{%
#+latex_header:   \begingroup
#+latex_header:   \ttfamily
#+latex_header:   \begingroup\lccode`~=`/\lowercase{\endgroup\def~}{/\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`-\lowercase{\endgroup\def~}{-\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`_\lowercase{\endgroup\def~}{_\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`:\lowercase{\endgroup\def~}{:\discretionary{}{}{}}%
#+latex_header:   \catcode`/=\active\catcode`-=\active\catcode`_=\active\catcode`:=\active
#+latex_header:   \scantokens{#1\noexpand}%
#+latex_header:   \endgroup
#+latex_header: }
#+latex_header: \catcode`_=8 %

#+latex_header: \usepackage[htt]{hyphenat}

#+NAME: glossary
| label       | name            | description |
|-------------+-----------------+-------------|
| tokenstream | tokenstream     | cock        |
| token       | token           | TODO        |
| static-anal | static analysis | TODO        |
| sample-rate | sample rate     | TODO        |
| downstream  | downstream      | TODO        |
| frontend    | frontend        | TODO        |
| upstream    | upstream        | TODO        |
| elf:data    | \texttt{.data}  | TODO        |
| JSON        | JSON            | TODO        |
| cdylib      | cdylib          | TODO        |

# TODO cdylib above: A cdylib crate is a crate that specifies =crate_type = ["cdylib"]=. Upon building the crate a dynamic library (a shared object file) that targets the stable C ABI is generated. Additionally, it is trivial to find the file location of cdylibs with cargo. This is not the case with dylibs that instead target the unstable Rust ABI. The only way to generate a shared object file is by building a dylib or a cdylib.

# XXX some of these should link to the glossary
#+NAME: acronyms
| key           | abbreviation     | full form                                             |
|---------------+------------------+-------------------------------------------------------|
| PC            | PC               | \textit{program counter}                              |
| CPU           | CPU              | \textit{central processing unit}                      |
| RTIC          | RTIC             | \textit{Real-Time Interrupt-driven Concurrency}       |
| RTOS          | RTOS             | \textit{real-time operating system}                   |
| SRP           | SRP              | \textit{Stack Resource Policy}                        |
| DCB           | DCB              | \textit{Debug Control Block}                          |
| SCS           | SCS              | \textit{System Control Space}                         |
| SCB           | SCB              | \textit{System Control Block}                         |
| DCB_DEMCR     | DEMCR            | \textit{Debug Exception and Monitor Control Register} |
| ITM           | ITM              | \textit{Instrumentation Trace Macrocell}              |
| TPIU          | TPIU             | \textit{Trace Port Interface Unit}                    |
| DWT           | DWT              | \textit{Data Watchpoint and Trace}                    |
| ETB           | ETB              | \textit{Embedded Trace Buffer}                        |
| WCET          | WCET             | \textit{Worst Case Execution Time}                    |
| EDF           | EDF              | \textit{Earliest Deadline First}                      |
| PAC           | PAC              | \textit{Peripheral Access Crates}                     |
| API           | API              | \textit{Application Programming Interface}            |
| TPIU_ACPR     | TPIU\_ACPR       | \textit{Asynchronous Clock Prescaler Register}        |
| ETM           | ETM              | \textit{Embedded Trace Macrocell}                     |
| DWT_CTRL      | DWT\_CTRL        | \textit{Control Register}                             |
| TPIU_TYPE     | TPIU\_TYPE       | \textit{TPIU Type Register}                           |
| ITM_TCR       | TPIU\_TCR        | \textit{Trace Control Register}                       |
| RAZ-WI        | RAZ/WI           | \textit{Read-As-Zero, Writes Ignored}                 |
| RAZ           | RAZ              | \textit{Read-As-Zero}                                 |
| RAO           | RAO              | \textit{Read-As-One}                                  |
| DWT_FUNCTIONn | DWT\_FUNCTION$n$ | \textit{Comparator Function registers}                |
| SBZ           | SBZ              | \textit{Should-Be-Zero}                               |
| DWT_COMPn     | DWT\_COMP$n$     | \textit{Comparator registers}                         |
| DWT_MASKn     | DWT\_MASK$n$     | \textit{Comparator Mask registers}                    |
| AST           | AST              | \textit{Abstract Syntax Tree}                         |

# TODO install and apply a grammar checker.
# TODO use glossary everywhere <https://www.overleaf.com/learn/latex/Glossaries>
# TODO +NAME all listings?
# TODO cite any mentioned crates.
# TODO call an RTIC app just that, or firmware, throughout.
# TODO fix cites to sections (remove the "p."?)
# TODO verify software versions with Cargo.lock from v0.3.0 tag.
# TODO fix hbox overflows on texttt in list of listings, bibliography, glossary
# TODO fix second list of listings page saying "list of figures"
# TODO tweak geometry for last overfull hboxes

* Org setup                                                        :noexport:
  #+begin_src emacs-lisp :result output :session :exports both
    ;; ignore some headlines
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines))

    ;; minted code listings
    (require 'ox-latex)
    (setq org-latex-listings 'minted)

    ;; use the book class, but without any \parts
    (add-to-list 'org-latex-classes
                 '("thesis"
                   "\\documentclass{memoir}"
                   ("\\chapter{%s}" . "\\chapter*{%s}")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    ;; use \cref instead of \ref, for cleveref
    (setq org-ref-default-ref-type "cref")
    (setq org-latex-prefer-user-labels t)

    ;; make so that =some text= yield \textttBreak{some text} instead of
    ;; \texttt{some text}.
    ;;
    ;; NOTE do not use =some text= in section headings or captions.
    (defun org-latex--protect-texttt (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\texttt{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&_#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--protect-textttbreak (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\textttBreak{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--text-markup (text markup info)
      "Format TEXT depending on MARKUP text markup.
    INFO is a plist used as a communication channel.  See
    `org-latex-text-markup-alist' for details."
      (let ((fmt (cdr (assq markup (plist-get info :latex-text-markup-alist)))))
        (cl-case fmt
          ;; No format string: Return raw text.
          ((nil) text)
          ;; Handle the `verb' special case: Find an appropriate separator
          ;; and use "\\verb" command.
          (verb
           (let ((separator (org-latex--find-verb-separator text)))
             (concat "\\verb"
                     separator
                     (replace-regexp-in-string "\n" " " text)
                     separator)))
          (protectedtexttt (org-latex--protect-texttt text))
          (protectedtextttbreak (org-latex--protect-textttbreak text))
          ;; Else use format string.
          (t (format fmt text)))))
    (setq org-latex-text-markup-alist
          '((bold . "\\textbf{%s}")
            (code . protectedtexttt)
            (italic . "\\emph{%s}")
            (strike-through . "\\sout{%s}")
            (underline . "\\uline{%s}")
            (verbatim . protectedtextttbreak)))
  #+end_src
#+RESULTS:

* Frontmatter                                                        :ignore:
#+LATEX: \frontmatter
# Make this a single paragraph; use unambiguous terms; aim for 250 words; 3-5 keywords.
#+begin_abstract
Here be an abstract...
#+end_abstract
#+begin_export latex
\newlist{inline-enum}{enumerate*}{1}
\setlist[inline-enum]{label=(\roman*)}

% Include "List of Listings" in the TOC
\renewcommand{\listoflistings}{
  \cleardoublepage
  \addcontentsline{toc}{chapter}{\listoflistingscaption}
  \listof{listing}{\listoflistingscaption}
}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\listoftodos
\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage
\listoflistings
\newpage

% Start counting with arabic numbers
\mainmatter

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Fix todonotes behavior
\setlength{\marginparwidth}{2cm}
\reversemarginpar
#+end_export

* *The Paper*                                                        :ignore:
** Introduction
# What are embedded systems, regulators, and how do they relate?
Embedded systems --- a unit combination of a central processing unit, system memory, and input/output peripheral devices --- serve a key role in the operation of systems with electronical components where computations must be made.
A prime examples of such systems are digital control systems which regulate one or more control quantities such that they adhere to designed characteristics.
Often the goal is to track a reference signal; such a control system is known as a regulator.
A regulator observes (either directly or by approximation) the internal states of a system under control via sensors and affect the system via actuators.
For example, one may wish to keep a rocket on a set path to reach orbit, or control the internals of a nuclear power plant to maximize electrical power output while keeping the plant within safe operation boundaries.

# On the real-time restrictions of control systems; exponential complexity phenomena.
A key design parameter of digital controllers is the [[gls:sample-rate][sample rate]]: if too low or unconsistent, the controlled system will end up unstable [[parencite:&franklin]].
The rocket may thus fly off course, or the nuclear reactor reach a meltdown.
This puts a real-time constrain on the digital controller which greatly limits how it can be implemented.
Further, a digital controller under implementation must be debugged so that the engineers can verify its correct operation and realize the real-time constrain.
This task grows exponentially in difficulty with as the number of system states, inputs, and outputs increase.
A similar phenomena is observed for embedded systems with an increasing number of tasks.[fn:2]

# The observer effect; data exfiltration.
Unfortunately are embedded systems subject to the observer effect: to observe the internal state of a embedded system (i.e., system variables in memory) its operation must be affected.
# A proper implementation would not block on a serial write.
This observeration is often realized by exfiltrating data via serial communication which in the best case can induce bus contention and full output queues,
but it is not uncommon that a program blocks until the data has been serialized, severely affecting the regulation if the payload is large.
In a perfect implementation, the user application[fn:1] would only concern itself with its mainsake regulation procedure and leave data exfiltration to a completely disjoint system, removing the observer effect and thus the effect on the underlying control system.

# ARM, tracing subsystem and possible exploitation.
ARM is an ubiquitous vendor for embedded systems with a number of sub-vendors (e.g. STMicroelectrics, NXP Semiconductors, Nordic Semiconductors).
The ARMv7-M platform standard offers debugging facilities that enables the developer to trace the system.
From [[textcite:&arm-cortex-learn]]: "Trace refers to the process of capturing data that illustrates how the components in a design are operating, executing, and performing".
Additionally, "[Trace generation is] almost entirely non-invasive. [Trace generation] does not influence the wider system".
These trace facilities allows for an event-based monitoring of
- interrupt handler enters and exits (tracing of hardware-bound tasks);
- Read and write access to in-memory address spaces (system state variables, software tasks); and
- [[acrfull:PC]] samples, among other features.
The generated trace is then exfiltrated via asynchronous serial using a packet protocol (described in [[#debug-periphs]]), henceforth referred to as the "trace stream".
These facilities are not disjoint (if they were, no insight into the system could be offered) but because the generation of the trace stream does not influence the wider system (as per [[citeauthor:&arm-cortex-learn]]) the trace stream (with system-external collection) is a suitable candidate for exploitation to realize insight into a control system with minimal observer effect.

# Less work, more sleep.
Further, with non-invasive trace generation, less code must be executed by the [[acrfull:CPU]], allowing a shorter duty-cycle of the user application.
With a decreased duty-cycle, the system can be put to sleep longer, and thus conserve energy.

# On real-time implementation restictions, embedded implementation difficulties in general. Enter RTIC.
The development of embedded system in general is a difficult one.
In comparison to general-purpose computers, where one often need not worry about resource limitations, embedded systems are constrained in all manners such that costs can be minimized for their non-general applications.
# No rich OS; no two embedded platforms are the same.
An embedded developer seldom have access to a rich operating systems --- a Linux-based distibution, for example --- which offers general-purpose facilities based on dynamic allocations and a common environment to simplify implementation.
Embedded platforms usually differ significantly, and porting an implementation to another platform is no small task.
This compares to general-purpose computers where a program written on one computer can be executed on another one, as long as the operating environment remains the same.
# Side effects and priority inversions.
Embedded platforms are much more subject to side-effects where peripherals are operated by writing data to memory-mapped registers.
Of certain importance is the problem of priority inversions, where a task of lower priority executes instead of a higher prioritized task because of implementation error.
In summary it is easy to put an embedded system in an incorrect or unknown state.
# Enter RTIC.
In order to lighten the implementation burden one may employ [[Acrfull:RTIC]] (see [[#rtic]]), [[textcite:&rtic]]: a [[Acrfull:RTOS]] developed at Luleå Technical University based on the extensively studied [[Acrfull:SRP]], which
- prevents deadlocks;
- mitigates priority inversions; and
- is compatible with [[Acrfull:EDF]] sheduling [[parencite:&srp]].
RTIC thus removes some burden out-of-the-box while also
- implementing message passing between tasks;
- incurring a minimal scheduling overhead;
- being highly efficient on memory usage; and
- being amenable to [[Acrfull:WCET]] analysis [[parencite:&rauk]].

# Oh yeah, and Rust
RTIC is written in Rust which removes additional developer overhead (see [[#rust]]).

# Project aim
The aim of this thesis is thus to employ and extend upon RTIC with a toolset, aptly named RTIC Scope, to leverage [[Citeauthor:&arm-cortex-learn][ARM]]'s non-intrusive tracing facilites while requiring minimal overhead for the end-user developer to apply the toolset, greatly lightening the burden when implementing a digital control systems.
The resulting toolset will be employed to implement a regulator for a non-trivial dynamic system (see [[#control-application]]), and the functionality and ergonomics of the toolset evaluated (see [[#discussion]]).

*** Background
This introductory section covers the software components that have realized RTIC Scope.

**** The Rust programming language
:PROPERTIES:
:CUSTOM_ID: rust
:END:
Rust is a system programming language that guarantees the absence of mutable aliasing and defined run-time behavior as long as code is written in a /safe/ context.
Refer to [[textcite:&rust-lang]].

For a summary of Rust in an embedded context, refer to [[textcite:&tjader2021rtic 6--8]].

**** [[Acrfull:PAC]]
:PROPERTIES:
:CUSTOM_ID: background:PAC
:END:
# What is a PAC and what are they used for?
A PAC is a Rust library crate which exposes an [[gls:API]] for hardware peripherals.
Rather than providing an ad-hoc implementation inlined in an embedded application, a PAC provides a convenient interface to read and write to memory-mapped registers in order to mutate (in order to configure) and query (in order to poll the status of) hardware peripherals.

# Differentiate {architecture,device}-specific PACs
In the embedded Rust ecosystems, these are two kinds of PACs:
- architecture-specific :: Architecture-specific PACs expose an API for hardware peripherals common to all embedded systems that share the same architecture, commonly denoted as a "family". For example, ~cortex-m~ [[parencite:&cortex-m]] is a PAC that targets the ARM Cortex-M family of embedded systems, which is based on the ARMv7-M standard.
- device-specific :: Device-specific PACs expose an API for hardware peripherals available on a smaller family of embedded systems.
  For example, ~stm32-rs~ [[parencite:&stm32-pac]] is a collection of PACs targeting all microcontrollers in the STMicroelectronics STM32 family.

# svd2rust
A common tool to generate PACs is ~svd2rust~ [[parencite:&svd2rust]].

# TODO reformat
An example declaration of such an enum can be seen in [[lst:pac-interrupt-example]].
#+NAME: lst:pac-interrupt-example
#+CAPTION: Example declaration of a ~PAC::Interrupt~ enum. Left-hand side of ~Interrupt~ is the IRQ label; right-hand is $N$ in [[tbl:irqns]].
#+begin_src rust
  pub mod PAC {
      #[derive(Debug)]
      #[repr(u16)]
      pub enum Interrupt {
          PVD = 1,
          EXTI0 = 6,
          EXTI1 = 7,
          // ...
      }

      unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
          #[inline(always)]
          fn number(self) -> u16 {
              self as u16
          }
      }
  }
#+end_src

**** [[Acrfull:RTIC]]
:PROPERTIES:
:CUSTOM_ID: rtic
:END:

# TODO Expand: briefly cover rtic::app, how an application is declared, hardware tasks (PAC usage) and task dispatchers.
Hardware tasks are regular Rust functions that are bound to a hardware interrupt.
When this interrupt is made pending in hardware, the task function executes.
An example hardware task is declared via
#+name: rtic-hw-task-example
#+begin_src rust
  #[rtic::app]
  mod app {
      #[task(bound = EXTI0)]
      fn foo(_ctx: foo::Context) {
          // ...
      }
  }
#+end_src
With this declaration, =foo= will be executed when ~EXTI0~ is made pending in hardware.
After =foo= returns, the interrupt has been handled and ~EXTI0~ is no longer pending.


Software tasks are also regular Rust functions that are bound to hardware interrupts, but the bound hardware interrupt is not exclusively associated to the task in question: a single hardware interrupt can be associated with multiple software tasks.
For this reason, the used hardware interrupt is considered a "dispatcher".
An example software task is declared via
#+begin_src rust
  #[rtic::app(dispatchers = [EXTI0])]
  mod app {
      #[task]
      fn bar(_ctx: bar::Context) {
          // ...
      }
  }
#+end_src

In difference to hardware tasks, software tasks can be scheduled by software.
**** Hardware debuggers (probes)
# TODO required for a host system to flash and read data from an embedded system

*** Motivation
# We must cross a hardware boundry when debugging embedded systems.
Debugging the code being executed in an embedded system is an integral part of an embedded work-flow similar to how it is common to attach to and debug a process of a program being developed on a general-purpose computer.
The latter process can be considered trivial because no hardware boundries must be crossed; the debugger and debugged program are (usually) contained within the same system.
Debugging an embedded system is on the other hand non-trivial: the embedded system is its own contained system and a line of communication[fn:: Which requires a hardware debugger.] must be established with a host system to debug the embedded system.
\missingfigure{Draw a comparison between conventional debugging and embedded debugging.}

# We want to be able to debug in real-time (read: trace), but also record it.
An important aspect of debugging is the act of debugging in real-time, often referred to as the act of "tracing".
By tracing an embedded system it is possible to verify its internal operations continuously as long as a debugger is attached.
Another important aspect of debugging are post-mortem analyses: being able to analyse a system's run-time behavior before it ended up in an invalid or unexpected state after the fact.
Port-mortem analyses are realized by recording a trace from the attached debugger.
Such analyses are useful for systems deployed "in the field" which are seldom continuously controlled by human hands.
An example of such a system is a charger for electrical vehicles: verifying the operation of the charger is much easier before it is permanently installed at a parking space and expected to operate continuously.
If the charger breaks the responsible engineers will want to have a detailed log of events that occured before the device broke in order to improve it.

# Tracing is zero-cost by help of hardware, but not trivial to configure.
Tracing is supported by hardware debug facilities on the ARMv7-M platform, as is the exfiltration of the trace stream from the device (a line of communication which can be read by a host system).
Enabling and correctly configuring these facilites to generate a trace stream and decoding the trace stream itself is no trivial task, however.

# The emergence of RTIC, and its lack of debug tools.
RTIC is a novel RTOS which offers improvements over conventional RTOSs [[parencite:&tjader2021rtic 23]].
The motivation behind RTIC Scope is thus to offer a "batteries included"[fn:: where details regarding trace stream generation and decoding is abstracted, and where no additional work must be done to utilize the tool.] toolset that enables instant insight into an RTIC application.
Such a toolset would make it easier to verify the implementation of an RTIC application.

# Control application.
RTIC Scope will then be used to verify the implementation of a regulator for a complex dynamic system (see [[#control-application]]).
This is done in order to establish a base-line for the end-user experience of the toolset, in order to improve upon it; and provide an example where the toolset is applied to a realistic RTIC application, in the hopes of increasing the usage of RTIC and RTIC Scope. \todo{rephrase?}
The regulation of a complex dynamic system is chosen because an RTIC application for such a task is non-trivial, and it provides an ample opportunity to improve one's capabilities for control engineering.

*** Problem definition
:PROPERTIES:
:CUSTOM_ID: requirements
:END:
This thesis covers the development of an analysis toolset, RTIC Scope, that enables an RTIC application developer to gain non-invasive insight into the run-time of said application by exploiting the trace stream generated and exfiltrated by the debug facilities (see [[#debug-periphs]]) made available by the ARMv7-M standard, which RTIC supports by targeting Cortex-M platforms.

The set of /requirements/ RTIC Scope must fulfill within the scope of this thesis follows: RTIC Scope *MUST*[fn:: Interpreted as described in [[textcite:&rfc2119]].] be able to
1. <<req:itm-gen>> enable trace stream generation of hardware and software tasks (as defined by RTIC), and enable exfiltration of said trace stream from the device, by help of a target-side tracing library crate;
2. <<req:input>> read the generated trace stream via a hardware debugger or a serial device;
3. <<req:decode>> decode the trace stream to Rust structures;
4. <<req:rtic>> recover RTIC application metadata not contained within the trace stream;
5. <<req:timestamps>> associate timestamps to RTIC task events;
6. <<req:protocol>> report RTIC task events in real-time to the RTIC Scope end-user by use of a defined communication protocol.
7. <<req:dummy>> offer a reference implementation of a [[gls:frontend]] which implements the the protocol described in Requirement [[req:protocol]].
8. <<req:record>> record a trace to file which can be replayed offline; and
9. <<req:cargo>> be invoked as a ~cargo~ subcommand.

Delimitations to the above requirements apply, see [[#delimitations]].
*** Delimitations
:PROPERTIES:
:CUSTOM_ID: delimitations
:END:
In order to focus on the delivery of a robust toolset with proper implementation and documentation the scope of this thesis have been limited.
These /delimitations/[fn:: Uses the key words *MUST* and *SHOULD NOT* which are to be interpreted as described in [[textcite:&rfc2119]].], which are related to the requirements enumerated in [[#requirements]], are as follows:
1. Requirement [[req:itm-gen]]: RTIC Scope *MUST* apply the device mutations that are common to all ARM Cortex-M targets in order to enable trace stream generation and exfiltration. RTIC Scope *SHOULD NOT* apply device-specific mutations.
2. Requirement [[req:input]]: RTIC Scope *SHOULD NOT* have to ensure that a trace stream is read from the device; that responsibility falls upon the RTIC Scope end-user. However, RTIC Scope *MUST* fail or warn the end-user if it is unable to correctly decode the read data stream.
3. Requirement [[req:rtic]]: RTIC Scope *MUST* support RTIC version 1.0.0, see [[textcite:&rtic]].
   RTIC Scope *MUST* must recover metadata necessary to report the timestamped status of hardware and software tasks, as defined by RTIC.
4. Requirement [[req:protocol]]: The defined communication protocol *MUST* enable one-way communication from the ~cargo~ subcommand /backend/ to the reference /frontend/. The protocol *SHOULD NOT* enable two-way communication.

Following the above delimitations allows this thesis to be finished within an acceptable time frame[fn:: As defined by the author, i.e. not necessarily the recommended time frame as defined by the X7009E course taken at Luleå Technical University during which this thesis is written.] and also to yield a documented code base which allows future development with minimal friction.

The use of the key words *MUST* and *SHOULD NOT* used above as to be interpreted as described in [[textcite:&rfc2119]].

# TODO describe that this paper only covers v0.3.0, except for the content of future work

*** Contributions
The development of RTIC Scope has yielded a number of [[gls:downstream]] contributions, namely a collection of crates:
- ~cargo-rtic-scope~ :: A ~cargo~ subcommand acting as the RTIC Scope backend (or host-side /daemon/) which fulfill Requirements [[req:input]]--[[req:protocol]] and [[req:record]]--[[req:cargo]].
  See [[#impl:cargo-rtic-scope]] and [[textcite:&rtic-scope:cargo-rtic-scope]].
- ~rtic-scope-frontend-dummy~ :: A reference implementation of a RTIC Scope frontend, which fulfill Requirement [[req:dummy]].
  See [[#impl:rtic-scope-frontend-dummy]] and [[textcite:&rtic-scope:dummy]].
- ~rtic-scope-api~ :: The communication protocol the ~cargo-rtic-scope~ uses to report RTIC task events in real-time to ~rtic-scope-frontend-dummy~, as described by Requirement [[req:protocol]].
  See [[#impl:api]] and [[textcite:&rtic-scope:api]].
- ~cortex-m-rtic-trace~ :: An auxilliary target-side crate that properly configure the device for trace stream generation and exfiltration, which fulfills Requirement [[req:itm-gen]].
  See [[#impl:rtic-trace]] and [[textcite:&rtic-scope:rtic-trace]].
- ~itm~ :: A library crate for decoding the trace stream exfiltrated from the embedded system, which fulfill Requirements [[req:decode]] and [[req:timestamps]] (partially).
  See [[#impl:itm]] and [[textcite:&itm]].

Of certain note it ~itm~ which ~cargo-rtic-scope~ relies on: its implementation does not rely on RTIC and can be used independently of RTIC Scope; ~itm~ can be used to decode trace stream generated by a target using an RTOS other than RTIC.
Because of this general nature and detachment from RTIC Scope it must not necessarily be a part of the RTIC Scope project itself, but is as of writing for reasons of convenience.
See [[#disc:itm-embedded-wg]] for a discussion on under what banner ~itm~ belongs.

Further, a number of [[gls:upstream]] contributions have been made to the crates which RTIC Scope depends on.
An exhaustive summary of these contributions are described below (listed in no particular order).

- ~probe-rs/probe-rs~ ::
  A "a modern, embedded debugging toolkit, written in Rust" [[parencite:&probe-rs]] utilized to fulfill Requirement [[req:input]].
  Contributions are:
  - /Reintroduce ~CargoOptions~ in ~mod common_options~/: patch set included in a larger refactor [[parencite:&pr:probe-rs:760]].
  - /arm: enable exception trace on ~setup_swv~/: improves tracing support for ARM targets [[parencite:&pr:probe-rs:758]].
  - /cargo: bump bitvec/: updates a dependency [[parencite:&pr:probe-rs:757]].
  - \textit{arm/itm: doc fields, enable global timestamps}: improves documentation [[parencite:&pr:probe-rs:728]].
  - \textit{Add generic probe/session logic from cargo-flash}: improves composability with RTIC Scope [[parencite:&pr:probe-rs:723]].
  - \textit{deprecate internal ITM/DWT packet decoder in favour of itm-decode}: replaces an unfinished internal trace stream decoder with an ~itm~ precursor; see [[#impl:itm]] [[parencite:&pr:probe-rs:564]].

  Refer to [[#impl:cargo-rtic-scope]] for a detailed description of the usage of this toolkit.
- ~probe-rs/cargo-flash~ ::
  A "cargo extension for programming microcontrollers" [[parencite:&cargo-flash]], functionality of which is used by ~cargo-rtic-scope~.
  Contributions are:
  - /move probe, session logic, flash downloader to probe-rs-cli-util/: moves functionality from ~cargo-flash~ to an auxilliary ~probe-rs~ library crate such that they can be utilized by ~cargo-rtic-scope~ [[parencite:&pr:cargo-flash:188]].

- ~rust-embedded/cortex-m~ :: A library crate that enables "low level access to Cortex-M processors" [[parencite:&cortex-m]], utilized to fulfill Requirement [[req:itm-gen]], [[req:decode]] and [[req:record]].
  Contributions are:
  - /scb: derive serde, Hash, PartialOrd for VectActive behind gates/: adds features used by ~itm~ [[parencite:&pr:cortex-m:363]].
  - /Implement various interfaces for trace configuration/: adds features used by ~cortex-m-rtic-trace~ [[parencite:&pr:cortex-m:342]].
  - \textit{TPIU: swo\textunderscore supports: make struct fields public, improve documentation}: fixes an issue in a library module and improves documentation [[parencite:&pr:cortex-m:381]].
  - /CHANGELOG: add missing items/: adds documentation about added features [[parencite:&pr:cortex-m:378]].
  - /itm: derive serde for \texttt{LocalTimestampOptions}, impl gated \texttt{TryFrom<u8>}/: adds features used by ~cargo-rtic-scope~  [[parencite:&pr:cortex-m:366]].
  - /ITM: check feature support during configuration, add busy flag, docs improvement/: ensures hardware support during trace stream generation configuration [[parencite:&pr:cortex-m:383]].

  Refer to [[#impl:rtic-trace]] and [[#impl:itm]] for a detailed description of the usage of this library.
- ~rtic-rs/rtic-syntax~ :: A crate that defines and parses the RTIC meta language [[parencite:&rtic-syntax]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - \textit{improve error string if parse\textunderscore binds is not set}: improves documentation when the crate is used as a library [[parencite:&pr:rtic-syntax:47]].
- ~rtic-rs/cortex-m-rtic~ :: The RTIC implementation for Cortex-M platforms [[parencite:&rtic]].
  Contributions are:
  - \textit{book/migration/v5: update init signature, fix example syntax}: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:480]].
  - /book: detail import resolving for 0.6 migration/: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:479]].
  - /book: update outdated required init signature/: improves RTIC examples in documentation [[parencite:&pr:rtic:478]].
- ~Michael-F-Bryan/include_dir~ :: A crate for embedding file trees in a binary [[parencite:&includedir]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - /Dir: add extract-to-filesystem functionality/: implements functionality for extracting embedded file trees to disk [[parencite:&pr:includedir:57]].
  - \textit{dir/extract: add mode for overwriting existing files}: implements functionality for overwriting existing files when extracting embedded file trees to disk [[parencite:&pr:includedir:65]].

*** Outline
 This paper is structured as follows
 - Introduction :: provides an introduction to Rust, RTIC, ARMv7-M hardware peripherals of interest, and the RTIC Scope project.
 - Previous work :: presents work previously done in the same domain, which this thesis builds upon.
 - Related work :: presents some tools similar to the features of RTIC Scope.
 - Implementation :: covers the implementation of RTIC Scope and the ~itm~ crate.
 - Results :: TODO
 - Discussion :: TODO
 - Conclusions :: TODO
 - Future work :: TODO
 - Appendices :: TODO

** Previous and Related Work
*** Related work
# TODO convert to references
Some toolsets similar to RTIC Scope were already available before the start of this thesis, namely:
- orbuculum :: https://github.com/orbcode/orbuculum, an ARM Cortex-M trace stream demuxer and post-processor;
- Percepio Tracealyzer :: https://percepio.com/tracealyzer/, proprietary visual trace diagnostic tool that supports a multitude of platforms and RTOSs.

Neither of the tools support RTIC, nor have any inspiration been taken from them during the development of RTIC Scope.

*** Previous work
The implementation of RTIC Scope stands of the shoulders of countless developers that have enabled the implementation of the toolset within the frame of this thesis.
Of certain note are
- ~cortex-m~ :: that enable low-level access to Cortex-M processors;
- ~probe-rs~ :: an extensible embedded debugging toolkit;
- ~rtic-syntax~ :: RTIC meta language parser library; and
- ~itm~ (version 0.3) and ~itm-tools~ :: library and tools for analyzing ITM traces.

For a full list of dependant crates used by RTIC Scope, execute
#+begin_src shell
  $ cargo install cargo-tree
  $ git clone https://github.com/rtic-scope/cargo-rtic-scope.git && cd cargo-rtic-scope
  $ cargo tree
#+end_src

** Theory
This chapter covers the theory, tools, and the ARMv7-M hardware features utilized in order to develop RTIC Scope.
*** ARMv7-M debug facilities
:PROPERTIES:
:CUSTOM_ID: debug-periphs
:END:
This section summarizes the [[Acrfull:ITM]] packet protocol and the hardware peripherals responsible for its generation and device exfiltration.
For sake of brevity this section is not exhaustible and only covers the subset of ITM packets that RTIC Scope utilizes as of version v0.3.0 [[parencite:&rtic-scope]].
For more information on each peripheral, refer to the respective sections in [[textcite:&arm-rm]].

# DWT -> ITM -> TPIU -> ETB.
RTIC Scope utilizes the [[Acrfull:DWT]], ITM, [[Acrfull:TPIU]], and [[Acrfull:ETB]] peripherals for on-target trace generation and trace extraction.
The DWT and ITM peripherals are sources of ITM protocol packets which are forwarded to the TPIU and ETB for device exfiltration via serial communication.
\missingfigure{Draw the DWT -> ITM -> TPIU -> ETB relationship.}

These peripherals are summarized below.

**** [[Acrfull:DWT]]
# Summarize DWT functionality exploited in RTIC Scope
# TODO "responsible for hardware events"
The DWT peripheral provides the core of the utilized hardware tracing functionality by generating packets when
- a configured range of data is read or written by help of hardware comparators (known as "data tracing"); and
- whenever the processor enters an exception handler and returns from it (known as "exception tracing").
Thus, tracing of hardware-bound RTIC tasks can be achieved by intercepting exception trace packets, and software tasks can be traced by writing a unique task identifier to a monitored address and intercepting the data trace packets.

# DWT comparators /can/ trace RTIC resources, but its complex
# TODO move to future work
# RTIC resources can theoretically also be traced by help of DWT comparators, but such as approach would be relatively complex.
# A data trace value packet contains up to one word (32 bits) of information.
# If the RTIC resources fits within a word only a single packet must be intercepted.
# However, a more common praxis is the usage of non-primitive resources which have differing sizes between an debug and optimized build of the target application.
# The more common case is then the need to intercept multiple data trace value packets from which the resources must be reconstructed.
# The need to emit more packets increases the possibility of DWT buffer overflows events, during which the packet is dropped and an overflow packet is generated instead.
# Of note is that the overflow packet does not contain any information on what caused the overflow.
# Assuming that all packets can be send and intercepted without buffer overflows, the issue of reconstucting the most-likely non-primitive data structures remain.
# This requires DWARF information and is a project on its own.

All the packets generated by the DWT unit are known as "hardware event packets" and are sent to the ITM unit and then forwarded to the TPIU.

Refer to [[textcite:&arm-rm C1.8]] for more information on the DWT unit.
**** [[Acrfull:ITM]]
# Summarize ITM functionality
The ITM unit is of an auxilliary nature; it has three functions:
- the multiplexing of hardware event packets from the DWT unit with its own instrumentation packets which are then forwarded to the TPIU;
- control and generation of timestamp packets; and
- a memory-mapped register interface that allows logging of arbitrary data via a maximum of 256 stimulus registers, unused by RTIC Scope.

# Summarize timestamp packets
Timestamp packets are appended to a set of non-timestamp packets that occur at a common timestamp and come in two forms: global and local.
# TODO when exactly is the time counting started?
Global timestamps are absolute and starts counting at the boot of the target device.
Local timestamps are relative to the last local timestamp and resets its count when a new one is generated.
An up-to-date absolute timestamp can be calculated by applying all local timestamp values upon the last global timestamp.
For example, if a global timestamp with the value $10$ is emitted after which two local timestamps with the respective values of $3$ and $4$ are emitted, an up-to-date absolute timestamp is calculated via $10 + 3 + 4 = 17$.
Local timestamps also contain information on the relationship between the local timestamp generation and the corresponding trace packets. The timestamp can be
- synchronous to the generated packets: the timestamp is the counter value when the non-timestamp packets were generated;
- delayed relative to the packets: the timestamp is the counter value when the timestamp packet was generated (the local timestamp value corresponding to the non-timestamp packet generation event is thus unknown, but must be between the previous and current local timestamp value);
- delayed relative to the associated event: synchronous to the generated packets, but the packets themselves were delayed because of other trace output packets; or
- delayed relative to the packets and associated event: a combination of the last two conditions.

# TODO explain what clock drives the global timestamp clock (P710)
# TODO document sync packets (P712)
# TODO document arbitration between packets from different sources (P713)

# TODO Instrumentation packets and RTIC resource tracing
# 32b per stim register, each has a FIFOREADY bit, each instrumentation packet contains at max 4B = 32b
# port number, 0-31

# XXX ITM stims has its own output buffer not related to the DWT output buffer, the status of the ITM output buffer can be queried via FIFOREADY in ITM_STIMx

# TODO add an example figure how a collection of back-to-back trace packets may look like. Timestamp is last in the chain

For more information on the ITM unit, refer to [[parencite:&arm-rm C1.7]]. For more information on global and local timestamps, refer to  [[parencite:&arm-rm C1-710]].
**** [[Acrfull:TPIU]]
# Summarize TPIU functionality
The TPIU provides external visibility of the trace packet stream by serializing...

by serializing these over a set of exposed hardware pins or via the MCU programmer unit (depending on target platform).
Depending on the platform, these can be GPIO pins which can be configured in parallel mode by use of multiple pins or a singular GPIO pin for an asynchronous port.

# Embedded Trace Buffer (ETB), SWO, or parallel trace port

For more information on the TPIU, refer to [[parencite:&arm-rm C1.10]].

# TODO recreate Fig. C1-1 from [[pdf:~/exjobb/thesis/docs/DDI0403E_d_armv7m_arm.pdf::713++0.00][DDI0403E_d_armv7m_arm.pdf: Page 713]] without ETM component.

# XXX The combination of the DWT and ITM packet stream and an asynchronous Serial Wire Output (SWO) is called a Serial Wire Viewer (SWV)
**** [[Acrfull:ETB]]
*** The [[ACRshort:ITM]] packet protocol
:PROPERTIES:
:CUSTOM_ID: theory:itm-proto
:END:
# TODO summarize the packet protocol and cover the packet types which we utilize

#+CAPTION: ARMv7-M Exception/IRQ numbers and names. Copied from [[parencite:&arm-rm Table B1-4]].
#+NAME: tbl:irqns
| Exception number | Exception name/label   |
|------------------+------------------------|
|                1 | Reset                  |
|                2 | NMI                    |
|                3 | HardFault              |
|                4 | MemManage              |
|                5 | BusFault               |
|             7-10 | Reserved               |
|               11 | SVCall                 |
|               12 | DebugMonitor           |
|               13 | Reserved               |
|               14 | PendSV                 |
|               15 | SysTick                |
|               16 | External interrupt 0   |
|                . | .                      |
|                . | .                      |
|                . | .                      |
|         16 + $N$ | External interrupt $N$ |
|------------------+------------------------|

** Implementation
This chapter covers the implementation of ~cargo-rtic-scope~, ~cortex-m-rtic-trace~, and ~rtic-scope-frontend-dummy~ of RTIC Scope and the implementation of ~itm~.
The implementation is presented in a downstream manner, similar to the order in which the RTIC Scope crates are applied.
That is, how
1. ~cortex-m-rtic-trace~ is applied and what it does;
2. ~cargo-rtic-scope~ recovers metadata from the RTIC application and how it reads the raw trace stream from the source;
3. ~itm~ decodes this stream into manageable Rust structures;
4. ~cargo-rtic-scope~ recovers RTIC metadata for the decoded trace stream;
5. this resolved trace stream is forwarded to frontends; and
6. how a frontend handles a trace stream.

As mentioned in [[cref:delimitations]], this chapter covers the v0.3.0 of RTIC Scope.

# TODO dedicated section for the replay verb

# TODO list a whole RTIC application example here somewhere that we can keep referring to?

\missingfigure{Draw the data flow in RTIC Scope: DWT to ITM to TPIU to cargo-rtic-scope and the itm crate, to replay file and frontends.}

*** ~cortex-m-rtic-trace~ and its application
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace
:END:
~cortex-m-rtic-trace~ is an auxilliary target-side crate that configures all relevant Cortex-M peripherals --- namely the [[acrfull:DCB]][fn:: A component of the [[acrfull:SCB]] peripheral.], [[ACRshort:TPIU]], [[ACRshort:DWT]], and [[ACRshort:ITM]] -- for tracing.
The crate exposes two functions:
- ~cortex_m_rtic_trace::configure~ :: a regular Rust function for configuration of the peripherals mentioned above; and
- ~cortex_m_rtic_trace::trace~ :: a Rust macro with with to trace software tasks.
Henceforth, within this section, these two functions will be referred to as ~configure~ and ~trace~, respectively.

This section is divided into two parts: [[cref:impl:rtic-trace:peripheral-config]], which covers the application of ~configure~; and [[cref:impl:rtic-trace:trace-macro]], which covers the application of the ~trace~ macro.

It is important to point out that ~cortex-m-rtic-trace~ is a crutch which incurs unecessary overhead for the end-user.
On the RTIC Scope roadmap is thus the eventual deprecation of this crate. See [[cref:fut:rm-rtic-trace]] for more on this topic.

**** Peripheral configuration
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:peripheral-config
:END:
After applying device-specific configurations for trace generation, and querying the frequency of the [[ACRshort:TPIU]] reference clock, ~configure~ is applied as shown in [[cref:lst:rtic-trace:configure]].
#+NAME: lst:rtic-trace:configure
#+CAPTION: Example application of ~cortex_m_rtic_trace::configure~.
#+begin_src rust
  #[init]
  fn init(mut ctx: init::Context) -> (SharedResources, LocalResources, init::Monotonics()) {
      // device-specific configurations for trace stream generation...

      let freq = {
          // device-specific query for the TPIU reference clock
          // frequency...
      };

      use cortex_m_rtic_trace::{
          self, GlobalTimestampOptions, LocalTimestampOptions, TimestampClkSrc,
          TraceConfiguration, TraceProtocol,
      };

      // configure device-common tracing
      cortex_m_rtic_trace::configure(
          &mut ctx.core.DCB,
          &mut ctx.core.TPIU,
          &mut ctx.core.DWT,
          &mut ctx.core.ITM,
          1, // task enter DWT comparator ID
          2, // task exit DWT comparator ID
          &TraceConfiguration {
              delta_timestamps: LocalTimestampOptions::Enabled,
              absolute_timestamps: GlobalTimestampOptions::Disabled,
              timestamp_clk_src: TimestampClkSrc::AsyncTPIU,
              tpiu_freq: freq, // Hz
              tpiu_baud: 9600, // B/s
              protocol: TraceProtocol::AsyncSWONRZ,
          },
      )
      .unwrap();

      // ...
  }
#+end_src

~configure~ in [[cref:lst:rtic-trace:configure]] does a number of things in the following order:
1. <<rtic-trace:conf-protocol>> ensures that the target's [[ACRshort:TPIU]] peripheral supports the requested ~protocol~ by reading the [[acrfull:TPIU_TYPE]] [[parencite:&arm-rm C1.10.6]];
2. ensures that the user did not request an invalid [[ACRshort:TPIU]] configuration (i.e. =tpiu_freq: 0= or =tpiu_baud: 0=);
3. <<rtic-trace:conf-exception-trace>> ensures that the target's [[ACRshort:DWT]] peripheral supports exception tracing by reading the /NOTRCPKT/ bit in [[acrfull:DWT_CTRL]] [[parencite:&arm-rm C1.8.7]];
4. <<rtic-trace:nofail-conf>> configures the [[ACRshort:DCB]], [[ACRshort:TPIU]], and [[ACRshort:DWT]] peripherals (partially):
   1. sets the /TRCENA/ bit in the [[acrfull:DCB_DEMCR]], a "global enable for all [[ACRshort:DWT]] and [[ACRshort:ITM]] features";
   2. calculates and writes a prescaler to the /SWOSCALER/ bitrange in the [[acrfull:TPIU_ACPR]] such that the [[ACRshort:TPIU]] communicates with a requested baud rate.
      The prescaler is calculated via [[cref:eq:prescaler]] as derived from [[textcite:&arm-rm C1.10.4]].[fn:: This configuration implementation is faulty. See [[cref:fut:swoscaler]].]
      #+NAME: eq:prescaler
      \begin{equation}
      \frac{\texttt{tpiu\textunderscore freq}}{\texttt{tpiu\textunderscore baud}} - 1
      \end{equation}
   3. drops any [[acrfull:ETM]] packets that the [[ACRshort:TPIU]] receives because the utilization of these packets are outside the scope of this thesis; and
   4. sets the /EXCTRCENA/ bit in [[acrshort:DWT_CTRL]] which enables the generation of exception traces in the [[ACRshort:DWT]] [[parencite:&arm-rm C1.8.7]].
5. <<rtic-trace:itm>> Applies [[ACRshort:ITM]]-related options given to ~configure~ by writing to the [[acrfull:ITM_TCR]] while also checking for target support for the requested configuration [[parencite:&arm-rm C1.7.6]]:
   1. sets the /ITMENA/, /TXENA/, /SWOENA/, and /TSENA/ bits which enables the [[ACRshort:ITM]], forwards trace packets from the [[ACRshort:DWT]] to the [[ACRshort:ITM]], "enables asynchronous clocking of the timestamp counter", and enables the generation of local timestamps, respectively;
   2. writes 0 to the /TraceBusID/ field because RTIC Scope does not support multi-source tracing within the scope of this thesis[fn:: Writing 0 to this field is potentially invalid. See [[cref:fut:TraceBusID]].]
   3. writes 0 to the /TSPrescale/ field, disabling prescaling for local timestamps; and
   4. writes 0 to the /GTSFREQ/ field, disabling global timestamps.[fn:: Global timestamps are an optional feature, and is not supported by all Cortex-M targets.]
6. <<rtic-trace:dwt>> Configures [[ACRshort:DWT]] comparators for software task tracing:
   1. first, resolves the target addresses of two =u32= /watch variables/ which live in [[gls:elf:data]];
   2. dereferences two [[ACRshort:DWT]] comparators as specified by the 5th and 6th arguments to ~configure~ in [[cref:lst:rtic-trace:configure]];[fn:: The [[ACRshort:API]] for specifying these comparators can be greatly improved. See [[cref:fut:dwtcomps]].]
   3. configures the first comparator to signal a match (and generate an associated trace stream packet) when data is written to the first watch variable:
      1. writes to seven fields in the [[acrfull:DWT_FUNCTIONn]][fn:dwt-n] [[parencite:&arm-rm C1.8.17]], where $n$ is the offset of the comparator (in the context of [[cref:lst:rtic-trace:configure]], $1$):
         0b1101 to /FUNCTION/, configuring the comparator to match on address access;
         0 to /EMITRANGE/, disabling trace address packet generation;[fn:: We are not interested in the address that contains the watch variable.]
         0 to /DATAVMATCH/, to disable data value comparison;
         0 to /CYCMATCH/, to disable cycle counter comparison;
         and 0 to /DATAVSIZE/, /DATAVADDR0/, and /DATAVADDR1/ because these fields are [[acrfull:SBZ]] [[parencite:&arm-rm Glossary-855]] in address comparison context.
      2. writes the first watch variable address to [[acrfull:DWT_COMPn]][fn:dwt-n] (with $n = 1$), in order for the comparator to match on that address access; and
      3. writes 0 to [[acrfull:DWT_MASKn]][fn:dwt-n] ($n=1$), such that the comparator does not match on a range of addresses.
   4. Lastly, the second comparator is configured in the same manner as the first, but with the second watch variable address in mind and $n=2$.

If any step in [[crefrange:rtic-trace:conf-protocol,rtic-trace:conf-exception-trace]] fails ~configure~ prematurely returns an ~Err(_)~ that signals what went wrong, and no peripheral configuration will have been applied: the target will be in the same state as before ~configure~ was called.

Several fields in [[ACRshort:ITM_TCR]] are potentially [[acrfull:RAZ-WI]], [[acrfull:RAZ]], or [[acrfull:RAO]] [[parencite:&arm-rm Glossary-854]] in order to signal hardware support.
This requires the field to be read after a write to ensure that a configuration was applied.
During the steps in [[cref:rtic-trace:itm]], if any read-back values does not match what was written, ~configure~ prematurely returns an ~Err(_)~ signalling what configuration component was not supported by the target and what components have been successfully applied, notifying the end-user that a partial configuration has now been applied.
It is up to the end-user to reset the target to the state before ~configure~ was called.
For a discussion on this implementation detail, see [[textcite:&issue:cortex-m:382]].

The steps in \cref{rtic-trace:nofail-conf,rtic-trace:dwt} and cannot fail.

Of certain note are the steps in [[cref:rtic-trace:dwt]] because of the dependency of variables in ~.data~ to trace software tasks, and how the watch variables in this section are aligned in memory.
The [[ACRshort:DWT]] comparators are configured to match on writes to singular addresses which are represented as =u32= variables.
However, due to performance reasons, the watch variables are represented as =u8= variables: only a single byte will be written to these 32-bit addresses during run-time tracing (see [[cref:impl:rtic-trace:trace-macro]]).
Further, because of time constrains no experimentation has been done with a non-zero mask: this requires the watch variables to be aligned to 32-bits. For more on the topic of performance, see [[cref:disc:perf]] and [[cref:fut:opt-dwt-units]].
\todo{improve this paragraph.}

**** Tracing software tasks with ~trace~
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:trace-macro
:END:
~trace~ is an optional macro that is only required if software task tracing is wanted.
It's application is trivial, but requires that ~config~ executed successfully.
To trace a software task, consider [[cref:lst:rtic-trace:trace]] which defines two tasks: =task1= and =task2=.
Of the two tasks, =task2= is traced by simply decorating it with =#[trace]=, the invocation of the =trace= macro.
#+NAME: lst:rtic-trace:trace
#+CAPTION: Application example of the ~trace~ macro. ~task2~ is traced; ~task1~ is not.
#+begin_src rust
  // ...

  use cortex_m_rtic_trace::{self, trace};

  #[task]
  fn task1(_: task1::Context) {}

  #[task]
  #[trace]
  fn task2(_: task2::Context) {}

  // ...
#+end_src

Consider now [[cref:lst:rtic-trace:trace-expanded]], which is the result of expanding the macros applied in [[cref:lst:rtic-trace:trace]] via ~cargo-expand~ [[parencite:&cargo-expand]].
#+NAME: lst:rtic-trace:trace-expanded
#+CAPTION: Application example of the ~trace~ macro after macro expansion via ~cargo-expand~. Unrelated expansions omitted.
#+begin_src rust
  // ...
  use cortex_m_rtic_trace::{self, trace};
  // ...
  #[allow(non_snake_case)]
  fn task1(_: task1::Context) {
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
  }
  #[allow(non_snake_case)]
  fn task2(_: task2::Context) {
      ::cortex_m_rtic_trace::__write_enter_id(0);
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
      ::cortex_m_rtic_trace::__write_exit_id(0);
  }
  // ...
#+end_src

*** Recording a trace
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope
:END:
~cargo-rtic-scope~ is a host-side daemon that fulfills [[crefrange:req:input,req:protocol]] and [[crefrange:req:record,req:cargo]].
It is run like a ~cargo~ subcommand, as seen in [[cref:lst:cargo-rtic-scope:summary]], where ~<verb>~ is either ~trace~ or ~replay~.
As the verbs imply, ~trace~ is used to trace the execution of an RTIC application on the target and ~replay~ is used to replay a trace for post-mortem analysis.
#+NAME: lst:cargo-rtic-scope:summary
#+CAPTION: Summary of ~cargo-rtic-scope~ invocation.
#+begin_src shell
  $ cargo rtic-scope [options...] <verb> [options...]
#+end_src

This section covers the options and implementation of the ~trace~ verb.

**** Section overview
The implementation responsible for recording and presenting a trace to the end-user is covered in 10 parts.
These parts are enumerated below.

1. Building the RTIC application, [[cref:impl:cargo-rtic-scope:building-rtic-app]].
2. Reading options from the cargo maniest, [[cref:impl:cargo-rtic-scope:read-manifest]].
3. Creating a trace file, [[cref:impl:cargo-rtic-scope:create-trace-file]].
4. Generating metadata maps, [[cref:impl:cargo-rtic-scope:generating-metadata-maps]].
5. Spawning frontends, [[cref:impl:cargo-rtic-scope:spawning-frontends]].
6. Reading the trace from the target, [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]].
7. Flashing the target, [[cref:impl:cargo-rtic-scope:flash-target]].
8. Flushing trace metadata to file, [[cref:impl:cargo-rtic-scope:flush-metadata]].
9. Resetting the target, [[cref:impl:cargo-rtic-scope:reset-target]].
10. Tracing the target, [[cref:impl:cargo-rtic-scope:trace-target]].

**** Building the RTIC application
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:building-rtic-app
:END:
The first step is to build the RTIC application the end-user wants to trace.
This is done as a preparatory stage for [[cref:impl:cargo-rtic-scope:generating-metadata-maps]], [[cref:impl:cargo-rtic-scope:create-trace-file]] and [[cref:impl:cargo-rtic-scope:flash-target]];
and logically, if the application cannot be built, it cannot be traced.
An additional side-effect of building the RTIC application is the possibility of executing ~cargo rtic-scope trace~ like one would execute ~cargo run~.

The application is built via [[cref:lst:cargo-rtic-scope:build]], where ~OPTIONS~ are optional additional flags to forward to ~cargo~ from the invocation of ~cargo rtic-scope trace~.
#+NAME: lst:cargo-rtic-scope:build
#+CAPTION: The build process of RTIC Scope. ~OPTIONS~ is a set of additional flags potentially forwarded by ~cargo-rtic-scope~.
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi [OPTIONS...]
#+end_src
For example, if the current crate would yield multiple binaries on build, ~cargo rtic-scope trace~ must know the singlar binary which the end-user wants to trace.
Specifying this flag is done in the same way as for ~cargo build~: via ~--bin~.
[[cref:lst:cargo-rtic-scope:build-bin]] contains an example use of this option, which would yield the ~cargo build~ invocation in [[cref:lst:cargo-rtic-scope:build-bin-forwarded]].
#+NAME: lst:cargo-rtic-scope:build-bin
#+CAPTION: Invocation of ~cargo rtic-scope trace~ with the optional ~--bin~ option which is forwarded to the underlying ~cargo build~ invocation, where ~OPTIONS~ is a set of additional flags and/or options potentially set by the end-user; not all of which are necessarily forwarded.
#+begin_src shell
  $ cargo rtic-scope trace --bin my-rtic-application [OPTIONS...]
#+end_src
#+NAME: lst:cargo-rtic-scope:build-bin-forwarded
#+CAPTION: The underlying ~cargo build~ invocation as a result of executing [[cref:lst:cargo-rtic-scope:build-bin]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application [OPTIONS...]
#+end_src

Below are a description of the flags and options the end-user can specify during the invocation of ~cargo rtic-scope trace~ (in the same manner as ~cargo build~) that are forwarded to the underlying ~cargo build~ invocation in [[cref:lst:cargo-rtic-scope:build]].
- ~--bin <binary>~ :: Used to specify which singlar binary to build.
- ~--example <example>~ :: Used to build a singular example binary instead of a non-example binary.
- ~--package <package>~ :: Used to build a crate instead of a singlar binary inside of a crate.
  This crate should yield a single binary.
- ~--release~ :: Used to build the binary in release mode instead of debug mode. Optimizations are applied during build with this flag.
- ~--target <target-triple>~ :: Used to specify the target platform for which the binary should be built for. This option can be used to override the default target triple, or the one specified via the ~/.cargo/config{,toml}~ files.
- ~--manifest-path <path>~ :: Used to override the default path to the ~cargo~ manifes, ~Cargo.toml~.
- ~--no-default-features~ :: Used to disable all default features of the crate that contains the singular binary.
- ~--all-features~ :: Used to enable all features of the crate that contains the singular binary.
- ~--features <feat1>[,feat2[,feat3[...]]]~ :: Used to specify the set of features to enable of the crate that contains the singular binary.

The above flags and options were deemed as the most common flags an end-user would want to specify when building the RTIC application.
If the user wants to specify an option or flag that is not among the above set the sentinel ~--~ can be used.
For example, if the end-user invokes [[cref:lst:cargo-rtic-scope:sentinel]], ~cargo-rtic-scope~ invokes [[cref:lst:cargo-rtic-scope:sentinel-forwarded]].
#+NAME: lst:cargo-rtic-scope:sentinel
#+CAPTION: Example ~cargo rtic-scope trace~ incovation with an arbitrary ~cargo build~ argument.
#+begin_src shell
    $ cargo rtic-scope trace --bin my-rtic-application [OPTIONS...] -- --some-cargo-build-flag
#+end_src
#+NAME: lst:cargo-rtic-scope:sentinel-forwarded
#+CAPTION: Resulting ~cargo build~ incovation on [[cref:lst:cargo-rtic-scope:sentinel]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application [OPTIONS...] --some-cargo-build-flag
#+end_src
This approach ensures that the end-user can always build the RTIC application with any set of valid ~cargo build~ flags and options.

The effect of building the binary with =--message-format=json-diagnostic-rendered-ansi= is that the otherwise human-readable output of ~cargo build~ is instead in [[gls:JSON]], a machine-readable format.
This JSON output describes all artifacts that are built, including the singular binary that the end-user wants to trace, for which ~cargo build~ tells us the path to the built binary used to flash the target in [[cref:impl:cargo-rtic-scope:flash-target]];
the path to the root of the crate that this binary lives, used in [[cref:impl:cargo-rtic-scope:create-trace-file]];
and the path to the source file of this binary, used in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]].

The JSON is not parsed directly, but via ~cargo_metadata~ [[parencite:&cargo-metadata]].

**** Reading options from the ~cargo~ manifest
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:read-manifest
:END:
The operation of ~cargo rtic-scope trace~ requires some information about the RTIC application from the end-user.
These are specified in the metadata block of the crate's manifest, ~Cargo.toml~.
One may for example write the information in [[cref:lst:cargo-rtic-scope:manifest-metadata-example]].
#+NAME: lst:cargo-rtic-scope:manifest-metadata-example
#+CAPTION: Example of required user-supplied information in crate manifest, ~Cargo.toml~.
#+begin_src text
  $ cat Cargo.toml
  [...]

  [package.metadata.rtic-scope]
  pac_name = "atsamd51n"
  pac_features = []
  pac_version = "0.11"
  interrupt_path = "atsamd51n::Interrupt"
  tpiu_freq = 12000000
  tpiu_baud = 38400
  dwt_enter_id = 1
  dwt_exit_id = 2
  lts_prescaler = 1
  expect_malformed = false

  [...]
#+end_src
Of these fields the below are utilized in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]]:
- ~pac_name~,
- ~pac_features~,
- ~pac_version~,
- ~interrupt_path~,
- ~dwt_enter_id~,
- ~dwt_exit_id~;
and the below fields are utilized in  [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]] and  [[cref:impl:itm]]:
- ~tpiu_freq~,
- ~tpiu_baud~,
- ~lts_prescaler~.
The last flag, ~expect_malformed~ is a debug option utilized in [[cref:impl:cargo-rtic-scope:trace-target]].
For a description of each field, see the respective sections.

The fields of information in [[cref:lst:cargo-rtic-scope:manifest-metadata-example]] are read from ~Cargo.toml~ by help of ~cargo_metadata~ [[parencite:&cargo-metadata]] and ~serde_json~ [[parencite:&serde-json]].

# TODO reformat the below
The last piece of the puzzle is from where to source user-supplied information.
Four fields of information is required to complete the second step above: the PAC name, version, features (if any), and the path to the =PAC::Interrupt= enum.
There are two methods the user can supply this information: via commandline options, see [[lst:recovery-user-info-cmdopt]];
or by entering the fields into the ~rtic-scope~ metadata block of the application's ~Cargo.toml~, see [[lst:recovery-user-info-toml]].
PAC information in ~Cargo.toml~ is persisent, and simplifies an iterative workflow.

#+NAME: lst:recovery-user-info-cmdopt
#+CAPTION: Supplying information to RTIC Scope for recovery purposes via command line options.
#+begin_src shell
  $ cargo rtic-scope trace --pac-name stm32f4 --pac-version 0.13 --pac-features stm32f401 --pac-features some-other-feature --interrupt-path "stm32f4::stm32f401::Interrupt"
#+end_src

#+NAME: lst:recovery-user-info-toml
#+CAPTION: Supplying information to RTIC Scope for recovery purposes via ~Cargo.toml~ metadata.
#+begin_src toml
# ...

[package.metadata.rtic-scope]
pac_name = "stm32f4"
pac_features = ["stm32f401", "some-other-feature"]
pac_version = "0.13"
interrupt_path = "stm32f4::stm32f401::Interrupt"

# ...
#+end_src

**** Creating a trace file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:create-trace-file
:END:
To enable port-mortem analysis of a traced RTIC application the recorded trace must be saved to disk.
The build step (see [[cref:impl:cargo-rtic-scope:building-rtic-app]]) yields the crate root of the traced application.
A natural directory in which to save trace files is then under ~/target/~ which contains all build artifacts of the crate.
For purposes of separation trace files are saved under the ~rtic-traces~ sub-directory; the full path to this directory is then ~/target/rtic-traces/~.
While this directory is meant for ephemeral artifacts (of which recorded traces may not belong) it was the simplest approach to associate traces to a particular crate (including its state; see below) while also not writing files to a wholly unexpected directory (e.g. the crate root directory).

Of note is that ~/target/~ is removed if ~cargo clean~ is executed.
It is thus up to the RTIC Scope end-user to ensure that traces of interests are saved to a persistent location.
For this purpose the optional ~--trace-dir <dir>~ option overrides the output directory of the trace files.

The trace filename contains three sections of information:
- the name of the RTIC application :: to help with the seperation of a crate that potentially contains more than one binary;
- the git revision of the local repository :: to associate the trace with the source code of the traced RTIC application; and
- a second-accurate timestamp :: to associate the trace with MCU-external events (e.g. conditions of the environment in which the application is traced).

After some tracing and development during January 13th and 14th, 2022, the trace directory could for example contain the files in [[cref:lst:cargo-rtic-scope:trace-example-files]].
#+NAME: lst:cargo-rtic-scope:trace-example-files
#+CAPTION: Example of trace filenames after two traces. ~blinky~ is the name of the RTIC application binary; ~g124b3c5~ the git revision; and the remainder (sans ~.trace~) is the timestamp of the trace. The second trace file was recoded from an RTIC application with uncommitted changes, hence the ~-dirty~ suffix to the git revision.
#+begin_src text
  $ ls -ogh target/rtic-traces
  total 8.0K
  -rw-r--r-- 1 1.5K Jan 13 16:54 blinky-g124b3c5-2022-01-13T16:54:00.trace
  -rw-r--r-- 1 1.3K Jan 14 18:38 blinky-g124b3c5-dirty-2022-01-14T18:37:57.trace
#+end_src

In case two ~cargo rtic-scope trace~ instances are executed within the span of one second without any changes to the git repository the same trace filename will be generated twice; this will be caught by the second instance which will exit with an error: ~cargo-rtic-scope~ cannot overwrite trace files.
Trace files can however be explicitly deleted:
if the user wants to record a trace and remove all previously recoded traces in the trace directory ~--clear-traces~ can be specified.
This flag only deletes files with the ~.trace~ file extension.

**** Generating metadata maps
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:generating-metadata-maps
:END:
# Introduction: we must translate raw ITM data to RTIC run-time information.
As covered in [[cref:theory:itm-proto]], the [[ACRshort:ITM]] packet protocol is used to trace hardware and software tasks.
This protocol is not designed with RTIC in mind:
instead of information that can be directly associated to an RTIC tasks the protocol tells us the number of the [[ACRshort:DWT]] comparator that signaled a write to a watch address along with the data written, used to signal a software task enter or exit;
and the IRQ number of the interrupt handler that entered, exited or was returned to, used to signal a hardware task enter or exit.
These pieces of information must be associated back to the RTIC tasks responsible for their emission in a preparatory /recovery step/.
This section covers this step which is divided into two parts:
1. the generation of the =recovery::HardwareMap=, [[cref:impl:hardware-map]]; and
2. the generation of the =recovery::SoftwareMap=, [[cref:impl:software-map]].
Together these two lookup maps constitute the full =recovery::TraceLookupMaps= which is used by =recovery::TraceMetadata= in order to fulfill Requirement [[req:rtic]].

***** Generating the ~recovery::HardwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:hardware-map
:END:
# Overview: what to we need?
In order to generate a =recovery::HardwareMap= the RTIC application declaration must be parsed.
This is already done when the RTIC application is built in [[cref:impl:cargo-rtic-scope:building-rtic-app]] when the =rtic::app= macro is expanded via =rtic_syntax::parse{,2}= [[parencite:&rtic]].
This expansion operation yields an =rtic_syntax::App= [[parencite:&rtic-syntax]] used internally to verify the application declaration and yield the expanded code.
This structure contains all the information ~cargo rtic-scope trace~ requires (see below) but is not emitted during the building step.
This requires the application declaration to be parsed an additional time which requires knowledge about the location of the source code file.
Fortunately, this knowledge is acquired in the build step.

# We must the source for the ASTs
In order to generate a =rtic_syntax::App= for recovery purposes =rtic_syntax::parse2= must be called directly with the arguments of =#[rtic::app(..)]= and with the input to the macro.
For example, in [[cref:lst:recovery-example]], =device = stm32f4::stm32f401= is the macro arguments, and =mod app { ... }= is the macro input.
Note the preamble on lines 1--3.
These must be skipped in order to parse correctly.
#+CAPTION: Example RTIC application declaration for execution on the STMicroelectronics STM32 NUCLEO-F401RE.
#+NAME: lst:recovery-example
#+begin_src rust
  #![no_main]
  #![no_std]

  #[rtic::app(device = stm32f4::stm32f401)] // tokens are skipped until this line is found
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[task(binds = SysTick)]
      fn task1(_: task1::Context) {
          // ...
      }

      #[task(binds = EXTI1)]
      fn task2(_: task2::Context) {
          // ...
      }
  } // this must be the last line of the file
#+end_src
# TODO document limitations of the parsing approach: no external tasks, no content after the macro

In order to isolate the =#[rtic::app(...)] mod app { ... }= section in [[cref:lst:recovery-example]] the ~std::String~ that represents the content of the source file must be converted to an [[acrfull:AST]];
or more specifically, a =proc_macro2::TokenStream2= [[parencite:&proc-macro2]].
This is done by help of the ~syn~ crate [[parencite:&syn]].

With a =TokenStream2= structure in hand [[glspl:token][tokens]] are skipped until the =proc_macro2::TokenTree::Group(_)= that contains =#[rtic::app(...)]= is found ([[cref:lst:recovery-example]], line 4).
The remainder of the source file is then assumed to be the =mod app { ... }= input to the =rtic::app= macro.

This places a few restrictions[fn:: The keywords *MUST* and *MUST NOT* shall be interpreted as described in [[textcite:&rfc2119]].] on how the RTIC application can be declared to be properly parsed:
1. tasks *MUST NOT* be externally declared;
2. the =rtic::app= macro *MUST* be called via =#[rtic::app]= (e.g. [[cref:lst:invalid-recovery-example]] will fail to parse); and
3. the =mod app { ... }= [[gls:token]] group terminator *MUST* be the last line of the source file ([[cref:lst:recovery-example]], line 27).
More restrictions that have yet to be discovered may apply.
#+NAME: lst:invalid-recovery-example
#+CAPTION: Valid RTIC application declaration that cannot be parsed by ~cargo rtic-scope trace~.
#+begin_src rust
  // ...
  use rtic::app;

  #[app(device = stm32f4::stm32f401)] // will not parse: #[rtic::app] must be used
  mod app {
      // ...
  }
#+end_src

# known and unknown maps
# TODO pluralize HardwareTask
At this point we have the necessary =rtic_syntax::App= structure to continue: =App::hardware_tasks= is a collection of =rtic_syntax::HardwareTask= that lists what interrupt handler each hardware task is bound to via the =binds= argument in =#[task(binds = ...)]=.
After parsing [[cref:lst:recovery-example]], =hardware_tasks= contains [fn:: Abstracted for brevity.]
#+begin_export latex
$$
\langle \text{\texttt{app::task1} binds to \texttt{SysTick}} \rangle,\quad\langle \text{\texttt{app::task2} binds to \texttt{EXTI1}} \rangle\text{.}
$$
#+end_export
Of these, the =app::task1= bind is considered /known/, and the =app::task2= bind is considered /unknown/.
A known bind is one that no more recovery work must be applied on.
This follows from [[cref:tbl:irqns]] in [[cref:theory:itm-proto]] which enumerates all numbers that can be in the packet's IRQ field:
All
#+begin_export latex
$$
\text{IRQn} < 16
$$
#+end_export
are common to all ARMv7-M targets, the name of which can be directly mapped to the RTIC task that binds the IRQ name.
All
#+begin_export latex
$$
\text{IRQn} \geq 16
$$
#+end_export
on the other hand, are not common to all ARMv7-M, and are thus platform-specific because the labels (specified via =#[task(binds = ...)]=) are unknown.
Additional recovery must be done to find these labels.

# PAC::Interrupt and known/unknown partitioning; Rust reflection woes
For any RTIC application, the labels are available in the =PAC::Interrupt= enum. For [[cref:lst:recovery-example]], =PAC= is =stm32::stm32f401=.
See [[cref:background:PAC]] for an example of such an enum.
By finding the label used in =#[task(bind = ...)]= in =PAC::Interrupt= we find what enum constructor to use.
With the enum in hand, we construct it and get the IRQ number offset $N$ via [[cref:lst:pac:extirq]].
#+NAME: lst:pac:extirq
#+CAPTION: Finding $N$ in [[cref:tbl:irqns]] for an external interrupt via the [[ACRshort:PAC]].
#+begin_src rust
  let label = PAC::Interrupt::EXTI1;
  assert_eq!(label.number(), 7);
#+end_src
To get the IRQ number of this unknown bind we simly sum it with $16$, as documented by [[cref:tbl:irqns]], via [[cref:lst:pac:irqsum]].
#+NAME: lst:pac:irqsum
#+CAPTION: Finding the IRQ number of an external interrupt by summing the offset documented by [[cref:tbl:irqns]].
#+begin_src rust
  let irq_nr = label.number() + 16;
  assert_eq!(irq_nr, 23);
#+end_src
This must be done for all unknown binds.

The above process is unfortunately non-trivial: Rust does not have dynamic programming features and an ideal evaluation function such as [[cref:lst:pac:ideal-pseudo]] is not realizeable.
#+NAME: lst:pac:ideal-pseudo
#+CAPTION: Non-realizeable pseudo code to dynamically resolve the IRQ number of an unknown bind via the [[ACRshort:PAC]]. ~quote~ is from [[textcite:&quote]].
#+begin_src rust
  use quote::quote;
  fn resolve_irq_nr(label: &str) -> u16 {
      quote!(PAC::Interrupt::$label).eval().number() + 16;
  }
#+end_src

# libadhoc
Enter =recovery::resolve_int_nrs=: given a list of labels, the function
1. extracts an embedded file tree constituting a skeleton crate to the RTIC application's ~target/cargo-rtic-trace-libadhoc~, by help of [[textcite:&includedir]];
2. writes the user-specified [[acrfull:PAC]] dependency into this crate's ~Cargo.toml~[fn:: By use of the ~pac_name~, ~pac_version~, ~pac_features~, and ~interrupt_path~ acquired from [[cref:impl:cargo-rtic-scope:read-manifest]].];
3. for each label: writes a non-mangled function with the same name as the label that returns the associated IRQ number offset, $N$ (for [[cref:lst:recovery-example]] the generated recovery code can be seen in [[cref:lst:resolve_int_nrs-example]]), to ~lib.rs~;
   #+NAME: lst:resolve_int_nrs-example
   #+CAPTION: Generated IRQ number recovery functions for [[cref:lst:recovery-example]] with ~interrupt_path = "st32::stm32f401::Interrupt"~ from the [[ACRshort:RTIC]] application's ~Cargo.toml~.
   #+begin_src rust
     use stm32::st32f401::Interrupt;

     #[no_mangle]
     pub extern fn EXTI1() -> u16 {
         Interrupt::EXTI0.number()
     }
   #+end_src
4. builds the crate as a [[gls:cdylib]];
5. loads the library into memory;
6. for each label: calls the associated function in the library to get the offset $N$ and sums it with 16; and
7. collects the results.
This collection then merges with the collection of known maps.

***** Generating the ~recovery::SoftwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:software-map
:END:
The work to generate a =recovery::SoftwareMap= is similar to that of a =recovery::HardwareMap= in the sense that the RTIC application declaration must be parsed again (for a third, but last time).
This parsing pass is done via =SoftWareMap::parse_ast= instead of =rtic_syntax::parse2=.
As the function name implies the [[ACRshort:AST]] is parsed by skipping [[glspl:token][tokens]] until the =TokenTree::Group(_)= describing =#[trace]= is found.
When this [[gls:token]] is found the software task the macro is used on is associated with the current value of an internal counter for software task IDs.
This counter is modified in the same manner as the internal counter when =cortex_m_rtic_trace::trace= expands.

To complete the =SoftwareMap= the IDs of the [[ACRshort:DWT]] comparators and the interrupts which handle the dispatch of the application's software tasks must be recorded.
The former are acquired from  [[cref:impl:cargo-rtic-scope:read-manifest]] via the ~dwt_enter_id~ and ~dwt_exit_id~ fields.
The latter are acquired via =rtic_syntax::ast::AppArgs::extern_interrupts=.

For the example in [[cref:lst:rtic-scope:trace-software-task]], =SoftwareMap= would contain[fn:: Abstracted for brevity.] the information denoting =EXTI2= as the software task dispatcher and
#+begin_export latex
$$
\langle 0 \equiv \text{\texttt{app::task1}}\rangle,\quad\langle 1 \equiv \text{\texttt{app::task2}} \rangle\text{.}
$$
#+end_export
#+NAME: lst:rtic-scope:trace-software-task
#+CAPTION: RTIC application declaration with two traced software tasks: ~app::task1~ and ~app::task2~. ~EXTI2~ is declared as the software task dispatcher.
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXTI2])]
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[trace] // task ID = 0
      #[task]
      fn task1(_: task1::Context) {
          // ...
      }

      #[trace] // task ID = 1
      #[task]
      fn task2(_: task2::Context) {
          // ...
      }
  }
#+end_src

The restrictions enumerated in [[cref:impl:hardware-map]] also apply when recovering information for traced software tasks.

The =trace= macro can also be applied on regular functions, effectively allowing the end-user to trace sections of both software and hardware tasks; see [[cref:impl:nested-tracing]] for an example.
Severe limitations apply when tracing functions inside tasks and are thus not useful in practise.
See [[cref:disc:nested-tracing-restrictions]] for more on this topic.
#+NAME: impl:nested-tracing
#+CAPTION: Tracing a function inside of a traced software example.
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXIT2])]
  mod app {
      // ...

      #[trace]
      #[task]
      fn task1(_: task1::Context) {
          // ...

          #[trace]
          fn nested() {
              // ...
          }
      }
  }
#+end_src
**** Spawning frontends
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:spawning-frontends
:END:
# TODO dont forget to cover the possibility of spawning multiple frontends
**** Reading the trace stream from the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reading-the-trace-stream
:END:
# TODO cover all sources here.
**** Flashing the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flash-target
:END:
**** Flushing trace metadata to file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flush-metadata
:END:
**** Resetting the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reset-target
:END:
**** Tracing the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:trace-target
:END:

*** Decoding the ITM packet stream via ~itm~
:PROPERTIES:
:CUSTOM_ID: impl:itm
:END:
# TODO the decoding part, draw/borrow some figures from standard
# TODO iter.rs, specifically Timestamps, timestamp formula, GTS logic, etc.
# TODO everything is unit tested.

*** Associating trace packets with RTIC task events
# TODO build_event_chunk

*** Forwarding resolved trace stream to sinks via ~rtic-scope-api~
:PROPERTIES:
:CUSTOM_ID: impl:api
:END:

*** Echoing the trace stream with ~rtic-scope-frontend-dummy~
:PROPERTIES:
:CUSTOM_ID: impl:rtic-scope-frontend-dummy
:END:

*** Replaying a trace

** Results
*** Using RTIC Scope
From an end-user perspective RTIC Scope offers a "batteries-included" toolset that enables great insight into a target RTIC applications,
provided that a small set of limitations are adhered to and specific metadata is added to the application crate in question.
To install RTIC Scope, an end-user executes
#+begin_src shell
  $ cargo install cargo-rtic-scope
  $ cargo install rtic-scope-frontend-dummy
#+end_src
and adds the following metadata to their RTIC application's ~Cargo.toml~:
#+begin_src toml
  [package.metadata.rtic-scope]
  # necessary information for RTIC metadata recovery
  pac_name = "stm32f4"
  pac_features = ["stm32f401"]
  pac_version = "0.13"
  interrupt_path = "stm32f4::stm32f401::Interrupt"

  # ITM/DWT/TPIU parameters
  tpiu_freq = 16000000
  tpiu_baud = 115200
  dwt_enter_id = 1
  dwt_exit_id = 2
  lts_prescaler = 1

  # Whether it is expected that the target generates packets that do not adhere to the ITM standard.
  # For debugging purposes.
  expect_malformed = true
#+end_src

# TODO document cortex-m-rtic-trace usage

** Discussion
:PROPERTIES:
:CUSTOM_ID: discussion
:END:
*** What project does ~itm~ belong to?
:PROPERTIES:
:CUSTOM_ID: disc:itm-embedded-wg
:END:
# TODO discuss on where the final itm actually belongs. Link to the RFC discussion.
*** Tracing overhead with RTIC Scope
:PROPERTIES:
:CUSTOM_ID: disc:perf
:END:
[[parencite:&arm-cortex-learn 24]] states:
#+begin_quote
Except for the power that is consumed by the system trace components,
trace is almost entirely non-invasive. This means that performing trace
generation and collection does not influence the wider system.
#+end_quote

The target-side code of RTIC Scope itself has a negligible performance impact during execution:
- the ITM/DWT/TPIU units need only be configured once in =#[init]= or during some other preparatory stage; and
- when software tasks are traced, a =u8= variable write must be done when entering and exiting the task.

The performance of the host-side =cargo-rtic-scope= and =rtic-scope-frontend-dummy= have not been measured.

# TODO DWT unit consumption, 2x u32-aligned .data usage
# TODO add a listing of the watch variable structs to detail alignment.
*** Restrictions of tracing functions inside tasks
:PROPERTIES:
:CUSTOM_ID: disc:nested-tracing-restrictions
:END:
*** Future work
# Link to all(?) issues

# TODO deprecating cortex-m-rtic-trace: push upstream to RTIC, probe-rs
# TODO cargo-embed functionality, RTICScope.toml
# TODO queries from frontend
# TODO replace serde with protobuf
# TODO HIL testing?
# TODO replace bash scripts with xtask testing
# TODO Cargo warning/errors not propagated when building application
# TODO Cargo-flash hints?

# TODO add a link to the issue tracker, or should we list all issues that are open when v0.3.0 is tagged?
**** Local timestamp prescaler configuration
:PROPERTIES:
:CUSTOM_ID: fut:swoscaler
:END:
# TODO integer division
**** Trace stream ID configuration
:PROPERTIES:
:CUSTOM_ID: fut:TraceBusID
:END:
# TODO 0 may not be a valid value, and tracebusid should be set before ITMENA
**** [[ACRshort:DWT]] comparator configuration
:PROPERTIES:
:CUSTOM_ID: fut:dwtcomps
:END:
# TODO move positional arguments to the struct instead. ensure that the two comparators are not the same one.
**** Optimizing [[ACRshort:DWT]] comparator utilization
:PROPERTIES:
:CUSTOM_ID: fut:opt-dwt-units
:END:
It would then be logical to store both =u8= variables on the same 32-bit address base: the first at offset 0, the other at offset 1.

# TODO elaborate
**** Deprecating ~cortex-m-rtic-trace~
:PROPERTIES:
:CUSTOM_ID: fut:rm-rtic-trace
:END:
# TODO merging things upstream into probe-rs, RTIC, etc.
# target-side conf can be done by RTIC
**** Supporting other [[ACRshortpl:RTOS]] than [[ACRshort:RTIC]]

** Conclusion
** Glossary & Bibliography                                          :ignore:
[[printglossaries:]]
[[printbibliography:]]
** Appendices                                                       :ignore:
#+begin_export latex
\appendix
\addappheadtotoc
#+end_export
*** TODO Application to a complex control system
:PROPERTIES:
:CUSTOM_ID: control-application
:END:
 # The results of the R7014E-alike course



* Footnotes
[fn:recovery-build] A positive side-effect of this step is that the RTIC Scope user does not have to manually call =cargo build= before =cargo rtic-scope trace=.

[fn:2] Additional tasks aside from regulation could for example include handling firmware updates over the air and switching mode of operation on a button press.
[fn:1] The program that executes on the embedded system when initialization has concluded. In some contexts also referred to as the "main loop".

[fn:dwt-running-bit] Alternatively, one bit in the =DataTraceValue= payload can denote whether a task was entered or exited.

[fn:cargo] See https://crates.io/crates/cargo.

[fn:rtic-syntax] See https://crates.io/crates/rtic-syntax.

[fn:decoder] Based upon the existing works of ~itm-tools~[fn:itm-tools].

[fn:memory-lanes] https://github.com/rtic-rs/rfcs/issues/31 discusses the RTIC-abstraction of RTT and similar peripherals to "memory lanes".

[fn:itm-tools] See https://github.com/japaric/itm-tools.

[fn:cli] Command-line interface.

[fn:dwt-n] $n$ emphasized for reasons of readability and typesetting.
