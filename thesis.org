# -*- eval: (org-indent-mode +1) -*-
# -*- eval: (visual-line-mode +1) -*-

#+TITLE: RTIC Scope — Real-Time Tracing Support for the RTIC RTOS Framework
#+AUTHOR: Viktor Vilhelm Sonesten
#+EMAIL: vikson-6@student.ltu.se
#+LANGUAGE: en
#+OPTIONS: ':t toc:nil title:nil todo:nil H:6

#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: thesis
#+LATEX_CLASS_OPTIONS: [a4paper,10pt]
#+latex_header: \usepackage{kpfonts}[maths]
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{inconsolata}
#+latex_header: \usepackage[style=apa,hyperref=true,url=true,backend=biber]{biblatex}
#+latex_header: \addbibresource{./ref.bib}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{newfloat}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{frame=lines,breaklines,breakafter=/.,fontsize=\footnotesize,linenos}
#+LATEX_HEADER: \usepackage[inline]{enumitem}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks=true,urlcolor=blue,linkcolor={red!50!black},citecolor=blue,breaklinks=true}
#+LATEX_HEADER: \usepackage{glossaries-extra}
#+latex_header: \usepackage{microtype}
#+latex_header: \usepackage{tocbibind}
#+latex_header: \usepackage{todonotes}
#+latex_header: \usepackage[capitalize]{cleveref}
#+latex_header: \usepackage{csquotes}
#+latex_header: \usepackage{svg}
#+latex_header: \usepackage{caption}
#+LATEX_HEADER: \makeglossaries

# NOTE auto linebreaks / : - and _ inside \textttBreak. Adapted from <https://tex.stackexchange.com/a/219497>.
#+latex_header: \catcode`_=12 %
#+latex_header: \newcommand{\textttBreak}[1]{%
#+latex_header:   \begingroup
#+latex_header:   \ttfamily
#+latex_header:   \begingroup\lccode`~=`/\lowercase{\endgroup\def~}{/\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`-\lowercase{\endgroup\def~}{-\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`_\lowercase{\endgroup\def~}{_\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`:\lowercase{\endgroup\def~}{:\discretionary{}{}{}}%
#+latex_header:   \catcode`/=\active\catcode`-=\active\catcode`_=\active\catcode`:=\active
#+latex_header:   \scantokens{#1\noexpand}%
#+latex_header:   \endgroup
#+latex_header: }
#+latex_header: \catcode`_=8 %

#+latex_header: \usepackage[htt]{hyphenat}

#+latex_header: \usepackage{tikz}
#+latex_header: \usetikzlibrary{automata, positioning, arrows, shapes, calc}
#+latex_header: \tikzset{
#+latex_header:   block/.style = {draw, rectangle, minimum height=1cm, minimum width=2cm},
#+latex_header:   ->, % make edges directed
#+latex_header:   every text node part/.style={align=center}, % allow multiline node descriptions
#+latex_header: }

#+latex_header: \loadglsentries{glossary}
# TODO fix long-em on first use only?
#+latex_header: \setabbreviationstyle[acronym]{long-em-short-em}

# TODO install and apply a grammar checker.
# TODO use glossary everywhere <https://www.overleaf.com/learn/latex/Glossaries>
# TODO verify software versions with Cargo.lock from v0.3.0 tag.
# TODO fix hbox overflows on texttt in list of listings, bibliography, glossary
# TODO fix second list of listings page saying "list of figures"
# TODO tweak geometry for last overfull hboxes
# TODO fix memoir page header to use H:3
# TODO ask ARM about permission to copy figures/tables?
# TODO copy more relevant images from ARM spec.

* Org setup                                                        :noexport:
  #+begin_src emacs-lisp :result output :session :exports both
    ;; ignore some headlines
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines))

    ;; minted code listings
    (require 'ox-latex)
    (setq org-latex-listings 'minted)

    ;; use the book class, but without any \parts
    (add-to-list 'org-latex-classes
                 '("thesis"
                   "\\documentclass{memoir}"
                   ("\\chapter{%s}" . "\\chapter*{%s}")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    ;; use \cref instead of \ref, for cleveref
    (setq org-ref-default-ref-type "cref")
    (setq org-latex-prefer-user-labels t)

    ;; setup org-ref
    (setq bibtex-completion-bibliography '("./ref.bib")
          org-export-before-parsing-hook '(org-ref-glossary-before-parsing
                                           org-ref-acronyms-before-parsing))

    ;; make so that =some text= yield \textttBreak{some text} instead of
    ;; \texttt{some text}.
    ;;
    ;; NOTE do not use =some text= in section headings or captions.
    (defun org-latex--protect-texttt (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\texttt{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&_#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--protect-textttbreak (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\textttBreak{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--text-markup (text markup info)
      "Format TEXT depending on MARKUP text markup.
       INFO is a plist used as a communication channel.  See
       `org-latex-text-markup-alist' for details."
      (let ((fmt (cdr (assq markup (plist-get info :latex-text-markup-alist)))))
        (cl-case fmt
          ;; No format string: Return raw text.
          ((nil) text)
          ;; Handle the `verb' special case: Find an appropriate separator
          ;; and use "\\verb" command.
          (verb
           (let ((separator (org-latex--find-verb-separator text)))
             (concat "\\verb"
                     separator
                     (replace-regexp-in-string "\n" " " text)
                     separator)))
          (protectedtexttt (org-latex--protect-texttt text))
          (protectedtextttbreak (org-latex--protect-textttbreak text))
          ;; Else use format string.
          (t (format fmt text)))))
    (setq org-latex-text-markup-alist
          '((bold . "\\textbf{%s}")
            (code . protectedtexttt)
            (italic . "\\emph{%s}")
            (strike-through . "\\sout{%s}")
            (underline . "\\uline{%s}")
            (verbatim . protectedtextttbreak)))

    (org-babel-do-load-languages
     'org-babel-load-languages '((latex . t)
                                 (python . t)))

    ;; Dont require confirmation when babel-ing latex or python code in this document
    (defun my-org-confirm-babel-eval (lang body)
      (not (member lang '("latex" "python"))))
    (setq org-confirm-babel-evaluate 'my-org-confirm-babel-eval)
  #+end_src
#+RESULTS:

* Frontmatter                                                        :ignore:
#+LATEX: \frontmatter
# Make this a single paragraph; use unambiguous terms; aim for 250 words; 3-5 keywords.
#+begin_abstract
Here be an abstract...
#+end_abstract
#+begin_export latex
\newlist{inline-enum}{enumerate*}{1}
\setlist[inline-enum]{label=(\roman*)}

% Include "List of Listings" in the TOC
\renewcommand{\listoflistings}{
  \cleardoublepage
  \addcontentsline{toc}{chapter}{\listoflistingscaption}
  \listof{listing}{\listoflistingscaption}
}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\listoftodos
\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage
\listoflistings
\newpage

% Start counting with arabic numbers
\mainmatter

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Fix todonotes behavior
\setlength{\marginparwidth}{2cm}
\reversemarginpar
#+end_export

* *The Paper*                                                        :ignore:
** Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:
# What are embedded systems, regulators, and how do they relate?
Embedded systems --- a unit combination of a central processing unit, system memory, and input/output peripheral devices --- serve a key role in the operation of systems with electronical components where computations must be made.
A prime examples of such systems are digital control systems which regulate one or more control quantities such that they adhere to designed characteristics.
Often the goal is to track a reference signal; such a control system is known as a regulator.
A regulator observes (either directly or by approximation) the internal states of a system under control via sensors and affect the system via actuators.
For example, one may wish to keep a rocket on a set path to reach orbit, or control the internals of a nuclear power plant to maximize electrical power output while keeping the plant within safe operation boundaries.

# On the real-time restrictions of control systems; exponential complexity phenomena.
A key design parameter of digital controllers is the [[gls:sample-rate][sample rate]]: if too low or unconsistent, the controlled system will end up unstable [[parencite:&franklin]]:
the rocket may thus fly off course, or the nuclear reactor reach a meltdown.
This puts a real-time constrain on the digital controller which greatly limits how it can be implemented.
Further, a digital controller under implementation must be debugged so that the engineers can verify its correct operation and realize the real-time constrain.
This task grows exponentially in difficulty as the number of system states, inputs, and outputs increase.
A similar phenomena is observed for embedded systems with an increasing number of responsibilities, such as handling firmware updates or switching modes of operation on a button press.

# The observer effect; data exfiltration.
Unfortunately are embedded systems subject to the observer effect: to observe the internal state of a embedded system (i.e., system variables in memory) its operation must be affected.
# A proper implementation would not block on a serial write.
This observeration is often realized by exfiltrating data via serial communication which in the best case can induce bus contention and full output queues,
but it is not uncommon that a program blocks until the data has been serialized, severely affecting the purpose of the program --- regulation --- if the payload is large.
In a perfect implementation, the user application --- the program that executes on the embedded system --- would only concern itself with its mainsake regulation procedure and leave data exfiltration to a completely disjoint system, removing the observer effect and thus the effect on the underlying control system.

# ARM, tracing subsystem and possible exploitation.
ARM Ltd. is a company that licenses out designs of ARM [[glspl:CPU]] for embedded systems.
ARM [[glspl:CPU]] are available via a number of vendors, e.g. STMicroelectrics, NXP Semiconductors, and Nordic Semiconductors.
The ARMv7-M platform standard offers debugging facilities that enables the developer to trace the system.
From [[textcite:&arm-cortex-learn]]: "Trace refers to the process of capturing data that illustrates how the components in a design are operating, executing, and performing".
Additionally, "[Trace generation is] almost entirely non-invasive. [Trace generation] does not influence the wider system".
These trace facilities allows for an event-based monitoring of
- interrupt handler enters and exits;
- Read and write access to in-memory address spaces; and
- [[gls:PC]] samples, among other features.
The generated trace is then exfiltrated via asynchronous serial using a packet protocol (described in [[cref:debug-periphs]]), henceforth referred to as the [[gls:trace-stream]].
These facilities are not disjoint (if they were, no insight into the traced system could be offered) but because the generation of the trace stream does not influence the wider system the trace stream with system-external collection is a suitable candidate for exploitation to realize insight into a control system with minimal observer effect.

# Less work, more sleep.
Further, with non-invasive trace generation, less code must be executed by the [[gls:CPU]], allowing a shorter duty-cycle of the user application.
With a decreased duty-cycle, the system can be put to sleep longer, and thus conserve energy.

# On real-time implementation restictions, embedded implementation difficulties in general.
The development of embedded system in general is a difficult one.
In comparison to general-purpose computers, where one often need not worry about resource limitations, embedded systems are constrained in all manners such that costs can be minimized for their non-general applications.
# No rich OS; no two embedded platforms are the same.
An embedded developer seldom have access to a rich operating systems --- a Linux-based distibution, for example --- which offers general-purpose facilities based on dynamic allocations and a common environment to simplify implementation.
Two embedded platforms usually differ significantly (even if both platforms are based upon ARMv7-M), and porting an implementation to another platform is no small task.
This compares to general-purpose computers where a program written on one computer can be executed on another one, as long as the operating environment remains the same.
# Side effects and priority inversions.
Embedded platforms are much more subject to side-effects where peripherals are operated by writing data to memory-mapped registers.
Of certain importance is the problem of priority inversions, where a task of lower priority executes instead of a higher prioritized task because of implementation error.
In summary it is easy to put an embedded system in an incorrect or unknown state.
# Enter RTIC.
In order to lighten the implementation burden one may employ [[gls:RTIC]], (see [[cref:rtic]]).

# Project aim
The aim of this thesis is thus to employ and extend upon [[gls:RTIC]] with a toolset, aptly named RTIC Scope, to trace [[glspl:task][tasks]] --- recording their executions off-target --- by leveraging [[Citeauthor:&arm-cortex-learn][ARM]]'s non-intrusive tracing facilites.
RTIC Scope will aim for minimal end-user overhead in order to apply the toolset, and allow the replay of traces post-mortem.

# Thesis summary
This thesis covers the theory behind relevant ARM peripherals and protocols upon which RTIC Scope relies, a close-to exhaustive enumerations of the contributions made during the project and a detailed description of its implementation, along with discussions on approaches taken and topics of interests regarding the future work that can be done to improve upon the toolset.

*** Background
This introductory section covers the software components that have realized RTIC Scope.

**** The Rust programming language
:PROPERTIES:
:CUSTOM_ID: rust
:END:
Rust is a system programming language that guarantees defined run-time behavior and the absence of mutable aliasing as long as code is written in a [[gls:safe]] context.
Throughout this text the following Rust terminology is used:
[[gls:crate]], [[gls:enum]], [[gls:struct]], [[gls:function]], [[gls:macro]], [[gls:manifest]], [[gls:feature]], and [[gls:trait]].
For sake of decreasing typesetting noise, the relevant glossary entries for these fundamental terms will not be referred to again henceforth.
For a more detailed description of this terminology, and the Rust programming language and eco-system in general, refer to [[textcite:&rust-lang]].

For a summary of Rust in an embedded context, refer to [[textcite:&tjader2021rtic 6--8]].

**** \glsxtrfull{PAC}
:PROPERTIES:
:CUSTOM_ID: background:PAC
:END:
# What is a PAC and what are they used for?
A PAC is a Rust library crate which exposes an [[gls:API]] for hardware peripherals.
Rather than providing an ad-hoc implementation inlined in an embedded application, a PAC provides a convenient interface to read and write to memory-mapped registers in order to mutate (in order to configure) and query (in order to poll the status of) hardware peripherals.

# Differentiate {architecture,device}-specific PACs
In the embedded Rust ecosystems, these are two kinds of PACs:
- Architecture-specific :: [[glspl:PAC]] exposes an [[gls:API]] for hardware peripherals common to all embedded systems that share the same architecture, commonly denoted as a "family". For example, =cortex-m= [[parencite:&cortex-m]] is a [[gls:PAC]] that targets the ARM Cortex-M family of embedded systems, which is based on the ARMv7-M standard.
- Device-specific :: [[glspl:PAC]] exposes an [[gls:API]] for hardware peripherals available on a smaller family of embedded systems.
  For example, =stm32-rs= [[parencite:&stm32-pac]] is a collection of PACs targeting all microcontrollers in the STMicroelectronics STM32 family.

# svd2rust
A common tool to generate PACs is =svd2rust= [[parencite:&svd2rust]].

An important component of device-specific [[glspl:PAC]] for RTIC Scope is the interrupt enum.
An example declaration of such an enum can be seen in [[lst:pac-interrupt-example]].
Refer to [[cref:impl:cargo-rtic-scope:generating-metadata-maps]] on how this enum is utilized.
#+NAME: lst:pac-interrupt-example
#+CAPTION: Example declaration of a ~PAC::Interrupt~ enum. Left-hand side of ~Interrupt~ is the IRQ label; right-hand is $N$ in [[tbl:irqns]].
#+begin_src rust
  pub mod PAC {
      #[derive(Debug)]
      #[repr(u16)]
      pub enum Interrupt {
          PVD = 1,
          EXTI0 = 6,
          EXTI1 = 7,
          // ...
      }

      unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
          #[inline(always)]
          fn number(self) -> u16 {
              self as u16
          }
      }
  }
#+end_src

**** \glsxtrfull{RTIC}
:PROPERTIES:
:CUSTOM_ID: rtic
:END:
[[gls:RTIC]] [[parencite:&rtic]] is a novel [[gls:RTOS]] targeting the ARM Cortex-M platform.
It is developed at Luleå Technical University based on the extensively studied [[gls:SRP]], which
- prevents deadlocks;
- mitigates priority inversions; and
- is compatible with [[gls:EDF]] sheduling [[parencite:&srp]].
[[gls:RTIC]] thus removes some burden out-of-the-box while also
- implementing message passing between tasks;
- incurring a minimal scheduling overhead;
- being highly efficient on memory usage; and
- being amenable to [[gls:WCET]] analysis [[parencite:&rauk]].

# Oh yeah, and Rust
[[gls:RTIC]] is written in Rust which removes additional developer overhead (see [[cref:rust]]).

An [[gls:RTIC]] application is implemented by statically declaring a set of atomic [[glspl:task]] which are executed and scheduled by help of Cortex-M hardware features.
This section summarizes the two different task types --- [[glspl:hardware-task]] and [[glspl:software-task]] --- that together constitute an [[gls:RTIC]] application.
For more details on [[gls:RTIC]] and how it is implemented, refer to [[textcite:&rtic]] and [[textcite:&tjader2021rtic]].

Hardware tasks are regular Rust functions that are bound to an [[gls:interrupt]].
When this interrupt is made pending in hardware, and no interrupt handler of higher priority is currently exeuting, the task function executes.
An example hardware task is declared via [[cref:rtic-hw-task-example]].
With this declaration, =app::foo= will be executed when =EXTI0= is pending.
When =app::foo= returns, the interrupt has been handled and =EXTI0= is no longer pending.
#+name: rtic-hw-task-example
#+CAPTION: \glsxtrfull{RTIC} hardware task bound to the ~EXTI0~ interrupt.
#+begin_src rust
  #[rtic::app]
  mod app {
      #[task(bound = EXTI0)]
      fn foo(_ctx: foo::Context) {
          // ...
      }
  }
#+end_src

Software tasks are also regular Rust functions that are bound to hardware interrupts, but the bound hardware interrupt is not exclusively associated to the task in question: a single hardware interrupt can be associated with multiple software tasks.
For this reason, the interrupt used to dispatch software tasks termed a [[gls:task-dispatcher]].
An example of two software tasks are declared via [[cref:rtic-sw-task-example]].
Multiple task dispatchers can be declared.
It is not possible to declare which tasks a task dispatcher should handle; this is done automatically.
#+name: rtic-sw-task-example
#+caption: \glsxtrfull{RTIC} software task, bound non-exclusively to the ~EXTI0~ interrupt, acting as the task dispatcher.
#+begin_src rust
  #[rtic::app(dispatchers = [EXTI0])]
  mod app {
      #[task]
      fn bar(_ctx: bar::Context) {
          // ...
      }
  }
#+end_src

The purpose of hardware tasks is to respond to external stimuli, e.g. a button press, a timer trigger, or similar.
Hardware tasks cannot be scheduled via the [[gls:RTIC]] [[gls:API]].

The purpose of software tasks is to provide a task implementation that is scheduled by software via the [[gls:RTIC]] [[gls:API]] instead of being triggered by external stimuli.
Example usage of a software task may be to send a response over a line of communication after a hardware task executed to read a message on the same line.
**** Hardware debuggers
:PROPERTIES:
:CUSTOM_ID: background:probes
:END:
Hardware debuggers, also known as [[glspl:probe]], are dedicated hardware that provide a debugging interface between the host and target.
In practise, the probe is its own embedded system, used to program and debug the embedded system that is considered the target.
A probe usually provides a [[gls:USB]] interface for the host-side and a [[gls:SWD]] and/or [[gls:JTAG]] interface for the target.
An embedded system may provide its own probe, usually the case for development kits, or expose headers on which to attach a probe for programming and debugging.

In order to interface with a hardware probe a software suite is required on the host side.
Examples of such suites are =openocd=, [[textcite:&openocd]]; and =probe-rs=, [[textcite:&probe-rs]].
Two different such suites may offer different feature sets and hardware probe support sets.

*** Motivation
# We must cross a hardware boundry when debugging embedded systems.
Debugging the code being executed in an embedded system is an integral part of an embedded work-flow similar to how it is common to attach to and debug a process of a program being developed on a general-purpose computer.
The latter process can be considered trivial because no hardware boundries must be crossed; the debugger and debugged program are (usually) contained within the same system.
Debugging an embedded system is on the other hand non-trivial: the embedded system is its own contained system and a probe must be used to establish a line of communication with a host system to debug the embedded system.
\missingfigure{Draw a comparison between conventional debugging and embedded debugging.}

# We want to be able to debug in real-time (read: trace), but also record it.
An important aspect of debugging is the act of debugging in real-time, often referred to as the act of [[gls:tracing]].
By tracing an embedded system it is possible to verify its internal operations continuously as long as a debugger is attached.
Another important aspect of debugging are post-mortem analyses: being able to analyse a system's run-time behavior before it ended up in an invalid or unexpected state after the fact.
Port-mortem analyses are realized by recording a trace from the attached debugger.
Such analyses are useful for systems deployed in the field or any system which are seldom (or not at all) continuously controlled by human hands.
If such a system fails and its operation has been traced it can be replayed to debug how it failed.

# Tracing is zero-cost by help of hardware, but not trivial to configure.
Tracing is supported by hardware debug facilities on the ARMv7-M platform, as is the exfiltration of the trace stream from the device (a line of communication which can be read by a host system).
Enabling and correctly configuring these facilites to generate a trace stream and decoding the trace stream itself is no trivial task, however.

# The emergence of RTIC, and its lack of debug tools.
RTIC is a novel RTOS which offers improvements over conventional RTOSs [[parencite:&tjader2021rtic 23]].
The motivation behind RTIC Scope is thus to offer a batteries included[fn:: where details regarding trace stream generation and decoding is abstracted, and where no additional work must be done to utilize the tool.] toolset that enables instant insight into an RTIC application.
Such a toolset would make it easier to verify the implementation of an RTIC application.

*** Problem definition
:PROPERTIES:
:CUSTOM_ID: requirements
:END:
This thesis covers the development of an embedded systems analysis toolset, RTIC Scope, that enables an RTIC application developer to gain non-invasive insight into the run-time of said application by exploiting the trace stream generated and exfiltrated by the debug facilities (see [[#debug-periphs]]) made available by the ARMv7-M standard, which RTIC supports by targeting Cortex-M platforms.

The set of requirements RTIC Scope must fulfill within the scope of this thesis follows: RTIC Scope *MUST*[fn:: Interpreted as described in [[textcite:&rfc2119]].] be able to
1. <<req:itm-gen>> enable trace stream generation of hardware and software tasks (as defined by RTIC), and enable exfiltration of said trace stream from the device, by help of a target-side tracing library crate;
2. <<req:input>> read the generated trace stream via a hardware debugger or a serial device;
3. <<req:decode>> decode the trace stream;
4. <<req:rtic>> recover RTIC application metadata not contained within the trace stream;
5. <<req:timestamps>> associate timestamps to RTIC task events;
6. <<req:protocol>> report RTIC task events to the RTIC Scope end-user by use of a defined communication protocol.
7. <<req:dummy>> offer a reference implementation of a [[gls:frontend]] which implements the the protocol described in Requirement [[req:protocol]].
8. <<req:record>> record a trace to file which can be replayed offline by use of a host-side daemon; and
9. <<req:cargo>> be invoked as a =cargo= subcommand.

Delimitations to the above requirements apply, see [[#delimitations]].
*** Delimitations
:PROPERTIES:
:CUSTOM_ID: delimitations
:END:
In order to focus on the delivery of a robust toolset with proper implementation and documentation the scope of this thesis have been limited.
These delimitations[fn:: Uses the key words *MUST* and *SHOULD NOT* which are to be interpreted as described in [[textcite:&rfc2119]].], which are related to the requirements enumerated in [[#requirements]], are as follows:
1. Requirement [[req:itm-gen]]: RTIC Scope *MUST* apply the device mutations that are common to all ARM Cortex-M targets in order to enable trace stream generation and exfiltration. RTIC Scope *SHOULD NOT* apply device-specific mutations.
2. Requirement [[req:input]]: RTIC Scope *SHOULD NOT* have to ensure that a trace stream is read from the device; that responsibility falls upon the RTIC Scope end-user. However, RTIC Scope *MUST* fail or warn the end-user if it is unable to correctly decode the read data stream.
3. Requirement [[req:rtic]]: RTIC Scope *MUST* support RTIC version 1.0.0, see [[textcite:&rtic]].
   RTIC Scope *MUST* recover metadata necessary to report the timestamped state changes of hardware and software tasks, as defined by RTIC.
4. Requirement [[req:protocol]]: The defined communication protocol *MUST* enable one-way communication from the =cargo= subcommand [[gls:backend]] to the reference [[gls:frontend]]. The protocol *SHOULD NOT* enable two-way communication.

Following the above delimitations allows this thesis to be finished within an acceptable time frame[fn:: As defined by the author, i.e. not necessarily the recommended time frame as defined by the X7009E course taken at Luleå Technical University during which this thesis is written.] and also to yield a documented code base which allows future development with minimal friction.

*** Contributions
:PROPERTIES:
:CUSTOM_ID: contribs
:END:
The development of RTIC Scope has yielded a number of [[gls:downstream]] contributions, namely a collection of crates:
- =cargo-rtic-scope= :: A =cargo= subcommand acting as the RTIC Scope [[gls:backend]] (i.e. host-side [[gls:daemon]]) which fulfill Requirements [[req:input]]--[[req:protocol]] and [[req:record]]--[[req:cargo]].
  See [[cref:impl:cargo-rtic-scope]] and [[textcite:&rtic-scope:cargo-rtic-scope]].
- =rtic-scope-frontend-dummy= :: A reference implementation of a RTIC Scope frontend, which fulfill Requirement [[req:dummy]].
  See [[cref:impl:rtic-scope-frontend-dummy]] and [[textcite:&rtic-scope:dummy]].
- =rtic-scope-api= :: The communication protocol that =cargo-rtic-scope= uses to report RTIC task events to =rtic-scope-frontend-dummy=, as described by Requirement [[req:protocol]].
  See [[textcite:&rtic-scope:api]].
- =cortex-m-rtic-trace= :: An auxilliary target-side crate that properly configures the device for trace stream generation and exfiltration, which fulfills Requirement [[req:itm-gen]].
  See [[cref:impl:rtic-trace]] and [[textcite:&rtic-scope:rtic-trace]].
- =itm= :: A library crate for decoding the trace stream exfiltrated from the embedded system, which fulfill Requirements [[req:decode]] and [[req:timestamps]] (partially).
  See [[cref:impl:itm]] and [[textcite:&itm]].

Of certain note is =itm= which =cargo-rtic-scope= relies on: its implementation is disjoint from RTIC and can be used independently of RTIC Scope.
=itm= can also be used to decode trace stream generated by a target using an RTOS other than RTIC.
Because of this general nature and detachment from both [[gls:RTIC]] and RTIC Scope it must not necessarily be a part of the RTIC Scope project itself, but is as of writing for reasons of development convenience.
See [[cref:disc:itm-embedded-wg]] for a discussion on under what banner =itm= belongs.

Further, a number of [[gls:upstream]] contributions have been made to the crates which RTIC Scope depends on.
An exhaustive summary of these contributions are described below (listed in no particular order).

- =probe-rs/probe-rs= ::
  A "a modern, embedded debugging toolkit, written in Rust" [[parencite:&probe-rs]] utilized to fulfill Requirement [[req:input]].
  Contributions are:
  - /Reintroduce CargoOptions in mod common\textunderscore options/: patch set included in a larger refactor [[parencite:&pr:probe-rs:760]].
  - /arm: enable exception trace on setup\textunderscore swv/: improves tracing support for ARM targets [[parencite:&pr:probe-rs:758]].
  - /cargo: bump bitvec/: updates a dependency [[parencite:&pr:probe-rs:757]].
  - \textit{arm/itm: doc fields, enable global timestamps}: improves documentation [[parencite:&pr:probe-rs:728]].
  - \textit{Add generic probe/session logic from cargo-flash}: improves composability with RTIC Scope [[parencite:&pr:probe-rs:723]].
  - \textit{deprecate internal ITM/DWT packet decoder in favour of itm-decode}: replaces an unfinished internal trace stream decoder with an =itm= precursor; see [[cref:impl:itm]] [[parencite:&pr:probe-rs:564]].

  Refer to [[cref:impl:cargo-rtic-scope]] for a detailed description of the usage of this toolkit.
- =probe-rs/cargo-flash= ::
  A "cargo extension for programming microcontrollers" [[parencite:&cargo-flash]], functionality of which is used by =cargo-rtic-scope=.
  Contributions are:
  - /move probe, session logic, flash downloader to probe-rs-cli-util/: moves functionality from =cargo-flash= to an auxilliary =probe-rs= library crate such that they can be utilized by =cargo-rtic-scope= [[parencite:&pr:cargo-flash:188]].

- =rust-embedded/cortex-m= :: A library crate that enables "low level access to Cortex-M processors" [[parencite:&cortex-m]], utilized to fulfill Requirement [[req:itm-gen]], [[req:decode]] and [[req:record]].
  Contributions are:
  - /scb: derive serde, Hash, PartialOrd for VectActive behind gates/: adds features used by =itm= [[parencite:&pr:cortex-m:363]].
  - /Implement various interfaces for trace configuration/: adds features used by =cortex-m-rtic-trace= [[parencite:&pr:cortex-m:342]].
  - /TPIU: swo\textunderscore supports: make struct fields public, improve documentation/: fixes an issue in a library module and improves documentation [[parencite:&pr:cortex-m:381]].
  - /CHANGELOG: add missing items/: adds documentation about added features [[parencite:&pr:cortex-m:378]].
  - /itm: derive serde for LocalTimestampOptions, impl gated TryFrom<u8>/: adds features used by =cargo-rtic-scope=  [[parencite:&pr:cortex-m:366]].
  - /ITM: check feature support during configuration, add busy flag, docs improvement/: ensures hardware support during trace stream generation configuration [[parencite:&pr:cortex-m:383]].

  Refer to [[cref:impl:rtic-trace]] and [[cref:impl:itm]] for a detailed description of the usage of this library.
- =rtic-rs/rtic-syntax= :: A crate that defines and parses the RTIC meta language [[parencite:&rtic-syntax]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - /improve error string if parse\textunderscore binds is not set/: improves run-time documentation when the crate is used as a library [[parencite:&pr:rtic-syntax:47]].
- =rtic-rs/cortex-m-rtic= :: The RTIC implementation for Cortex-M platforms [[parencite:&rtic]].
  Contributions are:
  - \textit{book/migration/v5: update init signature, fix example syntax}: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:480]].
  - /book: detail import resolving for 0.6 migration/: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:479]].
  - /book: update outdated required init signature/: improves RTIC examples in documentation [[parencite:&pr:rtic:478]].
- =Michael-F-Bryan/include_dir= :: A crate for embedding file trees in a binary [[parencite:&includedir]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - /Dir: add extract-to-filesystem functionality/: implements functionality for extracting embedded file trees to disk [[parencite:&pr:includedir:57]].
  - \textit{dir/extract: add mode for overwriting existing files}: implements functionality for overwriting existing files when extracting embedded file trees to disk [[parencite:&pr:includedir:65]].

*** Outline
 This paper is structured as follows:
 - [[cref:introduction]], Introduction :: Provides a background introduction to Rust, the embedded Rust ecosystem and [[gls:RTIC]].
   Subsequently covers the project motivation, problem definition, delimitations and contributions made within the scope of this thesis, and guidelines on how to read this text.
 - [[cref:prev-work]], Previous and Related work :: presents work previously done in the same domain, which this thesis builds upon, and some tools with similar feature sets of RTIC Scope.
 - [[cref:theory]], Theory :: Covers the ARMv7-M debug facilities, the [[gls:ITM]] packet protocol and how [[gls:RTIC]] tasks are traced in theory via RTIC Scope.
 - [[cref:impl]], Implementation :: covers the implementation of RTIC Scope and the =itm= crate.
 - [[cref:results]], Results :: Covers the results of this thesis.
 - [[cref:discussion]], Discussion :: discusses some topics of interests regarding RTIC Scope, and a choice selection of topics for further development.
 - [[cref:conclusion]], Conclusions :: Summarizes the work done in this thesis.

*** TODO Reading guidelines
# cover important typesetting such as glossary use. When and why not all terms are linked to the glossary.
# Blame any mess on time constrains.

** Previous and Related Work
:PROPERTIES:
:CUSTOM_ID: prev-work
:END:
This chapter briefly covers previous work upon which RTIC Scope is based and related work.
*** Previous work
The implementation of RTIC Scope stands of the shoulders of countless developers that have enabled the implementation of the toolset within the frame of this thesis.
Notable libraries are referred to inline throughout this text.
When citing software, the three authors with the most contributions (in decreasing order) at the time of writing are cited as the authors of that software.
This is done for brevity.

*** Related work
Some toolsets similar to RTIC Scope were already available before the start of this thesis, namely:
- orbuculum :: an "[ARM] Cortex-M trace stream demuxer and post-processor" [[parencite:&orbuculum]];
- Percepio Tracealyzer :: a proprietary visual trace diagnostic tool that supports a multitude of platforms and [[glspl:RTOS]] [[parencite:&tracealyzer]].
Neither of the above tools support [[gls:RTIC]] at the time of writing.

** Theory
:PROPERTIES:
:CUSTOM_ID: theory
:END:
This chapter covers the purpose and usage of the utilized ARMv7-M debug peripherals, relevant sections of the [[gls:ITM]] packet protocol and how [[gls:RTIC]] tasks are traced.
*** ARMv7-M debug facilities
:PROPERTIES:
:CUSTOM_ID: debug-periphs
:END:
This section summarizes the hardware peripherals responsible for the generation and exfiltration of the [[gls:ITM]] packet protocol.
The relationship of these perhipherals is also presented.
This section is not exhaustive for the sake of brevity.
For full information on each peripheral, refer to the respective sections in [[textcite:&arm-rm]].
See [[cref:theory:itm-proto]] for a description of the [[gls:ITM]] packet protocol.

# DWT -> ITM -> TPIU -> ETB.
RTIC Scope utilizes the [[gls:DWT]], [[gls:ITM]], and [[gls:TPIU]] peripherals for on-target trace generation and exfiltration.
The [[gls:DWT]] and [[gls:ITM]] peripherals are sources of [[gls:ITM]] protocol packets which are forwarded to the [[gls:TPIU]] for device exfiltration.
The [[gls:ITM]] multiplexes packets emitted by itself and the [[gls:DWT]] and generates timestamp packets in order to establish a timeline of events that occured on the traced target.
The relationship of these peripherals are visualized in [[cref:fig:debug-relations]].

#+BEGIN_src latex
  \begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, auto]
    \node[block] (clock) {timestamp clock};
    \node[block, below=0.5cm of clock] (itm) {\gls{ITM} \\ (timestamps, \\ multiplexing, etc.), \\ \cref{theory:itm-periph}};
    \node[block, left=of itm] (dwt) {\gls{DWT} \\ (hardware events), \\ \cref{theory:dwt}};
    \node[block, right=of itm] (tpiu) {\gls{TPIU} \\ (serialization), \\ \cref{theory:tpiu}};
    \node[block, above=0.5cm of tpiu] (prescaler) {prescaler: $/n$};
    \node[block, above=0.5cm of prescaler] (freq) {reference \\ clock $\left[\text{Hz}\right]$};
    \node[below=of tpiu.south east] (swo) {\gls{SWO}, \\ \cref{theory:swo}};
    \node[below=of tpiu.south west] (parallel) {parallel trace \\ output};
    \path[->]
    (dwt) edge (itm)
    (clock) edge (itm)
    (itm) edge (tpiu)
    (freq) edge (prescaler)
    (prescaler) edge (tpiu);

    %% box
    \node[above=0.5cm of clock] (target) {target configured with \\ \texttt{cortex-m-rtic-trace}, \\ \cref{impl:rtic-trace}};
    \draw[dotted,fill=yellow,fill opacity=0.2] let \p1=($(dwt.west)+(-0.3,0)$), \p2=($(target.north)+(0.0,0.3)$) in (\x1, \y2) rectangle ($(tpiu.south east)+(0.3,-0.3)$);

    %% anchors
    \node[below=0.5cm of tpiu.south west] (parallel-anchor) {};
    \node[below=0.5cm of tpiu.south east] (swo-anchor) {};
    \draw[-] ($(tpiu.south west)!0.5!(tpiu.south)$) |- (parallel-anchor.center);
    \draw[-] ($(tpiu.south east)!0.5!(tpiu.south)$) |- (swo-anchor.center);
    \path[->] (swo-anchor.center) edge (swo);
    \path[->] (parallel-anchor.center) edge (parallel);

  \end{tikzpicture}
  \caption{\label{fig:debug-relations}Downstream relationship between ARMv7-M debug peripherals used for tracing.
    Hardware event packets from the \gls{DWT} are forwarded to the \gls{ITM} which are subsequently forwarded to the \gls{TPIU} with an attached timestamp generated by the \gls{ITM}.
    The \gls{TPIU} serializes the \gls{ITM} protocol packets over \gls{SWO} or a parallel trace output by help of a reference clock divided by a prescaler ($n \geq 1$ is an integer).
    In this text only the \gls{SWO} is considered.}
  \end{figure}
#+END_src

**** \glsxtrfull{DWT}
:PROPERTIES:
:CUSTOM_ID: theory:dwt
:END:
# What does the DWT do and how do we use it?
The [[gls:DWT]] peripheral concerns itself with hardware events and react to these accordingly depending on the applied configuration.
For the purpose of RTIC Scope the [[gls:DWT]] is configured to emit [[glspl:hardware-event-packet]] on two types of events: when
- a configured range of memory is accessed (known as [[gls:data-tracing]]); and
- whenever the processor enters, exits, and returns to an exception handler (known as [[gls:exception-tracing]]).
Within this text the range of memory used for data tracing is referred to as a [[gls:watch-address]]:
when a value is written to a [[gls:watch-address]], a data trace packet is generated containing the written value.

In order to monitor a [[gls:watch-address]] a hardware comparator must be used.
An ARMv7-M [[gls:MCU]] offers between 0 and 15 such comparators.
RTIC Scope v0.3 requires two comparators.

Refer to [[textcite:&arm-rm Section C1.8]] for more information on the DWT unit.
**** \glsxtrfull{ITM}
:PROPERTIES:
:CUSTOM_ID: theory:itm-periph
:END:
# Summarize ITM functionality
The [[gls:ITM]] is of an auxilliary nature with three functions:
- the multiplexing of [[glspl:hardware-event-packet]] from the [[gls:DWT]] with its own packets which are then forwarded to the [[gls:TPIU]];
- control and generation of timestamp packets; and
- exposure of a memory-mapped register interface that allows logging of arbitrary data via a maximum of 256 stimulus registers[fn:: Not utilized by RTIC Scope.].

# Summarize the timestamp sources
Timestamp packets are sourced from a reference clock which can be seen in [[cref:fig:debug-relations]].
This reference clock is either the [[gls:system-clock]], an asynchronous [[gls:TPIU]] reference clock, or a "global timestamp clock"[fn:: See [[cref:fut:review-timestamp-relation]].].
The frequencies and behavior of these reference clocks and how the target clock hierarchy is configured in general is wholly specific to each target and will thus not be covered in further detail.

For more information on the [[gls:ITM]] unit, refer to [[parencite:&arm-rm Section C1.7]]. For more information on global and local timestamps, refer to [[parencite:&arm-rm p. C1-710]].
**** \glsxtrfull{TPIU}
:PROPERTIES:
:CUSTOM_ID: theory:tpiu
:END:
# Summarize TPIU functionality
The [[gls:TPIU]] provides external visibility of the trace packet stream by asynchronously serializing them on a single pin by help of a prescaled reference clock, see [[cref:fig:debug-relations]].
In order to communicate over an asynchronous serial channel the [[gls:baud-rate]] must be communicated out-of-band: it must be pre-configured both target-side and host-side.

When asynchronous serial is used, a choice of two protocols can be chosen: Manchester or NRZ encoding[fn:: Definition of these encoding protocols are not important in the context of this thesis. NRZ encoding is used in experiments referred to in this text.].

For more information on the TPIU, refer to [[parencite:&arm-rm Section C1.10]].
*** The \glsxtrfull{SWO} pin
:PROPERTIES:
:CUSTOM_ID: theory:swo
:END:
*** Serial devices
:PROPERTIES:
:CUSTOM_ID: theory:serial-device
:END:
*** The \glsxtrfull{ITM} packet protocol
:PROPERTIES:
:CUSTOM_ID: theory:itm-proto
:END:
The [[gls:ITM]] packet protocol is used by RTIC Scope to garner insight about the executing RTIC application.
This protocol defines packets that contain a one-byte /header/, which describes what type of data a certain packet contains; how long the packet /payload/ is, a byte multiple; and the packet payload.
Some headers also contain payload.
The protocol effectively implements a [[gls:TLV]] encoding sheme.
This section covers the packet types that RTIC Scope exploits and provide graphical representations ([[crefrange:fig:lts1,fig:data-trace-packet]]) of these packets, sourced from [[textcite:&arm-rm]].
Within all of these representations, the /C/ flag indicate whether a decoder should interpret the next byte in the trace stream as a part of the current packet:
if /C/ is not set, the next byte in the stream is a header for the next packet.

For other packet types, and a full description of the protocol, see [[textcite:&arm-rm Part D4]].

RTIC Scope v0.3 concerns itself with six packets:
- [[gls:GTS1]] :: A timestamp packet containing the lower 26 bits of the absolute timestamp.
- [[gls:GTS2]] :: A timestamp packet containig the upper 22 or 38 bits of the absolute timestamp, depending on the hardware implemenation.
- [[gls:LTS1]] :: A multi-byte timestamp packet containing the relative timestamp.
- [[gls:LTS2]] :: A single-byte timestamp packet containing the relative timestamp.
- Exception trace packet :: A [[gls:hardware-event-packet]] describing the status of an interrupt handler. See [[cref:theory:itm:exceptions]]
- Data trace data value packet format :: A [[gls:hardware-event-packet]] describing the value read or written to a [[gls:watch-address]] monitored by a [[gls:DWT]] comparator. See [[cref:theory:itm:data-trace]].
For timestamp packets, see [[cref:theory:itm:timestamps]].

**** Timestamp packets
:PROPERTIES:
:CUSTOM_ID: theory:itm:timestamps
:END:
Timestamp packets come in two types: absolute and relative.
Both types derive their timestamps from one or more reference clocks (see [[cref:theory:itm-periph]]):
absolute timestamps denote how many ticks this clock have tocked ever since it was connected to the [[gls:ITM]]; and
relative timestamps denote how many ticks this clock have tocked ever since the last relative timestamp.
When a relative timestamp is generated the relative timestamp counter is reset.
This type separation is done in order to decrease the required bandwidth to communicate the time on the system.
Absolute and relative timestamps are further divided into a total of four different packets, summarized above and detailed below.

Global timestamps come in three flavour: 48-bit, 64-bit, or not at all (omitted).
Whether global timestamp support is implemented, and the size of this timestamp, depends on the hardware implementation of the [[gls:ITM]].

The two packets that constitute a global timestamp, [[gls:GTS1]] and [[gls:GTS2]], are sent seperately and not necessarily in order.
A [[gls:GTS2]] packet is not emitted unless any of the bits in the 26--47 or 26--64 range have changed.
The [[gls:GTS1]] packet also contains two flags aside from the lesser significant 25 bits:
- /ClkCh/ :: Set if the system which the [[gls:ITM]] is tracing has changed clock input to the processor since the last global timestamp packet.
  A full global timestamp follows in the stream if this flag is set.
- /Wrap/ :: Set if the more significant bits above the 25th have changed since the last [[gls:GTS2]] packets.
If either of the flags are set the [[gls:GTS1]] should be recorded until the next [[gls:GTS2]] is received so that the full timestamp can be decoded.
[[cref:fig:gts1]], [[cref:fig:gts2-48]], and [[cref:fig:gts2-64]] visually describes the [[gls:GTS1]], [[gls:GTS2]] (48-bit) and [[gls:GTS2]] (64-bit) packets, respectively.

Global timestamps can be generated periodically; or after each packet, if space is available in the queue.

#+NAME: fig:gts1
#+CAPTION: \glsxtrfull{GTS1} packet format, copied from [[textcite:&arm-rm Figure D4-7]].
[[file:svgs/gts1.pdf]]
#+NAME: fig:gts2-48
#+CAPTION: \glsxtrfull{GTS2} 48-bit packet format, copied from [[textcite:&arm-rm Figure D4-8]].
[[file:svgs/gts2-48.pdf]]
#+NAME: fig:gts2-64
#+CAPTION: \glsxtrfull{GTS2} 64-bit packet format, copied from [[textcite:&arm-rm Figure D4-9]].
[[file:svgs/gts2-64.pdf]]

The two local timestamps, [[gls:LTS1]] and [[gls:LTS2]], are not complementary:
instead they supply a different maximum relative timestamp.
[[gls:LTS1]] provide a relative timestamp value that can be represented with 28 bits and is between 2--5 bytes long (header included).
[[gls:LTS2]] is a single-byte packet with a relative timestamp that can be represented with 3 bits that are provided in the header.
More specifically, an [[gls:LTS2]] can represent a relative timestamp value of 1--6;
clashes with headers for other types of packets would occur if the value was 0 or 7.
[[gls:LTS1]] also contain a 2-bit /TC/ field which describes the relationship of the timestamp value with the corresponding non-timestamp packet(s).
This flag have four possible values, termed /qualities/ throughout this text, described in decreasing quality:
- /TC/ $=$ 0b00 :: Synchronous: the timestamp value denotes the time when the non-timestamp packet was generated.
- /TC/ $=$ 0b01 :: Delayed relative: the timestamp value denotes the time when the timestamp packet itself was generated.
  The synchronous timestamp is here unknown but must be between the previous and current timestamp values.
- /TC/ $=$ 0b10 :: Synchronous, but the corresponding non-timestamp packet generation was delayed relative to the associated event.
- /TC/ $=$ 0b11 :: Delayed relative, and the corresponding non-timestamp packet generation was delayed relative to the associated event.
[[gls:LTS2]] packets are always synchronous.

Local timestamps are emitted after the corresponging non-timestamp packets.
For example, if the sequence reads
1. data packet 1;
2. [[gls:LTS1]];
3. data packet 2;
4. data packet 3; and
5. [[gls:LTS2]],
then the [[gls:LTS1]] corresponds to data packet 1;
and [[gls:LTS2]] corresponds to data packet 2 and 3.

#+NAME: fig:lts1
#+CAPTION: \glsxtrfull{LTS1} packet format, copied from [[textcite:&arm-rm Figure D4-4]].
[[file:svgs/lts1.pdf]]
#+NAME: fig:lts2
#+CAPTION: \glsxtrfull{LTS2} packet format, copied from [[textcite:&arm-rm Figure D4-6]].
[[file:svgs/lts2.pdf]]

**** Exception trace packets
:PROPERTIES:
:CUSTOM_ID: theory:itm:exceptions
:END:
The exception trace packet ([[cref:fig:exception-packet]]) describes the state of the system's interrupt handlers and are emitted upon such a state change.
Its payload contains two fields:
- /ExceptionNumber/ :: A 7-bit field describing which interrupt handler changed state.
  This field it decoded via [[cref:tbl:irqns]].[fn:exception-number-0]
- /FN/ :: A 2-bit field describing the action taken by the processor regarding the interrupt handler.
  This field can have three possible values:
  - /FN/ $=$ 0b01 :: the exception was entered;
  - /FN/ $=$ 0b10 :: the exception was exited; or
  - /FN/ $=$ 0b11 :: the exception was returned to.
    This action indicates that exception was previously preempted by an exception of higher priority which has now exited.

#+NAME: fig:exception-packet
#+CAPTION: Exception trace packet format, copied from [[textcite:&arm-rm Figure D4-16]].
[[file:svgs/exception-trace.pdf]]
#+CAPTION: ARMv7-M Exception or \glsxtrfull{IRQ} numbers and names/labels. Redrawn from [[parencite:&arm-rm Table B1-4]], with additional emphasis on $N$.
#+NAME: tbl:irqns
| Exception number | Exception name/label   |
|------------------+------------------------|
|                1 | Reset                  |
|                2 | NMI                    |
|                3 | HardFault              |
|                4 | MemManage              |
|                5 | BusFault               |
|             7-10 | Reserved               |
|               11 | SVCall                 |
|               12 | DebugMonitor           |
|               13 | Reserved               |
|               14 | PendSV                 |
|               15 | SysTick                |
|               16 | External interrupt 0   |
|                . | .                      |
|                . | .                      |
|                . | .                      |
|         16 + $N$ | External interrupt $N$ |
|------------------+------------------------|

**** Data trace data value packets
:PROPERTIES:
:CUSTOM_ID: theory:itm:data-trace
:END:
The data trace data value packet format packet ([[cref:fig:data-trace-packet]]), henceforth referred to as the /data trace packet/, are emitted when the processor accesses a watch address after appropriate [[gls:DWT]] comparator configuration (see [[cref:impl:rtic-trace]]).
The payload contains three fields of information:
- /CMPN/ :: A 2-bit identifier of the [[gls:DWT]] comparator which matched the configured watch address access.
  This identifier is the same as the comparator offset specified in [[cref:impl:rtic-trace]].
- /WnR/ :: A flag describing whether the access was a read (not set) or write (set).
- /VALUE/ :: The value that was written to the address.
  The length of VALUE is the same number of bytes accessed by the target hardware.
  If only a single byte is read/written by the target, then VALUE is also one byte long.

#+NAME: fig:data-trace-packet
#+CAPTION: Data trace data value packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-22]].
[[file:svgs/data-trace.pdf]]

*** Tracing \glsxtrfull{RTIC} tasks
# How tasks are traced, summarized
Because [[gls:RTIC]] implements [[glspl:task]] by use of [[gls:exception]] handlers it is only natural to exploit [[gls:exception-tracing]] in order to trace the tasks abstracted above them.
This approach is however only directly applicable to [[glspl:hardware-task]] which dedicate a handler for each task.
[[Glspl:software-task]] are implemented with an additional layer of abstraction above handlers by use of [[glspl:task-dispatcher]] as covered in [[cref:rtic]].
If exception tracing is employed to trace software tasks such a [[gls:trace-packet]] would only describe that one of the potentially multiple software tasks handled by one dispatcher changed state.
Instead, a unique identifier is assigned to each software task and written to a [[gls:watch-address]] when the task enters and exits.
An additional decoding step is then applied to trace software tasks. Refer to [[cref:impl]].

** Implementation
:PROPERTIES:
:CUSTOM_ID: impl
:END:
This chapter covers the implementation of =cortex-m-rtic-trace=, =cargo-rtic-scope=, =rtic-scope-api=, and =rtic-scope-frontend-dummy= of RTIC Scope and the implementation of =itm=.
The implementation is presented in a downstream manner, similar to the order in which the RTIC Scope crates are applied and how the trace data flows.
That is, how
1. =cortex-m-rtic-trace= is applied on the target-side and what it does;
2. =cargo-rtic-scope= recovers metadata from the RTIC application and how it reads the raw trace stream from the source;
3. =itm= decodes this stream into manageable Rust structures;
4. =cargo-rtic-scope= recovers RTIC metadata for the decoded trace stream;
5. this resolved (or previously recorded) trace stream is forwarded to frontends as =rtic-scope-api= structures; and
6. how a frontend handles a trace stream.

A graphical representation this data flow can be seen in [[cref:fig:rtic-scope-data-flow]].

As mentioned in [[cref:delimitations]], this chapter covers v0.3 of RTIC Scope.

#+BEGIN_src latex
  \begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 2cm, auto]

    %% record stack
    \node[block] (tpiu) {\gls{TPIU}, \\ \cref{theory:tpiu}; \\ from~\cref{fig:debug-relations}};
    \node[above=0.5cm of tpiu] (target) {target configured with \\ \texttt{cortex-m-rtic-trace}, \\ \cref{impl:rtic-trace}};
    \draw[dotted,fill=yellow,fill opacity=0.2] let \p1=(target.north east), \p2=($(tpiu.south east)+(0.3,-0.3)$) in (target.north west) rectangle (\x1,\y2);
    \node[block, below=of tpiu] (serial-dev) {serial device, \\ \cref{theory:serial-device}};
    \path[->] (tpiu) edge node {\gls{SWO}, \\ \cref{theory:swo}} (serial-dev);
    \node[block, below=of serial-dev] (itm-crate) {\texttt{itm} crate, \\ \cref{impl:itm}};
    \path[->] (serial-dev) edge node {byte stream; \\ \cref{theory:itm-proto}} (itm-crate);
    \node[block, below left=of tpiu] (rtic-app-crate) {\gls{RTIC} application crate, \\ \crefrange{impl:cargo-rtic-scope:building-rtic-app}{impl:cargo-rtic-scope:read-manifest}};
    \node[block, below=of rtic-app-crate] (recovery-procedure) {recovery procedure, \\ \cref{impl:cargo-rtic-scope:generating-metadata-maps}};
    \path[->] (rtic-app-crate) edge node {crate manifest; \\ \gls{RTIC} application \\ declaration} (recovery-procedure);
    \node[block, below=of recovery-procedure] (record-source) {trace record source, \\ \cref{impl:cargo-rtic-scope:reading-the-trace-stream}};
    \path[->] (recovery-procedure) edge node {recovery maps; \\ trace metadata} (record-source);

    %% replay stack
    \node[block, below right=of tpiu] (replay-file) {replay file, \\ \cref{impl:cargo-rtic-scope:create-trace-file}};
    \node[block, below=of replay-file] (replay-source) {trace replay source, \\ \cref{impl:cargo-rtic-scope:replay}};
    \path[->,dashed] (replay-file) edge node {trace metadata; \\ recovery maps; \\ \texttt{itm} structures} (replay-source);
    \draw[->] (itm-crate.south) |- (record-source.east) node [near start] {\texttt{itm} structures};

    %% trace source anchor
    \node[below=3cm of itm-crate] (mux) {};

    %% run_loop
    \node[block, below=3cm of itm-crate] (run-loop) {\texttt{cargo-rtic-scope}: \\ \cref{impl:cargo-rtic-scope:spawning-frontends}, \\ \cref{impl:cargo-rtic-scope:flush-metadata}, and \\ \cref{impl:cargo-rtic-scope:trace-target}};
    \draw[-] (record-source.south) |- (run-loop.west);
    \draw[->,dashed] (replay-source.south) |- (run-loop.east);

    %% frontend anchors
    \node[below=1.5cm of run-loop] (mux-frontend) {};
    \path[-,dashdotted] (run-loop) edge node [left] {\gls{JSON} of \texttt{rtic-scope-api} \\ structures, \cref{impl:cargo-rtic-scope:trace-target}} (mux-frontend.center);
    \node[below=1cm of mux-frontend] (frontend-anchor) {};

    %% record feedback
    \node[below=0.5cm of run-loop.south east] (feedback1) {};
    \node[right=1.5cm of replay-file] (replay-anchor) {};
    \draw[-] ($(run-loop.south)!0.5!(run-loop.south east)$) |- (feedback1.center);
    \draw[-] (feedback1.center) -| (replay-anchor.center);
    \draw[->] (replay-anchor.center) -- (replay-file.east);

    %% frontends
    \node[block, left=0.5cm of frontend-anchor.center] (frontend2) {$2$nd frontend};
    \node[block, right=0.5cm of frontend-anchor.center] (frontends) {$n-1$th \\ frontend};
    \node[block, left=3.5cm of frontend-anchor.center] (frontend1) {$1$th frontend, \\ \cref{impl:rtic-scope-frontend-dummy}};
    \node[block, right=3.5cm of frontend-anchor.center] (frontendn) {$n$th frontend};
    \draw[->,dashdotted] (mux-frontend.center) -| (frontend1.north);
    \draw[->,dashdotted] ($(frontend2.north)+(0,0.75cm)$) -- (frontend2.north);
    \draw[->,dashdotted] ($(frontends.north)+(0,0.75cm)$) -- (frontends.north);
    \draw[->,dashdotted] (mux-frontend.center) -| (frontendn.north);
    \draw[thin,fill=gray,fill opacity=0.2] ($(frontend2.north west)+(-0.3,0.3)$) rectangle ($(frontendn.south east)+(0.3,-0.3)$);
  \end{tikzpicture}
  \caption{ \label{fig:rtic-scope-data-flow} Downstream data flow in RTIC Scope.
    Data flow drawn with solid lines (\protect\tikz[baseline]{\protect\draw[-] (0,.5ex)--++(1,0) ;}) are operational during trace recording;
    dashed lines (\protect\tikz[baseline]{\protect\draw[-,dashed] (0,.5ex)--++(1,0) ;}) during trace replay; and
    dash-dotted lines (\protect\tikz[baseline]{\protect\draw[-,dashdotted] (0,.5ex)--++(1,0) ;}) during both trace recording and replay.
    During recording the trace is saved to a replay file.
    $n \geq 1$: grayed-out frontends (\protect\tikz[baseline]{\protect\draw[thin,fill=gray,fill opacity=0.2] (0,1ex) rectangle (1,0) ;}) are optional.
  }
  \end{figure}
#+END_src

*** ~cortex-m-rtic-trace~ and its application
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace
:END:
=cortex-m-rtic-trace= is an auxilliary target-side crate that configures all relevant Cortex-M peripherals for tracing, namely the [[gls:DCB]][fn:: A component of the [[gls:SCB]] peripheral.], [[gls:TPIU]], [[gls:DWT]], and [[gls:ITM]].
The crate exposes two functions:
- =cortex_m_rtic_trace::configure= :: a regular Rust function for configuration of the peripherals mentioned above; and
- =cortex_m_rtic_trace::trace= :: a Rust macro with with to trace software tasks.
Henceforth, within this section, these two functions will be referred to as =configure= and =trace=, respectively.

This section is divided into two parts: [[cref:impl:rtic-trace:peripheral-config]], which covers the application of =configure=; and [[cref:impl:rtic-trace:trace-macro]], which covers the application of the =trace= macro.

It is important to point out that =cortex-m-rtic-trace= is a crutch which incurs unecessary overhead for the end-user.
On the RTIC Scope roadmap is thus the eventual deprecation of this crate. See [[cref:fut:rm-rtic-trace]] for more on this topic.

**** Peripheral configuration
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:peripheral-config
:END:
After applying device-specific configurations for trace generation, and querying the frequency of the [[gls:TPIU]] reference clock, =configure= is applied as shown in [[cref:lst:rtic-trace:configure]].
#+NAME: lst:rtic-trace:configure
#+CAPTION: Example application of ~cortex_m_rtic_trace::configure~.
#+begin_src rust
  #[init]
  fn init(mut ctx: init::Context) -> (SharedResources, LocalResources, init::Monotonics()) {
      // device-specific configurations for trace stream generation...

      let freq = {
          // device-specific query for the TPIU reference clock
          // frequency...
      };

      use cortex_m_rtic_trace::{
          self, GlobalTimestampOptions, LocalTimestampOptions, TimestampClkSrc,
          TraceConfiguration, TraceProtocol,
      };

      // configure device-common tracing
      cortex_m_rtic_trace::configure(
          &mut ctx.core.DCB,
          &mut ctx.core.TPIU,
          &mut ctx.core.DWT,
          &mut ctx.core.ITM,
          1, // task enter DWT comparator ID
          2, // task exit DWT comparator ID
          &TraceConfiguration {
              delta_timestamps: LocalTimestampOptions::Enabled,
              absolute_timestamps: GlobalTimestampOptions::Disabled,
              timestamp_clk_src: TimestampClkSrc::AsyncTPIU,
              tpiu_freq: freq, // Hz
              tpiu_baud: 9600, // B/s
              protocol: TraceProtocol::AsyncSWONRZ,
          },
      )
      .unwrap();

      // ...
  }
#+end_src

=configure= in [[cref:lst:rtic-trace:configure]] does a number of operations in the following order:
1. <<rtic-trace:conf-protocol>> ensures that the target's [[gls:TPIU]] peripheral supports the requested =protocol= by reading the [[gls:TPIU_TYPE]] [[parencite:&arm-rm Section C1.10.6]];
2. ensures that the user did not request an invalid [[gls:TPIU]] configuration (i.e. =tpiu_freq: 0= or =tpiu_baud: 0=);
3. <<rtic-trace:conf-exception-trace>> ensures that the target's [[gls:DWT]] peripheral supports exception tracing by reading a zero from the /NOTRCPKT/ bit in the [[gls:DWT_CTRL]] [[parencite:&arm-rm Section C1.8.7]];
4. <<rtic-trace:nofail-conf>> configures the [[gls:DCB]], [[gls:TPIU]], and [[gls:DWT]] peripherals (partially):
   1. sets the /TRCENA/ bit in the [[gls:DCB_DEMCR]], a "global enable for all [[gls:DWT]] and [[gls:ITM]] features";
   2. calculates and writes a prescaler to the /SWOSCALER/ bitrange in the [[gls:TPIU_ACPR]] such that the [[gls:TPIU]] communicates with a requested baud rate.
      The prescaler is calculated via [[cref:eq:prescaler]] as derived from [[textcite:&arm-rm Section C1.10.4]].[fn:: This configuration implementation is error-prone: See [[cref:fut:swoscaler]].]
      #+NAME: eq:prescaler
      \begin{equation}
        \left\lfloor
        \frac{\texttt{tpiu\textunderscore freq}}{\texttt{tpiu\textunderscore baud}}
        \right\rfloor - 1
      \end{equation}
   3. drops any [[gls:ETM]][fn:: A debug facility similar to (but with finer granularity than) the [[gls:ITM]], but outside the scope of this thesis.] packets that the [[gls:TPIU]] receives because the utilization of these packets are outside the scope of this thesis; and
   4. sets the /EXCTRCENA/ bit in [[gls:DWT_CTRL]] which enables the generation of exception traces in the [[gls:DWT]] [[parencite:&arm-rm Section C1.8.7]].
5. <<rtic-trace:itm>> Applies [[gls:ITM]]-related options given to =configure= by writing to the [[gls:ITM_TCR]] while also checking for target support for the requested configuration [[parencite:&arm-rm Section C1.7.6]]:
   1. sets the /ITMENA/, /TXENA/, /SWOENA/, and /TSENA/ bits which enables the [[gls:ITM]], forwards trace packets from the [[gls:DWT]] to the [[gls:ITM]], "enables asynchronous clocking of the timestamp counter", and enables the generation of local timestamps, respectively;
   2. writes 0 to the /TraceBusID/ field because RTIC Scope does not support multi-source tracing within the scope of this thesis[fn:: Writing 0 to this field is potentially invalid. See [[cref:fut:TraceBusID]].]
   3. writes 0 to the /TSPrescale/ field, disabling prescaling for local timestamps; and
   4. writes 0 to the /GTSFREQ/ field, disabling global timestamps.[fn:: Global timestamps are an optional feature, and is not supported by all Cortex-M targets.]
6. <<rtic-trace:dwt>> Configures [[gls:DWT]] comparators for software task tracing:
   1. first, resolves the target addresses of two =u32= /watch variables/ which live in target memory;
   2. dereferences two [[gls:DWT]] comparators as specified by the 5th and 6th arguments to =configure= in [[cref:lst:rtic-trace:configure]];[fn:: The [[gls:API]] for specifying these comparators can be greatly improved by passing them via the =TraceConfiguration= structure. Additionally and ideally, only a single comparator would be required; see [[cref:disc:perf]].]
   3. configures the first comparator to signal a match (and generate an associated trace stream packet) when data is written to the first watch variable:
      1. writes to seven fields in the [[gls:DWT_FUNCTIONn]][fn:dwt-n] [[parencite:&arm-rm Section C1.8.17]], where $n$ is the offset of the comparator (in the context of [[cref:lst:rtic-trace:configure]], $n=1$):
         0b1101 to /FUNCTION/, configuring the comparator to match on address access;
         0 to /EMITRANGE/, disabling trace address packet generation;[fn:: We are not interested in the address that contains the watch variable.]
         0 to /DATAVMATCH/, to disable data value comparison[fn:not-of-concern];
         0 to /CYCMATCH/, to disable cycle counter comparison[fn:not-of-concern];
         and 0 to /DATAVSIZE/, /DATAVADDR0/, and /DATAVADDR1/ because these fields are [[gls:SBZ]] [[parencite:&arm-rm p. Glossary-855]] in address comparison context.
      2. writes the first watch variable address to [[gls:DWT_COMPn]][fn:dwt-n] (with $n = 1$), in order for the comparator to match on that address access; and
      3. writes 0 to [[gls:DWT_MASKn]][fn:dwt-n] ($n=1$), such that the comparator does not match on a range of addresses.
   4. Lastly, the second comparator is configured in the same manner as the first, but with the second watch variable address in mind and $n=2$.

If any step in [[crefrange:rtic-trace:conf-protocol,rtic-trace:conf-exception-trace]] fails =configure= prematurely returns an =Err(_)= that signals what went wrong, and no peripheral configuration will have been applied: the target will be in the same state as before =configure= was called.

Several fields in [[gls:ITM_TCR]] are potentially [[gls:RAZ-WI]], [[gls:RAZ]], or [[gls:RAO]] [[parencite:&arm-rm p. Glossary-854]] in order to signal hardware support.
This requires the field to be read after a write to ensure that a configuration was applied.
During the steps in [[cref:rtic-trace:itm]], if any read-back values does not match what was written, =configure= prematurely returns an =Err(_)= signalling what configuration component was not supported by the target and what components have been successfully applied, notifying the end-user that a partial configuration has now been applied.
It is up to the end-user to reset the target to the state before =configure= was called.
For a discussion on this implementation detail, see [[textcite:&issue:cortex-m:382]].

The steps in \cref{rtic-trace:nofail-conf,rtic-trace:dwt} cannot fail.

Of certain note are the steps in [[cref:rtic-trace:dwt]] because of the dependency of variables in memory to trace software tasks, and how the watch variables in this section are aligned in memory.
The [[gls:DWT]] comparators are configured to match on writes to singular addresses which are represented as =u32= variables.
However, due to performance reasons (and in order to reduce implementation complexity), the watch variables are represented as =u8= variables: only a single byte will be written to these 32-bit addresses during run-time tracing (see [[cref:impl:rtic-trace:trace-macro]]).
Further, because of time constrains no experimentation has been done with a non-zero mask: this requires the watch variables to be aligned to 32-bits. For more on the topic of performance, see [[cref:disc:perf]].

**** Tracing software tasks with ~trace~
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:trace-macro
:END:
=trace= is an optional macro that is only required if software task tracing is wanted.
Its application is trivial, but requires that =configure= executed successfully.
To trace a software task, consider [[cref:lst:rtic-trace:trace]] which defines two tasks: =task1= and =task2=.
Of the two tasks, =task2= is traced by simply decorating it with =#[trace]=, the invocation of the =trace= macro.
#+NAME: lst:rtic-trace:trace
#+CAPTION: Application example of the ~trace~ macro. ~task2~ is traced; ~task1~ is not.
#+begin_src rust
  // ...

  use cortex_m_rtic_trace::{self, trace};

  #[task]
  fn task1(_: task1::Context) {}

  #[task]
  #[trace]
  fn task2(_: task2::Context) {}

  // ...
#+end_src

Consider now [[cref:lst:rtic-trace:trace-expanded]], which is the result of expanding the macros applied in [[cref:lst:rtic-trace:trace]] via =cargo-expand= [[parencite:&cargo-expand]].
#+NAME: lst:rtic-trace:trace-expanded
#+CAPTION: Application example of the ~trace~ macro after macro expansion via ~cargo-expand~. Unrelated expansions omitted.
#+begin_src rust
  // ...
  use cortex_m_rtic_trace::{self, trace};
  // ...
  #[allow(non_snake_case)]
  fn task1(_: task1::Context) {
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
  }
  #[allow(non_snake_case)]
  fn task2(_: task2::Context) {
      ::cortex_m_rtic_trace::__write_enter_id(0);
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
      ::cortex_m_rtic_trace::__write_exit_id(0);
  }
  // ...
#+end_src

A traced software task then writes its unique ID to two watch addresses that signify that a task was entered or exited.

*** Recording a trace
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope
:END:
=cargo-rtic-scope= is a host-side daemon that fulfills [[crefrange:req:input,req:protocol]] and [[crefrange:req:record,req:cargo]].
It is run as a =cargo= subcommand, as seen in [[cref:lst:cargo-rtic-scope:summary]], where =<verb>= is either =trace= or =replay=.
As the verbs imply, =trace= is used to trace the execution of an RTIC application on the target and =replay= is used to replay a trace for post-mortem analysis.
#+NAME: lst:cargo-rtic-scope:summary
#+CAPTION: Summary of ~cargo-rtic-scope~ invocation.
#+begin_src shell
  $ cargo rtic-scope [options...] <verb> [options...]
#+end_src

This section covers the options and implementation of the =trace= verb.

**** Section overview
The implementation responsible for recording and presenting a trace to the end-user is covered in 10 parts.
These parts are enumerated below.

1. Building the RTIC application, [[cref:impl:cargo-rtic-scope:building-rtic-app]].
2. Reading options from the cargo maniest, [[cref:impl:cargo-rtic-scope:read-manifest]].
3. Creating a trace file, [[cref:impl:cargo-rtic-scope:create-trace-file]].
4. Generating metadata maps, [[cref:impl:cargo-rtic-scope:generating-metadata-maps]].
5. Spawning frontends, [[cref:impl:cargo-rtic-scope:spawning-frontends]].
6. Reading the trace from the target, [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]].
7. Flashing the target, [[cref:impl:cargo-rtic-scope:flash-target]].
8. Flushing trace metadata to file, [[cref:impl:cargo-rtic-scope:flush-metadata]].
9. Resetting the target, [[cref:impl:cargo-rtic-scope:reset-target]].
10. Tracing the target, [[cref:impl:cargo-rtic-scope:trace-target]].

**** Building the RTIC application
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:building-rtic-app
:END:
The first step is to build the RTIC application the end-user wants to trace.
This is done as a preparatory stage for [[crefrange:impl:cargo-rtic-scope:generating-metadata-maps,impl:cargo-rtic-scope:create-trace-file]] and [[cref:impl:cargo-rtic-scope:flash-target]];
and logically, if the application cannot be built, it cannot be traced so the process should prematurely end.
An additional side-effect of building the RTIC application is the possibility of executing =cargo rtic-scope trace= like one would execute =cargo run=.

The application is built via [[cref:lst:cargo-rtic-scope:build]] by the =trace= verb, where =OPTIONS= are optional additional flags to forward to =cargo build= from the invocation of =cargo rtic-scope trace=.
#+NAME: lst:cargo-rtic-scope:build
#+CAPTION: The build process of RTIC Scope. ~OPTIONS~ is a set of additional flags potentially forwarded by ~cargo-rtic-scope~.
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi [OPTIONS...]
#+end_src
For example, if the crate would yield multiple binaries on build, =cargo rtic-scope trace= must know the singlar binary which the end-user wants to trace.
Specifying this flag is done in the same way as for =cargo build=: via =--bin=.
[[cref:lst:cargo-rtic-scope:build-bin]] contains an example use of this option, which would yield the =cargo build= invocation in [[cref:lst:cargo-rtic-scope:build-bin-forwarded]].
#+NAME: lst:cargo-rtic-scope:build-bin
#+CAPTION: Invocation of ~cargo rtic-scope trace~ with the optional ~--bin~ option which is forwarded to the underlying ~cargo build~ invocation, where ~OPTIONS~ is a set of additional flags and/or options potentially set by the end-user; not all of which are necessarily forwarded.
#+begin_src shell
  $ cargo rtic-scope trace --bin my-rtic-application [OPTIONS...]
#+end_src
#+NAME: lst:cargo-rtic-scope:build-bin-forwarded
#+CAPTION: The underlying ~cargo build~ invocation as a result of executing [[cref:lst:cargo-rtic-scope:build-bin]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application [OPTIONS...]
#+end_src

Below are a description of the flags and options the end-user can specify during the invocation of =cargo rtic-scope trace= (in the same manner as =cargo build=) that are forwarded to the underlying =cargo build= invocation in [[cref:lst:cargo-rtic-scope:build]].
- =--bin <binary>= :: Used to specify which singlar binary to build.
- =--example <example>= :: Used to build a singular example binary instead of a non-example binary.
- =--package <package>= :: Used to build a crate instead of a singlar binary inside of a crate.
  This crate should yield a single binary.
- =--release= :: Used to build the binary in release mode instead of debug mode. Optimizations are applied during build with this flag.
- =--target <target-triple>= :: Used to specify the target platform for which the binary should be built for. This option can be used to override the default target triple, or the one specified via the =/.cargo/config{,toml}= files.
- =--manifest-path <path>= :: Used to override the default path to the =cargo= manifes, =Cargo.toml=.
- =--no-default-features= :: Used to disable all default features of the crate that contains the singular binary.
- =--all-features= :: Used to enable all features of the crate that contains the singular binary.
- =--features <feat1>[,feat2[,feat3[...]]]= :: Used to specify the set of features to enable of the crate that contains the singular binary.

The above flags and options were deemed as the most common flags an end-user would want to specify when building the RTIC application.
If the user wants to specify an option or flag that is not among the above set the sentinel =--= can be used.
For example, if the user invokes [[cref:lst:cargo-rtic-scope:sentinel]], =cargo-rtic-scope= invokes [[cref:lst:cargo-rtic-scope:sentinel-forwarded]].
#+NAME: lst:cargo-rtic-scope:sentinel
#+CAPTION: Example ~cargo rtic-scope trace~ incovation with an arbitrary ~cargo build~ argument.
#+begin_src shell
    $ cargo rtic-scope trace --bin my-rtic-application [OPTIONS...] -- --some-cargo-build-flag
#+end_src
#+NAME: lst:cargo-rtic-scope:sentinel-forwarded
#+CAPTION: Resulting ~cargo build~ incovation on [[cref:lst:cargo-rtic-scope:sentinel]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application [OPTIONS...] --some-cargo-build-flag
#+end_src
This approach ensures that the end-user can always build the RTIC application with any set of valid =cargo build= flags and options.

The effect of building the binary with =--message-format=json-diagnostic-rendered-ansi= is that the otherwise human-readable output of =cargo build= is instead in [[gls:JSON]], a machine-readable format.
This JSON output describes all artifacts that are built, including the singular binary that the end-user wants to trace, for which =cargo build= tells us the path to the built binary used to flash the target in [[cref:impl:cargo-rtic-scope:flash-target]];
the path to the root of the crate that this binary lives, used in [[cref:impl:cargo-rtic-scope:create-trace-file]];
and the path to the source file of this binary, used in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]].

The JSON is not parsed directly, but via =cargo_metadata= [[parencite:&cargo-metadata]].

**** Reading options from the ~cargo~ manifest
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:read-manifest
:END:
The operation of =cargo rtic-scope trace= requires some information about the RTIC application from the end-user.
These are specified in the metadata block of the crate's manifest, =Cargo.toml=.
One may for example write the information in [[cref:lst:cargo-rtic-scope:manifest-metadata-example]].
#+NAME: lst:cargo-rtic-scope:manifest-metadata-example
#+CAPTION: Example of required user-supplied information in crate manifest, ~Cargo.toml~.
#+begin_src toml
  [package.metadata.rtic-scope]
  pac_name = "atsamd51n"
  pac_features = []
  pac_version = "0.11"
  interrupt_path = "atsamd51n::Interrupt"
  tpiu_freq = 12000000
  tpiu_baud = 1000000
  dwt_enter_id = 1
  dwt_exit_id = 2
  lts_prescaler = 1
  expect_malformed = false
#+end_src
Of these fields the below are utilized in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]]:
- =pac_name=,
- =pac_features=,
- =pac_version=,
- =interrupt_path=,
- =dwt_enter_id=,
- =dwt_exit_id=;
and the below fields are utilized in  [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]] and  [[cref:impl:itm]]:
- =tpiu_freq=,
- =tpiu_baud=,
- =lts_prescaler=.
The last flag, =expect_malformed= is a debug option utilized in [[cref:impl:cargo-rtic-scope:trace-target]].
For a description of each field, see the respective sections.

The fields of information in [[cref:lst:cargo-rtic-scope:manifest-metadata-example]] are read from =Cargo.toml= by help of =cargo_metadata= [[parencite:&cargo-metadata]] and =serde_json= [[parencite:&serde-json]].

**** Creating a trace file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:create-trace-file
:END:
To enable post-mortem analysis of a traced RTIC application the recorded trace must be saved to disk.
The build step (see [[cref:impl:cargo-rtic-scope:building-rtic-app]]) yields the crate root of the traced application.
A natural directory in which to save trace files is then under =/target/= which contains all build artifacts of the crate.
For purposes of separation trace files are then saved under the =rtic-traces= sub-directory; the full path to this directory is then =/target/rtic-traces/=.
While this directory is meant for ephemeral artifacts (of which recorded traces may not belong) it was the simplest approach to associate traces to a particular crate (including its git revision; see below) while also not writing files to a wholly unexpected directory (e.g. the crate root directory).

Of note is that =/target/= is removed if =cargo clean= is executed.
It is thus up to the RTIC Scope user to ensure that traces of interests are saved to a persistent location.
For this purpose the optional =--trace-dir <dir>= option overrides the output directory of the trace files.

The trace filename contains three sections of information:
- the name of the RTIC application :: which associates the trace with the application that generated it, useful when a crate contains more than one application.
- the git revision of the local repository :: to associate the trace with the source code of the traced RTIC application; and
- a second-accurate timestamp :: to associate the trace with target-external events (e.g. conditions of the physical environment in which the application is traced).

For example, after some tracing and development during January 13th and 14th, 2022, the trace directory could for example contain the files in [[cref:lst:cargo-rtic-scope:trace-example-files]].
#+NAME: lst:cargo-rtic-scope:trace-example-files
#+CAPTION: Example of trace filenames after two traces. ~blinky~ is the name of the RTIC application binary; ~124b3c5~ the git revision; and the remainder (sans ~.trace~) is the timestamp of the trace. The second trace file was recoded from an RTIC application with uncommitted changes, hence the ~-dirty~ suffix to the git revision.
#+begin_src text
  $ ls -ogh target/rtic-traces
  total 8.0K
  -rw-r--r-- 1 1.5K Jan 13 16:54 blinky-g124b3c5-2022-01-13T16:54:00.trace
  -rw-r--r-- 1 1.3K Jan 14 18:38 blinky-g124b3c5-dirty-2022-01-14T18:37:57.trace
#+end_src

In case two =cargo rtic-scope trace= instances are executed within the span of one second without any changes to the git repository the same trace filename will be generated twice; this will be caught by the second instance which will exit with an error[fn:: A virtual limitation. The timestamp granularity can be increased, but from a user standpoint it is unlikely to start a trace twice within the same second unless two targets are traced at the same time with the same application.]:
=cargo-rtic-scope= cannot overwrite trace files.
Trace files can however be explicitly deleted:
if the user wants to record a trace and remove all previously recoded traces in the trace directory =--clear-traces= can be specified.
This flag only deletes files with the =.trace= file extension.

**** Generating metadata maps
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:generating-metadata-maps
:END:
# Introduction: we must translate raw ITM data to RTIC run-time information.
As covered in [[cref:theory:itm-proto]], the [[gls:ITM]] packet protocol is used to trace [[gls:RTIC]] tasks.
This protocol is not designed with RTIC in mind:
instead of information that can be directly associated to an RTIC tasks the protocol tells us the number of the [[gls:DWT]] comparator that signaled a write to a watch address along with the data written, used to signal a software task enter or exit;
and the IRQ number of the interrupt handler that entered, exited or was returned to, used to signal a hardware task enter or exit.
These pieces of information must be associated back to the RTIC tasks responsible for their emission in a preparatory /recovery step/.
This section covers this step which is divided into two parts:
1. the generation of the =recovery::HardwareMap= for hardware tasks associations, [[cref:impl:hardware-map]]; and
2. the generation of the =recovery::SoftwareMap= for software tasks associations, [[cref:impl:software-map]].
Together these two lookup maps constitute the full =recovery::TraceLookupMaps= which is used by =recovery::TraceMetadata= in order to fulfill Requirement [[req:rtic]].

***** Generating the ~recovery::HardwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:hardware-map
:END:
# Overview: what to we need?
In order to generate a =recovery::HardwareMap= the RTIC application declaration must be parsed.
This is already done when the RTIC application is built in [[cref:impl:cargo-rtic-scope:building-rtic-app]] when the =rtic::app= macro is expanded via =rtic_syntax::parse{,2}= [[parencite:&rtic]].
This expansion operation yields an =rtic_syntax::App= [[parencite:&rtic-syntax]] used internally to verify the application declaration and yield the expanded code.
This structure contains all the information =cargo rtic-scope trace= requires (see below) but is not emitted during the building step.
This requires the application declaration to be parsed an additional time which requires knowledge about the location of the source code file.
This knowledge is acquired in [[cref:impl:cargo-rtic-scope:building-rtic-app]].

# We must the source for the ASTs
In order to generate a =rtic_syntax::App= for recovery purposes =rtic_syntax::parse2= must be called directly with the arguments of =#[rtic::app(..)]= and with the input to the macro.
For example, in [[cref:lst:recovery-example]], =device = stm32f4::stm32f401= is the macro arguments, and =mod app { ... }= is the macro input.
Note the preamble on lines 1--3.
These must be skipped in order to parse correctly.
#+CAPTION: Example RTIC application declaration for execution on the STMicroelectronics STM32 NUCLEO-F401RE that can be parsed by ~cargo-rtic-scope~.
#+NAME: lst:recovery-example
#+begin_src rust
  #![no_main]
  #![no_std]

  #[rtic::app(device = stm32f4::stm32f401)] // tokens are skipped until this line is found
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[task(binds = SysTick)]
      fn task1(_: task1::Context) {
          // ...
      }

      #[task(binds = EXTI1)]
      fn task2(_: task2::Context) {
          // ...
      }
  } // this must be the last line of the file
#+end_src

In order to isolate the =#[rtic::app(...)] mod app { ... }= section in [[cref:lst:recovery-example]] the =std::String= that represents the content of the source file must be converted to an [[gls:AST]];
or more specifically, a =proc_macro2::TokenStream2= [[parencite:&proc-macro2]].
This is done by help of the =syn= crate [[parencite:&syn]].

With a =TokenStream2= structure in hand [[glspl:token][tokens]] are skipped until the =proc_macro2::TokenTree::Group(_)= that contains =#[rtic::app(...)]= is found ([[cref:lst:recovery-example]], line 4).
The remainder of the source file is then assumed to be the =mod app { ... }= input to the =rtic::app= macro.

This places a few restrictions[fn:: The keywords *MUST* and *MUST NOT* shall be interpreted as described in [[textcite:&rfc2119]].] on how the RTIC application can be declared to be properly parsed:
1. tasks *MUST NOT* be externally declared;
2. the =rtic::app= macro *MUST* be called via =#[rtic::app]= (e.g. [[cref:lst:invalid-recovery-example]] will fail to parse); and
3. the =mod app { ... }= [[gls:token]] group terminator *MUST* be the last line of the source file ([[cref:lst:recovery-example]], line 27).
More restrictions that have yet to be discovered may apply.
#+NAME: lst:invalid-recovery-example
#+CAPTION: Valid RTIC application declaration that cannot be parsed by ~cargo rtic-scope trace~.
#+begin_src rust
  // ...
  use rtic::app;

  #[app(device = stm32f4::stm32f401)] // will not parse: #[rtic::app] must be used
  mod app {
      // ...
  }
#+end_src

# known and unknown maps
At this point we have the necessary =rtic_syntax::App= structure to continue: =App::hardware_tasks= is a collection of multiple =rtic_syntax::HardwareTask= that lists what interrupt handler each hardware task is bound to via the =binds= argument in =#[task(binds = ...)]=.
After parsing [[cref:lst:recovery-example]], =hardware_tasks= contains [fn:: Abstracted for brevity.]
#+begin_export latex
$$
\langle \text{\texttt{app::task1} binds to \texttt{SysTick}} \rangle,\quad\langle \text{\texttt{app::task2} binds to \texttt{EXTI1}} \rangle\text{.}
$$
#+end_export
Of these, the =app::task1= bind is considered /known/, and the =app::task2= bind is considered /unknown/.
A known bind is one that no more recovery work must be applied on.
This follows from [[cref:tbl:irqns]] in [[cref:theory:itm-proto]] which enumerates all numbers that can be in the packet's IRQ field:
All
#+begin_export latex
$$
\text{IRQn} < 16
$$
#+end_export
are common to all ARMv7-M targets, the name of which can be directly mapped to the RTIC task that binds the IRQ name.
All
#+begin_export latex
$$
\text{IRQn} \geq 16
$$
#+end_export
on the other hand, are not common to all ARMv7-M, and are thus platform-specific because the labels (specified via =#[task(binds = ...)]=) are unknown.
Additional recovery must be done to find these labels.

# PAC::Interrupt and known/unknown partitioning; Rust reflection woes
For any RTIC application, the labels of unknown binds are available in the =PAC::Interrupt= enum. For [[cref:lst:recovery-example]], =PAC= is =stm32::stm32f401=.
See [[cref:background:PAC]] for an example of such an enum.
By finding the label used in =#[task(bind = ...)]= in =PAC::Interrupt= we find what enum constructor to use.
With the enum in hand, we construct it and get the IRQ number offset $N$ via [[cref:lst:pac:extirq]].
#+NAME: lst:pac:extirq
#+CAPTION: Finding $N$ in [[cref:tbl:irqns]] for an external interrupt via the \glsxtrfull{PAC}.
#+begin_src rust
  let label = PAC::Interrupt::EXTI1;
  assert_eq!(label.number(), 7);
#+end_src
To get the IRQ number of this unknown bind we simly sum it with $16$, as documented by [[cref:tbl:irqns]], via [[cref:lst:pac:irqsum]].
#+NAME: lst:pac:irqsum
#+CAPTION: Finding the IRQ number of an external interrupt by summing the offset documented by [[cref:tbl:irqns]].
#+begin_src rust
  let irq_nr = label.number() + 16;
  assert_eq!(irq_nr, 23);
#+end_src
This must be done for all unknown binds.

The above process is unfortunately non-trivial: Rust does not have dynamic programming features and an ideal evaluation function such as [[cref:lst:pac:ideal-pseudo]] is not realizeable.
#+NAME: lst:pac:ideal-pseudo
#+CAPTION: Non-realizeable pseudo code to dynamically resolve the IRQ number of an unknown bind via the \glsxtrfull{PAC}. ~quote~ is from [[textcite:&quote]].
#+begin_src rust
  use quote::quote;
  fn resolve_irq_nr(label: &str) -> u16 {
      quote!(PAC::Interrupt::$label).eval().number() + 16;
  }
#+end_src

# libadhoc
Enter =recovery::resolve_int_nrs=: given a list of labels, the function
1. extracts an embedded file tree constituting a skeleton crate to the RTIC application's =target/cargo-rtic-trace-libadhoc=, by help of [[textcite:&includedir]];
2. writes the user-specified [[gls:PAC]] dependency into this crate's =Cargo.toml=[fn:: By use of the =pac_name=, =pac_version=, =pac_features=, and =interrupt_path= acquired from [[cref:impl:cargo-rtic-scope:read-manifest]].];
3. for each label: writes a non-[[gls:manglfn][mangled function]] with the same name as the label that returns the associated IRQ number offset, $N$ (for [[cref:lst:recovery-example]] the generated recovery code can be seen in [[cref:lst:resolve_int_nrs-example]]), to =lib.rs=;
   #+NAME: lst:resolve_int_nrs-example
   #+CAPTION: Generated IRQ number recovery functions for [[cref:lst:recovery-example]] with ~interrupt_path = "st32::stm32f401::Interrupt"~ from the \glsxtrfull{RTIC} application's ~Cargo.toml~.
   #+begin_src rust
     use stm32::st32f401::Interrupt;

     #[no_mangle]
     pub extern fn EXTI1() -> u16 {
         Interrupt::EXTI0.number()
     }
   #+end_src
4. builds the crate as a [[gls:cdylib][cdylib crate]];
5. loads the library into memory;
6. for each label: calls the associated function in the library to get the offset $N$ and sums it with 16; and
7. collects the results.
This collection then merges with the collection of known maps.

***** Generating the ~recovery::SoftwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:software-map
:END:
The work to generate a =recovery::SoftwareMap= is similar to that of a =recovery::HardwareMap= in the sense that the RTIC application declaration must be parsed again (for a third, but last time).
This parsing pass is done via =SoftWareMap::parse_ast= instead of =rtic_syntax::parse2=.
As the function name implies the [[gls:AST]] is parsed by skipping [[glspl:token][tokens]] until the =TokenTree::Group(_)= describing =#[trace]= is found.
When this [[gls:token]] is found the software task the macro is used on is associated with the current value of an internal counter for software task IDs.
This counter is modified in the same manner as the internal counter when =cortex_m_rtic_trace::trace= expands.

To complete the =SoftwareMap= the IDs of the [[gls:DWT]] comparators and the interrupts which handle the dispatch of the application's software tasks must be recorded.
The former are acquired from  [[cref:impl:cargo-rtic-scope:read-manifest]] via the =dwt_enter_id= and =dwt_exit_id= fields.
The latter are acquired via =rtic_syntax::ast::AppArgs::extern_interrupts=.

For the example in [[cref:lst:rtic-scope:trace-software-task]], =SoftwareMap= would contain[fn:: Abstracted for brevity.] the information denoting =EXTI2= as the software task dispatcher and
#+begin_export latex
$$
\langle 0 \equiv \text{\texttt{app::task1}}\rangle,\quad\langle 1 \equiv \text{\texttt{app::task2}} \rangle\text{.}
$$
#+end_export
#+NAME: lst:rtic-scope:trace-software-task
#+CAPTION: RTIC application declaration with two traced software tasks: ~app::task1~ and ~app::task2~. ~EXTI2~ is declared as the software task dispatcher.
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXTI2])]
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[trace] // task ID = 0
      #[task]
      fn task1(_: task1::Context) {
          // ...
      }

      #[trace] // task ID = 1
      #[task]
      fn task2(_: task2::Context) {
          // ...
      }
  }
#+end_src

The restrictions enumerated in [[cref:impl:hardware-map]] also apply when recovering information for traced software tasks.

The =trace= macro can also be applied on regular functions, effectively allowing the end-user to trace subsections of both software and hardware tasks; see [[cref:impl:nested-tracing]] for an example.
Severe limitations apply when tracing functions inside tasks and are thus not useful in practise.
See [[cref:disc:nested-tracing-restrictions]] for more on this topic.
#+NAME: impl:nested-tracing
#+CAPTION: Tracing a function inside of a traced software example.
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXIT2])]
  mod app {
      // ...

      #[trace]
      #[task]
      fn task1(_: task1::Context) {
          // ...

          #[trace]
          fn nested() {
              // ...
          }
      }
  }
#+end_src
**** Spawning frontends
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:spawning-frontends
:END:
The host-side of RTIC Scope is divided into two parts: the backend, =cargo-rtic-scope=;
and the frontends, of which =rtic-scope-frontend-dummy= is provided within the scope of this thesis, fulfilling Requirement [[req:dummy]] and also acting as the frontend reference implementation (see [[cref:impl:rtic-scope-frontend-dummy]]).
Frontends are separate processes that receive JSON messages from the backend over a local socket connection.
This section covers how frontends are specified, found in the environment, and executed.

The set of frontends to spawn is specified with the =--frontend= option before the =<verb>= in [[cref:lst:spawn-frontend]].
#+NAME: lst:spawn-frontend
#+CAPTION: Starting the RTIC Scope backend with an explicit frontend.
#+begin_src shell
  $ cargo rtic-scope --frontend=rtic-scope-frontend-dummy <verb> [OPTIONS...]
#+end_src
Multiple frontends (or multiple instances of a single frontend) can be spawned by specifying the =--frontend= option multiple times.
By default (by not specifying the option) a single instance of =rtic-scope-frontend-dummy= is spawned.

=cargo-rtic-scope= searches for frontends in three locations in the environment.
With =--frontend=rtic-scope-frontend-dummy= the search pattern in decreasing order of priority is
1. in the =PATH= [[gls:envvar][environmental variable]];
2. the relative path: =./rtic-scope-frontend-dummy=; and
3. the absolute path: =/rtic-scope-frontend-dummy=.
If a higher priority location is valid, the search ends.
[[cref:lst:spawn-frontends]] contains an example of spawning three frontends in each of the supported location types.
#+NAME: lst:spawn-frontends
#+CAPTION: Starting the RTIC Scope backend with three explicit frontends: one in ~PATH~, one relative, and one absolute.
#+begin_src shell
  $ cargo rtic-scope --frontend=frontend-in-PATH \
                     --frontend=./path/to/relative/frontend \
                     --frontend=/path/to/absolute/frontend \
                     <verb> [OPTIONS...]
#+end_src

In RTIC Scope v0.3.1, a frontend takes zero arguments and *MUST* return a path to a Unix socket on [[gls:stdout]] which the backend can use to communicate with the frontend.
**** Sourcing the trace stream from the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reading-the-trace-stream
:END:
# Introduce the two main sources
At this point a line of communication with the target must be established.
Internally, this line of communication is known as a /source/ of which only one is established before =cargo-rtic-scope= traces the target.
As of v0.3.1 two sources are implemented:
- a TTY/serial source :: which configures and reads the trace data from a serial device; and
- a probe source :: wherein =probe-rs= [[textcite:&probe-rs]] is used to read trace data from supported targets.

A serial source is used if =--serial= is specified to the =trace= verb.
When a serial source is used =cargo-rtic-scope= must know what baud rate to configure the device for.
This is specified via the =tpiu_baud= field in the crate manifest (see [[cref:lst:cargo-rtic-scope:manifest-metadata-example]]) but can also be overridden via the =--tpiu-baud= option.
See [[cref:lst:tty-source]] for an example of these options.
#+NAME: lst:tty-source
#+CAPTION: Tracing a target by reading the trace stream from a serial device at ~/dev/ttyUSB3~ at 115200 bauds.
#+begin_src shell
  $ cargo rtic-scope trace --serial /dev/ttyUSB3 --tpiu-baud 115200 [OPTIONS...]
#+end_src

A probe source is used if =--serial= is not specified.
=cargo-rtic-scope= will then use the first probe it can find on the system.
If multiple probes are attached =--probe VID:PID[:Serial]= can be used to specify one.
A list of connected and supported probes can be queried by specifying the =--list-probes= flag.

When the target is traced in [[cref:impl:cargo-rtic-scope:trace-target]] the trace stream is simply read from the serial device if one is used.
If a probe source is used =probe-rs= sends the appropriate commands to the used probe polling for available trace data.
**** Flashing the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flash-target
:END:
If the target under trace is supported by =probe-rs= it can optionally be flashed before tracing begins.
This is the default behavior in order to simplify an iterative development process but can be disabled by specifying the =--dont-touch-target= flag to the =trace= verb.
If a chip is supported =cargo-rtic-trace= must know its memory layout for flashing.
This is done via the =--chip= option.
See the example in [[cref:lst:chip-opt-example]].
#+NAME: lst:chip-opt-example
#+CAPTION: Flashing and tracing an STMicroelectronics STM32 NUCLEO-F401RE.
#+begin_src shell
  $ cargo rtic-scope trace --chip stm32f401ret [OPTIONS...]
#+end_src

The list of chips that =probe-rs= supports can be queried by specifying the =--list-chips= to the =trace= verb.

**** Flushing trace metadata to file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flush-metadata
:END:
The next step is flushing all metadata related to the trace to the replay file created in [[cref:impl:cargo-rtic-scope:create-trace-file]].
The metadata is contained in a =recovery::TraceMetadata= structure, listed and described in [[cref:lst:TraceMetaData]].
Of these fields
- =maps: TraceLookupMaps= :: is described in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]];
- =reset_timestamp= :: is an approximate reset timestamp (the target is actually reset after this structure has been flushed to file, in [[cref:impl:cargo-rtic-scope:reset-target]]); and
- =comment= :: is an optional comment describing the trace which is supplied via the =--comment= option to the =trace= verb.
The data that is flushed to file is a JSON-representation of the structure, serialized by help of =serde_json= as implied by the derivation of the =Serialize= and =Deserialize= traits [[parencite:&serde-json]].
#+NAME: lst:TraceMetaData
#+CAPTION: ~recovery~ structure containing all metadata related to a trace.
#+begin_src rust
  /// Contains all metadata for a single trace.
  #[derive(Clone, Serialize, Deserialize)]
  pub struct TraceMetadata {
      /// Name of the RTIC application that was/is traced.
      pub program_name: String,

      /// Lookup maps for data received over ITM to RTIC application idents.
      maps: TraceLookupMaps,

      /// Timestamp of target reset, after which tracing begins.
      ///
      /// Note: this timestamp is sampled host-side and is approximate.
      reset_timestamp: chrono::DateTime<Local>,

      /// Frequency of the target TPIU clock. Used to generate absolute
      /// timestamps. Set via `tpiu_freq` in
      /// `[{package,workspace}.metadata.rtic-scope]` from `Cargo.toml` or
      /// overridden via the `--tpiu-freq` trace option.
      tpiu_freq: u32,

      /// Optional comment of this particular trace.
      pub comment: Option<String>,
  }
#+end_src

This structure is later read back for trace replay in [[cref:impl:cargo-rtic-scope:replay]].
**** Resetting the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reset-target
:END:
The last step before tracing the target is optionally resetting it.
This is the default behavior but can be disabled by specifying the =--dont-touch-target= flag to the =trace= verb.
Resetting the target causes it to begin executing the flashed application from the beginning.
If =--dont-touch-target= was not specified the executing application will be the flashed RTIC application.

From this point on the target will generate and emit [[gls:ITM]] packets.

**** Tracing the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:trace-target
:END:
With all the preparatory steps concluded and the target being (optionally) reset its up to =cargo-rtic-scope= to record these packets host-side.
This is done in a number of steps in the imaginatively named =run_loop= function:
1. A [[gls:sigint][SIGINT handler]] is installed, which allows the end-user to terminate =cargo-rtic-scope=.
   If this signal is not eventually sent =cargo-rtic-scope= will never terminate.
2. A second [[gls:thread]] is spawned with the mission of polling trace data from the source.
   In order to avoid the generation of overflow packets the thread should poll data as fast as possible.
   The easiest implementation to accomplish this is via a separate thread.
3. In a loop:
   1. Asynchronously polls any buffered trace data from the separate thread and the eventual SIGINT signal for a duration of 100ms.
      If trace data has been read, forward this to the aply named =handle_packet= function (see below).
      If SIGINT is received the loop breaks and =cargo-rtic-trace= terminates.
      If after 100ms nothing happens:
   2. a message from the spawned frontends is read (if any) and echoed as an error;
   3. a message of the tracing status is echoed.
      This status message describes:
      - the application under trace;
      - how many ITM packets that have been recorded;
      - how many of these packets that are /malformed/ or /unmappable/[fn:: See [[cref:impl:itm]].];
      - for how long the application has been traced;
      - how many ITM packets per second that are being recorded; and
      - how many /sinks/ that are operational (not marked as broken; see below).

=handle_packet= handles a single =TimestampedTracePacket= (henceforth referred to as a /packet chunk/).
This is done several steps:
1. first, the packet chunk is converted to an =api::EventChunk= via =TraceMetadata::build_event_chunk= (see below).
2. Any unmappable, unknown, or invalid packets ITM packets in the chunk are echoed as warnings to the end-user with an apt message.
3. Chunks are /drained/ to all /sinks/ (the replay file and all spawned frontends).
   If a drain fails for any sink, it is marked as broken and an error is echoed to the end-user.
   As long as at least one sink is not marked as broken, tracing continues.
   If all sinks are marked as broken =cargo-rtic-scope= terminates with an error.

=TraceMetadata::build_event_chunk= is responsible for recovering RTIC application metadata for a packet chunk.
This is done by matching all =itm::TracePacket= structures in the chunk: If a packet in the chunk is
- a synchronization packet (=TracePacket::Sync=), it is ignored because it does not contain any trace information;
- an exception trace packet (=TracePacket::ExceptionTrace=), the lookup maps generated in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]] are consulted for the task matching the packet's IRQ number.
  If the exception trace corresponds to a hardware task, an =api::EventType::Task= is constructed.
  If the trace corresponds to a software task dispatcher or a Thread mode enter/exit it is ignored because it contains redundant trace information.
  If none of these predicates are true the trace is logged as an unmappable event by the construction of an =api::EventType::Unmappable=.
- If the chunk packet is a data trace value (=TracePacket::DataTraceValue=), the lookup maps are again consulted:
  if the comparator ID in the packet matches either =dwt_enter_id= or =dwt_exit_id= then the trace is a software task event.
  The packet's data value is matched against the set of RTIC application tasks decorated with =#[trace]=.
  If such a match exists, an =api::EventType::Task= is constructed, otherwise the trace is logged as an unmappable event.
If none of the above predicates were true, the chunk packet is logged as an unknown packet by wrapping it in an =api::EventType::Unknown=.
Last of all are the malformed packets: these are simply wrapped in an =api::EventType::Invalid=.

*** Decoding the ITM packet stream via ~itm~
:PROPERTIES:
:CUSTOM_ID: impl:itm
:END:
The =itm= library crate, [[textcite:&itm]], is
#+ATTR_LATEX: :environment quotation
#+begin_quote
\noindent
A decoder for the [[gls:ITM]] and [[gls:DWT]] packet protocol[fn:: [[gls:DWT]] packets (hardware event packets) are included in the [[gls:ITM]] packet protocol standard.] as specifed in [[[textcite:&arm-rm Part D4]]].

Aside from covering the entirety of the protocol, this crate offers two iterators which reads data from the given [\textttBreak{std::io::Read}] instance:
- [\texttt{iter::Singles}] :: which decodes each packet in the stream in sequence, yielding [\textttBreak{TracePacket} structures].
- [\texttt{iter::Timestamps}] :: which continuously decodes packets from the stream until a local timestamp is encountered,
  yielding \linebreak[4] [\texttt{TimestampedTracePackets} structures],
  which contains a \linebreak[4] [nanosecond-accurate] timestamp relative to trace reset of when the packets where generated target-side.
#+end_quote

While the implementation of =itm= has been influenced by the development of RTIC Scope it is logically disjoint from the the RTIC Scope feature set.
=itm= can thus be considered a wholly separate project but its inception was a precursor to RTIC Scope in order to fulfill Requirement [[req:decode]], and it is thus within the scope of this thesis.
RTIC Scope is then considered a downstream crate of =itm=, because it depends on it.

The crate is a /green-field implementation/ of its deprecated v0.3 release branch, [[textcite:&itm-old]], of which this v0.7 (and above) release branch is only trivially influenced[fn:: Namely the implementation of the =std::io::Read= trait.].
Another =itm=-downstream crate is =itm-decode= [[parencite:&itm]] which aims to eventually replace the also deprecated (intepreted as such; not explicitly stated as of writing) =itm-tools= [[parencite:&itm-tools]], but that task is outside the scope if this thesis (see [[cref:fut:itm-tools]]).
Both =itm-decode= and =itm-tools= are convenient UNIX-like tools for decoding the ITM packet protocol.

=itm= is a packet decoder with state that handles its own data input.
After constructing a new decoder via =itm::Decoder::new= with an implementation of =std::io::Read= ---
e.g. a =std::fs::File= pointing to a preconfigured serial device, or a =probe_rs::architecture::arm::swo::SwoReader= ---
decoded packets are trivially acquired via the exposed iterators summarized above.
RTIC Scope utilizes the =iter::Timestamps= iterator, and is thus the only iterator covered in this text.

As covered in [[cref:theory:itm-proto]], the [[gls:ITM]] packet protocol define packets that contain a one-byte /header/, which describes what type of data a certain packet contains; how long the packet /payload/ is, a byte multiple; and the packet payload.
Effectively, the protocol follows a [[gls:TLV]] encoding sheme.
Decoding such a protocol is rather trivial, especially in Rust:
the individual bytes of the header are pattern-matched in order to decode the packet type after which the remaining bytes are dispatched to another pattern-matcher in order to decode its payload.
On success an =itm::TracePacket= is emitted.
On failure --- if a header or payload contains data that is not covered by [[textcite:&arm-rm Part D4]] --- an =itm::MalformedPacket= is emitted, describing why the decode failed.

=iter::Timestamps= intercepts all global and local timestamps in order to maintain a monotonically increasing duration from when the reference clocks start ticking.
Logically, this duration is initially zero, before any timestamp packets have been decoded.
When a local timestamp is intercepted, its value is added to the current duration and its quality recorded.
When a global timestamp is intercepted, the duration is reset to this value, discarding information from previously received timestamps.

Any non-timestamp packets will be buffered until a local timestamp is intercepted after which they will be associated to this latest timestamp in an emitted =TimestampedTracePackets=.
This structure also contains a field describing how many [[gls:ITM]] packets were consumed to generate it.
This information is used in =cargo-rtic-scope= in order to report the number of trace packets received per second.

# XXX qualitative/quantitive? Am I formulating correctly here?
The maintained and emitted durations are structures with a qualitative unit that which the timestamp packets themselves does not contain; timestamp packets contain a unit-less counter, which is quantitative.
In order to calculate a duration two pieces of information must be known:
- the frequency of the reference clock; and
- the prescaler of this clock.
This information is the same that is configured in [[cref:impl:rtic-trace]].
When a full timestamp has been received the offset to add to the current duration is calculated via =iter::calc_offset= seen in [[cref:lst:calc-offset]].

#+NAME: lst:calc-offset
#+CAPTION: Calculation of the offset to add to the current timestamp.
#+begin_src rust
  fn calc_offset(ts: u64, prescaler: Option<LocalTimestampOptions>, freq: u32) -> Duration {
    let prescale = match prescaler {
        None | Some(LocalTimestampOptions::Enabled) => 1,
        Some(LocalTimestampOptions::EnabledDiv4) => 4,
        Some(LocalTimestampOptions::EnabledDiv16) => 16,
        Some(LocalTimestampOptions::EnabledDiv64) => 64,
        Some(LocalTimestampOptions::Disabled) => unreachable!(), // checked in `Timestamps::new`
    };
    let ticks = ts * prescale;
    let seconds = ticks as f64 / freq as f64;

    // NOTE(ceil) we rount up so as to not report an event before it
    // occurs on hardware.
    Duration::from_nanos((seconds * 1e9).ceil() as u64)
}
#+end_src

The generation of local timestamps is critical in order to ensure a qualitative trace.
If trace packets are generated faster than they can be emitted from the target, a queued packet is dropped in favor of an overflow packet.
One of these packets may be a local timestamp.
For a discussion on how to avoid overflows, see [[cref:disc:overflows]].

*** Handling the resolved trace stream in the frontend
:PROPERTIES:
:CUSTOM_ID: impl:rtic-scope-frontend-dummy
:END:
The purpose of the of =rtic-scope-frontend-dummy= frontend is to act as a reference implementation upon which more useful frontends can be built.
There is no limit to what a frontend could do.
It could present a real-time graphical representation of the system alike a logic analyzer, it could store the resolved trace in a database, or it could simply echo the messages to =stderr=.

The dummy frontend is trivial in implementation: [[cref:lst:dummy-src]] contains its entirety with exhaustively descriptive comments.
#+NAME: lst:dummy-src
#+CAPTION: The full source code of the dummy frontend.
#+begin_src rust
  #![allow(rustdoc::bare_urls)]
  //! Reference frontend implementation for RTIC Scope.
  #![doc = include_str!("../../docs/profile/README.md")]

  use anyhow::{Context, Result};
  use rtic_scope_api as api;
  use serde_json::Deserializer;

  fn main() -> Result<()> {
      // Create frontend socket in a temporary directory, print it for the parent backend.
      let socket_dir = tempfile::TempDir::new()
          .context("Failed to create temporary directory for frontend socket")?;
      let socket_path = socket_dir.path().join("rtic-scope-frontend.socket");
      let listener = std::os::unix::net::UnixListener::bind(&socket_path)
          .context("Failed to bind frontend socket")?;
      println!("{}", socket_path.display());

      // Deserialize api::EventChunks from socket and print events to
      // stderr along with nanoseconds timestamp.
      let (socket, _addr) = listener.accept().context("Failed to accept()")?;
      let stream = Deserializer::from_reader(socket).into_iter::<api::EventChunk>();
      let mut prev_nanos = 0;
      for chunk in stream {
          let chunk = chunk.context("Failed to deserialize chunk")?;
          let nanos = chunk.timestamp.offset.as_nanos();
          let diff = nanos - prev_nanos;
          eprintln!("@{} µs (+{} ns): {:?}", nanos, diff, chunk.events);
          prev_nanos = nanos;
      }

      Ok(())
  }
#+end_src

*** Replaying a trace
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:replay
:END:
Replaying a trace is done via the =replay= verb.
The implementation behind replaying a trace is the same as recording one, only that the source is a replay file instead of a serial device or a probe, and no recovery must be done.
A replay file can be specified in two ways: by use of an index of which the =--list= flag lists the indices; or by specifying the path to the trace file.
[[cref:lst:replay-examples]] exemplifies these two methods.
When using an index to replay a file the default directory within which to search for replay files can be overridden via =--trace-dir=.

When replaying a file, =cargo-rtic-scope= will terminate when the replay file ends or if a SIGINT is received.

#+NAME: lst:replay-examples
#+CAPTION: Example commands of listing and replaying recoded traces.
#+begin_src shell
  # listing available replay files
  $ cargo rtic-scope replay --list
  0       target/rtic-traces/atsamd-demo-g472bc3d-dirty-2022-01-19T17:05:21.trace
  # replaying the trace with index 0
  $ cargo rtic-scope replay 0
  # specifying the path to the replay file
  $ cargo rtic-scope replay --trace-file target/rtic-traces/atsamd-demo-g472bc3d-dirty-2022-01-19T17:05:21.trace
#+end_src

** Results
:PROPERTIES:
:CUSTOM_ID: results
:END:
From [[cref:impl]] it follows that all requirements enumerated in [[cref:requirements]] are fulfilled.
This project has yielded a collection of five crates; four of which constitute the RTIC Scope project, the last crate a (much more; i.e. not specific to RTIC Scope) generally applicable [[gls:trace-stream]] decoding library.
These crates are described in [[cref:contribs]].
This section covers the application of RTIC Scope to a trivial [[gls:RTIC]] application executing on a Microchip ATSAME51N20A [[gls:MCU]].

We consider the RTIC Scope application example from [[textcite:&rtic-scope:atsame-example]]:
After configuring the device-specific clocks to source [[gls:ITM]] and [[gls:TPIU]], the application configures [[gls:tracing]] via =cortex_m_rtic_trace::configure= and pends a [[gls:hardware-task]], =app::hardware=.
When this task executes it spawns a [[gls:software-task]], =app::software=, with higher priority and is thus preempted.
=app::software= exits after 100 ms and =app::hardware= resumes execution after which it also exits.
The source of this application can be seen in its entirety in [[cref:lst:app-atsame-example-src-main]].
Note
- the breakpoint at line 49 which is used to escape the transient of the [[gls:SWO]] pin covered in [[cref:disc:swo-transient]];
- the configuration of the [[gls:MCU]]-specific trace clock on lines 32--40; and
- the use of the =cortex_m_rtic_trace::trace= [[gls:macro]] on the [[gls:software-task]].

As mentioned in [[cref:impl:cargo-rtic-scope:read-manifest]] trace and [[gls:MCU]] metadata must be provided in the crate's =Cargo.toml=.
This provided metadata can be seen in [[cref:lst:app-atsame-example-manifest]].

To apply RTIC Scope to an existing [[gls:RTIC]] application, the following overhead is thus required:
- configuration of the trace clock, which is [[gls:MCU]]-specific;
- configuration of tracing via =cortex_m_rtic_trace::configure= and allocating two [[gls:DWT]] comparators for [[gls:software-task]] tracing;
- application of the =cortex_m_rtic_trace::trace= macro on [[glspl:software-task]] of interest;
- addition of trace and [[gls:MCU]] metadata to the crate's =Cargo.toml=; and
- a method to escape the [[gls:SWO]] pin transient.

With this overhead performed, we trace [[textcite:&rtic-scope:atsame-example]] via [[cref:lst:app-atsame-example-trace-scope]].
The recorded traces are then listed via [[cref:lst:app-atsame-example-trace-scope-replay-list]] and replayed via [[cref:lst:app-atsame-example-trace-scope-replay]].

# TODO check if the ATSAME actually spends 100ms in app::software by toggling a pin.

** Discussion
:PROPERTIES:
:CUSTOM_ID: discussion
:END:
*** What project does ~itm~ belong to?
:PROPERTIES:
:CUSTOM_ID: disc:itm-embedded-wg
:END:
As mentioned in [[cref:impl:itm]], =itm= is a re-implementationand feature superset of a deprecated library with the same trace stream decoding goal, namely [[textcite:&itm-old]].
During the re-implementation the changes where pushed upstream to the original repository but a consensus regarding the created merge request was not reached.
Subsequently, a [[gls:RFC]] was created [[parencite:&rfc:rust-embedded:move-itm-crate]] initially proposing that the =itm= crate was moved out of the then-maintaining Cortex-M team of the Embedded Rust working group to a repository under my control to continue the development.
When the discussion concluded it was instead decided to simply add a deprecation notice to the =itm= repository pointing towards the new implementation at [[textcite:&itm]].

The reason for the proposed move was that the maintaining working group would have to maintain a wholly new code-base that had yet to stabilize.
Changes to both implementation and the [[gls:API]] of the library would then have to be vetted by team members before merge which would induce development friction.
The [[gls:RFC]] process then decided that a new discussion should be held regarding adopting the new implementation when it has stabilized.
The [[gls:RFC]] also notes that "the crate is unlikely to stabilize before Q1 2022".

Another root reason that led to the indecision of the merge was the question whether a host-side crate should ultimately be maintained by a working group focused on an embedded aspect.
While the library could in theory be adapted to operate in an embedded environment such a discussion was not raised at the time
In its present form, =itm= [[parencite:&itm]] can only be run in a rich OS environment.

As of writing, the discussion on the adoption of the reimplementation has yet to begin.
A comment will be appended to [[textcite:&rfc:rust-embedded:move-itm-crate]] pointing to the new discussion when it begins.
*** Tracing overhead with RTIC Scope
:PROPERTIES:
:CUSTOM_ID: disc:perf
:END:
[[parencite:&arm-cortex-learn 24]] states:
#+begin_quote
Except for the power that is consumed by the system trace components,
trace is almost entirely non-invasive. This means that performing trace
generation and collection does not influence the wider system.
#+end_quote

The target-side code of RTIC Scope itself has a theoritecally negligible performance impact during execution:
- the ITM/DWT/TPIU units need only be configured once in =#[init]= or during some other preparatory stage; and
- when software tasks are traced, a =u8= variable write must be done when entering and exiting the task.

Some hardware resources are also required: two [[gls:DWT]] comparators for the tracing functionality and 64 bits of flash storage for watch variables (see [[cref:lst:watch-variable-impl]]).
These resources are only strictly required if software tasks are traced, but are unconditionally required due to the current [[gls:API]] of =cortex-m-rtic-trace=, implemented as such for simplicity.

#+NAME: lst:watch-variable-impl
#+CAPTION: Implementation of watch variable storage in ~cortex-m-rtic-trace~. Two ~u8~, aligned to 32 bits, are used to track the state of software tasks. The variables are aligned to 32 bits for implementation simplicity.
#+begin_src rust
  /// Container of a variable in memory that is watched by a DWT
  /// comparator to enable software task tracing. Word-aligned to help
  /// with address comparison.
  ///
  /// XXX Is word-alignment necessary? Can't we use a mask instead?
  #[repr(align(4))]
  struct WatchVariable {
      /// ID of the software task that was entered or exited.
      pub id: u8,
  }

  /// Watch variable to which the just entered software task ID is written to. Aligned to 32-bit.
  static mut WATCH_VARIABLE_ENTER: WatchVariable = WatchVariable { id: 0 };
  /// Watch variable to which the just exited software task ID is written to. Aligned to 32-bit.
  static mut WATCH_VARIABLE_EXIT: WatchVariable = WatchVariable { id: 0 };

  /// Function utilized by [`#[trace]`](trace) to write the unique ID of
  /// the just entered software task to its associated watch address. Only
  /// use this function via [`#[trace]`](trace).
  #[inline]
  pub fn __write_enter_id(id: u8) {
      unsafe {
          WATCH_VARIABLE_ENTER.id = id;
      }
  }

  /// Function utilized by [`#[trace]`](trace) to write the unique ID of
  /// the software task about to exit to its associated watch address.
  /// Only use this function via [`#[trace]`](trace).
  #[inline]
  pub fn __write_exit_id(id: u8) {
      unsafe {
          WATCH_VARIABLE_EXIT.id = id;
      }
  }
#+end_src

Theoretically, a single comparator could be utilized to handle both software task enters and exit by reserving a bit in the written =u8= to denote the new state.
Further, because only 8 of the 32 bits (in conjunction with a change to only use a single comparator) are effectively used, only 8 bit should need to be allocated for the (now) singular watch variable.
This overzealous resource allocation was for implementation simpliticy.
A future release of RTIC Scope can offer a lower resource requirement.

The performance of the host-side =cargo-rtic-scope= and =rtic-scope-frontend-dummy= programs have not been measured.
*** Restrictions of tracing functions inside tasks
:PROPERTIES:
:CUSTOM_ID: disc:nested-tracing-restrictions
:END:
While implementing software task tracing by help of the =trace= macro, support was also added to apply the macro to nested functions.
However, due to how the macro expands (see [[cref:lst:rtic-trace:trace-expanded]]), a nested function would expand to [[cref:lst:trace-expanded-nested]]: the exit state change of the nested function would never be reported due to the return statement just before.

#+NAME: lst:trace-expanded-nested
#+CAPTION: Expanded \glsxtrfull{RTIC} task declaration with a traced nested function.
#+begin_src rust
  // ...

  #[allow(non_snake_case)]
  fn task(_: task::Context) {
      ::cortex_m_rtic_trace::__write_enter_id(0);
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
      fn nested() {
          ::cortex_m_rtic_trace::__write_enter_id(1);
          // some work
          return // or equivalent
          ::cortex_m_rtic_trace::__write_exit_id(1);
      }
      ::cortex_m_rtic_trace::__write_exit_id(0);
  }

  // ...
#+end_src

This limitation can be side-stepped by implementing =task::nested= such that it only applies side-effects to the function's parameters.
Such an approach can be compared to how functions in C are commonly implemented, where the returned value is a pointer or an integer signalling if the operation was successful.
However, due to the strict requirement that the function must not return any value in its last statement, any return data or signals must first be intermediately allocated and passed as a mutable reference to the traced function, yielding an ad-hoc [[gls:API]] that not only breaks Rust's implementation guidelines but is different from a C [[gls:API]].

An alternative implementation of =trace= could instead wrap the call to =task::nested=, allowing a implementation of a pure function[fn:: A function without side-effects.], but because =trace= is an attribute macro it cannot be applied to statements in functions [[parencite:&docs:rust-proc-macros]].
If trace was available as a function-like macro one could in theory wrap and trace any block expression via a theoretical =trace!(|| { nested() + nested() })=, but that would non-trivial changes to the recovery step of =cargo-rtic-scope= in order to assign a unique ID to each macro invocation.
Furthermore it would also require the allocation of a key-word to differentiate trace macros from non-trace macros, inducing end-user overhead.

The support for nested function tracing is likely to be removed in a future release of RTIC Scope.
It is thus recommended to only use the =trace= macro on [[gls:RTIC]] task declarations.
*** A fundamental flaw of asynchronous serial trace exfiltration
:PROPERTIES:
:CUSTOM_ID: disc:swo-transient
:END:
During the development of RTIC Scope done within the scope of this thesis, considerate focus was put on trace exfiltration using asynchronous serial communication.
This approach saw focus due to the minimal hardware design required to enable tracing support of a product based on a ARMv7-M [[gls:MCU]]:
the base requirement is to expose the single [[gls:SWO]] pin, after which the remaining work is done by device-external hardware (in order to convert the electrical signal to a byte stream) and software.
A single [[gls:MCU]] pin commonly multiplex features, however.
Features can in theory be selected via hardware or software:
via a hardware configuration (pulling another pin high or low[fn:: Shorting the pin to a 3.3V source, or common ground, respectively.]) the pin in question will expose the wanted feature when the [[gls:MCU]] and eventual [[gls:MCU]]-internal peripherals are powered;
via software the pin will expose its default feature on power and software must configure the pin during initialization.
Commonly, most pins can only be configured via software and upon a [[gls:MCU]] reset, the pin returns to its default feature.
Unfortunately, software configuration is prone to induce transient noise on the pin until it is configured.
If this noise it not accounted for and host-side trace recording starts as the [[gls:MCU]] resets, the recorded noise will put the trace decoder in an unknown state and likely emit malformed packets.
Ultimately, task state changes are likely to be lost and the error induced to the decoder may not necessarily be transient.
This behavior is intrinsically [[gls:MCU]]-specific: there is unlikely a common model of this noise that can be used to filter the bytes host-side in software.

The ATSAME51N20A is one example of an [[gls:MCU]] that displays this noise, seen in [[cref:fig:swo-transient]], as a consequence of the configuration done to pin PC27 in [[cref:lst:atsame51n20a-swo-conf]].

#+NAME: lst:swo-transient-plot
#+begin_src python :results file :exports results
  import pandas as pd
  import matplotlib as mpl
  import matplotlib.pyplot as plt

  rc_fonts = {
      "font.family": "serif",
      "font.size": 12,
      "text.usetex": True,
      'text.latex.preview': True,
      'text.latex.preamble': [
          r"""
          \usepackage{kpfonts}[maths]
          \usepackage{libertine}
          \usepackage{inconsolata}
          """],
  }
  mpl.rcParams.update(rc_fonts)

  df_trans = pd.read_csv('data/swo-transient.txt', sep=' ', skiprows=4, index_col=0)
  df_ground = pd.read_csv('data/swo-transient-grounded.txt', sep=' ', skiprows=4, index_col=0)
  plt.plot(df_ground, label='Signal (probe grounded)')
  plt.plot(df_trans, label='Signal')
  plt.legend()
  plt.ylabel('Signal voltage [V]')
  plt.xlabel('Time [s]')

  plt.savefig('fig.svg')
  return 'fig.svg'
#+end_src

#+NAME: fig:swo-transient
#+CAPTION: Transient seen on the [[Gls:SWO]] pin after the configuration in [[cref:lst:atsame51n20a-swo-conf]] has been applied. Compared with grounded equivalent. When logically interpreted, the signal can yield a malformed [[gls:trace-packet]] where there is none.
#+RESULTS: lst:swo-transient-plot
[[file:fig.svg]]

#+NAME: lst:atsame51n20a-swo-conf
#+CAPTION: Configuration of the PC27 pin for the ATSAME51N20A [[gls:MCU]] to act as the [[gls:SWO]] pin. This configuration induces transient noise on the pin, seen in [[cref:fig:swo-transient]]. Remainder of the [[gls:RTIC]] application omitted for brevity.
#+begin_src rust
  #[init]
  fn init(mut ctx: init::Context) -> (SharedResources, LocalResources, init::Monotonics()) {
      use atsamd_hal as hal;
      use hal::thumbv7em::clock::GenericClockController;
      use hal::gpio::v2::pin::{Alternate, M};

      // configure trace clock
      let mut gcc = GenericClockController::with_internal_32kosc(
          ctx.device.GCLK,
          &mut ctx.device.MCLK,
          &mut ctx.device.OSC32KCTRL,
          &mut ctx.device.OSCCTRL,
          &mut ctx.device.NVMCTRL,
      );
      let gclk0 = gcc.gclk0();
      let _trace_clk = gcc.cm4_trace(&gclk0).unwrap();

      // configure SWO pin; this induces transient noise on the pin.
      let pins = hal::gpio::v2::Pins::new(ctx.device.PORT);
      let _pc27 = pins.pc27.into_mode::<Alternate<M>>();
  }
#+end_src

A few methods of "escaping" this transient that require further investigation are proposed in [[cref:fut:espace-swo-transient]].

*** Avoiding overflows
:PROPERTIES:
:CUSTOM_ID: disc:overflows
:END:
The theory behind overflow avoidance is simple: the [[gls:ITM]] and [[gls:DWT]] may not generate more trace packets than what the [[gls:TPIU]] can serialize.

If overflows are encountered the below description of approaches can be consulted, in order of recommendations.
- Increase [[gls:TPIU]] baud rate :: the [[gls:SWO]] baud rate is controlled via the /SWOSCALER/ bitrange in [[gls:TPIU_ACPR]] as described in [[cref:impl:rtic-trace:peripheral-config]].
  /SWOSCALER/ can be calculated via [[cref:eq:prescaler]], and can be considered arbitrary.
  Increasing the baud rate by lowering /SWOSCALER/ gives the [[gls:TPIU]] more time to serialize a packet onto the [[gls:SWO]] pin, thus inceasing the margin until the internal [[gls:FIFO]] queue fills up prompts an overflow on the next packet.

  While the [[gls:TPIU]] can communicate with an arbitrary baud rate the host-side system may not be able to communicate with the same arbitrarity.
  Linux, for example, can only communicate with a set of pre-defined baud rates as described in =termios.h= [[parencite:&linux:termios]].
  With a sufficiently low error rate, $\left\lvert1 - \frac{\text{Linux baud rate}}{\text{TPIU baud rate}}\right\rvert$, it may be possible to establish a stable communication with non-matched baud rates.

  The baud rate can be selected via =cortex_m_rtic_trace::configure= by appropriately configuring the passed =TraceConfiguration::tpiu_baud= structure field.

- Asynchronously clock [[gls:TPIU]] :: The [[gls:TPIU]] can be clocked with the system clock or via an asynchronous clock, configured via the =TraceConfiguration::timestamp_clk_src= enum passed to =cortex_m_rtic_trace::configure=.
  If overflows are encountered when using the system clock, it is recommended to use a faster asynchronous clock instead.
  The capabilites of this clock, how it is configured, and whether an asynchronous clock source is supported at all is [[gls:MCU]]-specific.
  In combination with the previous recommendation, this gives a lot more leeway when configuring the baud rate;
  with a dedicated trace clock the baud rate can much more easily match the baud rates the host system can communicate with, without affecting the [[gls:MCU]]'s system clock.

  As the configuration field name implies, this clock is also used to increment the timestamp values --- specifically local timestamps.
  Note also [[textcite:&arm-rm Section C1.7.6]], under /SWOENA/, which the configuration field is equivalent to: "[When an asynchronous clock is used] the timestamp counter is held in reset while the output line is idle."
  This implies that when the system clock is used the timestamp counter will continue to run even if there are no trace packets to serialize.[fn:: Anecdotally, when experimenting with the Atmel ATSAME51N20A, a local timestamp would be emitted before it wrapped when using the system clock.]
  This behavior must be taken into account when changing the clock source.
  It is in any case recommended to always use an asynchonous clock source if available in case the sysem clock frequency must be changed.

- Lower the system clock :: The frequency at which trace packets are generated is entirely bound to how often tasks are entered and exited and the frequency of the system clock.
  If the above recommendations have been applied and overflows are still encountered, a last resort before the traced application must be refactored is to lower the system clock frequency.
  This frequency should as per the last recommendation be lower than that of the asynchronous clock frequency which the [[gls:TPIU]] sources.

- Generate less events :: If all the above recommendations fail to remedy overflows, the remaining option is to refactor the [[gls:RTIC]] application to generate less events: that is, decrease the frequency at which tasks are entered and exited.
  The lowest hanging fruit of this approach is to simply disable the tracing of software tasks by omitting all instances of the =trace= macro.
*** Future work
This section comments on some choice topics of future work planned for RTIC Scope, most sections being referred to previously in this text and being filed as issues in the relevant repository.
This section is not exhaustive for sake of brevity:
as of writing 31 issues are open for RTIC Scope[fn:: Refer to [[https://github.com/rtic-scope/cargo-rtic-scope/issues][https://github.com/rtic-scope/cargo-rtic-scope/issues]].];
7 for =itm=[fn:: Refer to [[https://github.com/rtic-scope/itm/issues][https://github.com/rtic-scope/itm/issues]].];
and 10 for =cortex-m=[fn:: Refer to [[https://github.com/rust-embedded/cortex-m/issues?q=is%3Aopen+author%3Atmplt][https://github.com/rust-embedded/cortex-m/issues?q=is%3Aopen+author%3Atmplt]].] (which relate to tracing functionality).

**** \glsxtrfull{TPIU} baud rate configuration
:PROPERTIES:
:CUSTOM_ID: fut:swoscaler
:END:
The baud rate of the [[gls:TPIU]] is configured via [[cref:lst:tpiu-baud-rate]] which implements [[cref:eq:prescaler]].
This implementation is error-prone due to integer division and because it does not verify the written prescaler value by reading it back.
The implementation will also attempt a divide-by-zero if a baud rate of 0 is requested; in the best case, this leads to a panic.
Currently, this behavior is not documented.

#+NAME: lst:tpiu-baud-rate
#+CAPTION: \glsxtrfull{TPIU} baud rate configuration using the reference clock frequency and requested baud rate, from the ~cortex-m~ crate, that implements [[cref:eq:prescaler]]. ~self~ is a structure representation of the [[gls:TPIU]] configuration registers. This implementation is subject to integer division, divide-by-zero, and does not verify the written prescaler value; it is thus error-prone.
#+begin_src rust
  impl TPIU {
      /// Sets the prescaler value for a wanted baud rate of the Serial
      /// Wire Output (SWO) in relation to a given asynchronous refernce
      /// clock rate.
      #[inline]
      pub fn set_swo_baud_rate(&mut self, ref_clk_rate: u32, baud_rate: u32) {
          unsafe {
              self.acpr.write((ref_clk_rate / baud_rate) - 1);
          }
      }

      // ...
  }
#+end_src

For example, if the function is called via =tpiu.set_swo_baud_rate(16_000_000, 115_200)= one would expect the prescaler value 137.88 to be written, but because this prescaler must be an integer 137 is written instead, configuring the [[gls:TPIU]] to use a baud rate of approximately 115942 instead as per [[textcite:&arm-rm Section C1.10.4]]; an error of 6.44%, via [[cref:eq:baud-rate-error]].
A sufficiently large error will induce communication problems.
#+NAME: eq:baud-rate-error
\begin{equation}
  \left\lvert 1 - \left(\frac{115942}{115200}\right)\right\rvert = 0.00644
\end{equation}

An issue that further documents the erroneous implementation and offers improvements is available at [[textcite:&issue:cortex-m:388]].

Ideally, errors such as [[cref:eq:baud-rate-error]] should be caught statically during compilation, but such a feature would require non-trivial changes to the embedded Rust eco-system because =cortex-m= currently has no idea about the clock configuration of the target device.[fn:: This would require changes to all [[glspl:HAL]] to statically hold information about the device-specific clock hierarchy that can then be passed to and inspected by =cortex-m=.]

**** Trace stream ID configuration
:PROPERTIES:
:CUSTOM_ID: fut:TraceBusID
:END:
[[textcite:&arm-rm p. C1-718]] documents:
#+begin_quote
If a system supports multiple trace streams, the debugger must write a nonzero value to the ITM\textunderscore TCR.TraceBusID field.
\textelp{} An example of a system with multiple trace streams is an ARMv7-M core with ETM trace stream.
#+end_quote
However, no documentation covers the use-case when [[gls:ETM]] should be disabled and only the [[gls:ITM]] trace stream is of interest.
From brief communication with the ARM errata team, it seems that writing zero to this field is valid if the device does not support [[gls:ETM]], but anecdotally (during RTIC Scope testing) it also seems valid when [[gls:ETM]] packets are dropped (see [[cref:impl:rtic-trace:peripheral-config]]) on a device that does offer an [[gls:ETM]], particularly the Atmel ATSAME51N20A.
This relationship (validity of a zero trace bus ID when [[gls:ETM]] packets are dropped) has not been verified.

An issue covering the potential invalidity of a zero trace bus ID is available at [[textcite:&issue:cortex-m:392]].

**** Deprecating ~cortex-m-rtic-trace~
:PROPERTIES:
:CUSTOM_ID: fut:rm-rtic-trace
:END:
=cortex-m-rtic-trace= is an auxilliary library that provides =configure=, which configures all relevant peripherals for tracing; and =trace=, a macro with which software tasks can be traced after =configure= has been called successfully.
Refer to [[cref:impl:rtic-trace]] for implementation details.

A goal of RTIC Scope is to minimize the end-user overhead when applying it.
The version of RTIC Scope presented in this text requires the user to modify their RTIC application's =init= function by calling =configure=.
Ideally, the end-user should be able to enable tracing via flags to RTIC, either for the whole application or tasks of interest.
See [[cref:lst:ideal-trace-enable]] for an example.
Then the =trace= flag is set, RTIC could then inject the code to =configure= into the application.


#+NAME: lst:ideal-trace-enable
#+CAPTION: Ideal methods to enable tracing of RTIC applications via flag specification: either
#+begin_src rust
  #[rtic::app(trace = true, ...)] // enables tracing of all tasks
  mod app {
      // ...

      #[task(trace = true, ...)] // enables tracing of just this task
      fn task(_: task::Context) {
          // ...
      }
  }
#+end_src

Of note is that only a portion of =configure= is specific to RTIC Scope; other RTOSs could benefit from its implementation.
It may be apt to upstream portions of its implementations to [[textcite:&cortex-m]] (which =cortex-m-rtic-trace= extends).

Regardless of what the outcome of minimizing end-user overhead is, =cortex-m-rtic-trace= is predicted to be deprecated.
A tracking issue for this eventuality is available; see [[textcite:&issue:cargo-rtic-scope:90]].
See also [[textcite:&issue:cargo-rtic-scope:100]], a tracking issue on the realization of zero end-user overhead.

**** Supporting other \glsxtrfullpl{RTOS} than \glsxtrfull{RTIC}
Version 0.3.1 of RTIC Scope targets and depends on (as the name implies) [[gls:RTIC]] v1.0.0.
This dependency is only required for the recovery step which generates the =recovery::SoftwareMap= and =recovery::HardwareMap= with some metadata required by the end-user (see [[cref:impl:cargo-rtic-scope:read-manifest]]).
RTIC Scope could as well require that the end-user provide these maps by describing them in an external file passed via a theoretical =cargo rtic-scope trace --maps-file /path/to/extenal-map-description [...]= invocation.
Such an approach would enable an end-user to apply =cargo-rtic-scope= on an application that is not written in [[gls:RTIC]].
Additionally, =cargo-rtic-scope= could then also be applied on an application that is not necessarily written in Rust if =--dont-touch-target= and =--trace-dir= are passed to the =trace=[fn:: =--trace-dir= would be required such that =cargo-rtic-scope= would not search through a crate that does not exist. =--dont-touch-target= is would be required because =cargo-rtic-scope= only knows how to build and flash a Rust application.] verb and provided that =cortex-m-rtic-trace= is substituted.
This would make the toolset more general and drive development from more than a single, currently niche, front.

No work has currently been done to make [[gls:RTIC]] an optional run-time dependency of =cargo-rtic-scope=.

**** Publishing all crates to the crate registery
In order to publish a crate all of its dependencies must first be published.
When a crate has been published, it can be used as a dependency by specifying the crate name and version alone in =Cargo.toml=, as seen in [[cref:lst:cargo-lib-dep]].
A published crate can also be installed via =cargo= by simply specifying the name of the crate;
this makes it trivial for end-users to install your program as long as any non-Rust dependencies are installed.
Ideally, an user should be able to install RTIC Scope via [[cref:lst:cargo-install-bins]], but as of writing the easiest way to install RTIC Scope is via [[cref:lst:cargo-install-git]], simply because RTIC Scope v0.3.1 has yet to be published at the time of writing.

#+NAME: lst:cargo-lib-dep
#+CAPTION: Declaring ~cortex-m-rtic-trace~, which is here presumed to be published on the crate repository, as a dependency in a ~Cargo.toml~
#+begin_src toml
  # ...

  [dependencies]
  cortex-m-rtic-trace = "0.3.1"

  # ...
#+end_src

#+NAME: lst:cargo-install-bins
#+CAPTION: Installing RTIC Scope via ~cargo install~, presuming v0.3.1 has been published on the crate reposity.
#+begin_src shell
  $ cargo install cargo-rtic-scope rtic-scope-frontend-dummy --version 0.3.1
#+end_src

#+NAME: lst:cargo-install-git
#+CAPTION: Installing RTIC Scope via ~cargo install~ via the git repository.
#+begin_src shell
  $ cargo install --git https://github.com/rtic-scope/cargo-rtic-scope cargo-rtic-scope rtic-scope-frontend-dummy --branch v0.3.1
#+end_src

RTIC Scope has yet to be published because of contributions made upstream.
Either these contributions have been merged (but not released) or are awaiting feedback from their respective maintainers.
A tracking issue has been created that documents the effort to publish RTIC Scope; see [[textcite:&issue:cargo-rtic-scope:101]].

**** Replacing ~itm-tools~
:PROPERTIES:
:CUSTOM_ID: fut:itm-tools
:END:
=itm-tools= [[parencite:&itm-tools]] is a toolset for analyzing [[gls:ITM]] trace streams.
As of writing, the tools decode the [[gls:ITM]] packet standard and offer interpretation of exception traces, [[gls:PC]] samples (via =pcsampl=), and instrumentation packet port demuxing (via =port-demux=).
Of certain interest is that =pcsampl= can answer the quetion of "where is my program spending most if its time?"
An example invocation of =pcsampl= would yield [[cref:lst:pcsampl]], describing that the program spent almost 92% of its time sleeping during the time the target was traced.

#+NAME: lst:pcsampl
#+CAPTION: Example invocation of ~pcsampl~ from [[textcite:&itm-tools]].
#+begin_src shell
  $ pcsampl -e target/thumbv7m-none-eabi/release/app itm.bin 2>/dev/null
      % FUNCTION
  91.69 *SLEEP*
   3.70 app::foo_o7xa::h9e4953f3ea6a58d8
   2.87 app::bar_t7fm::hf544b1b6f026d266
   0.95 SysTick
   0.52 EXTI1
   0.26 EXTI0
   0.01 main
  -----
   100% 11692 samples
#+end_src

In comparison to =itm-decode= provided as a result of this thesis, =itm-tools= does not: configure an optional serial device for direct reading, offer the option to maintain a monotonically increasing timestamp, optionally associates trace packets with such a timestamp, or trivially describes the timestamp quality.
=itm-decode= does on the other hand not offer equivalents to =pcsampl= and =port-demux=.

It would be beneficial to incorporate the features offered by =itm-tools= into =itm= (within which =itm-decode= is available) in order to collect [[gls:ITM]] decoding and interpretation efforts in a singular crate.
For =port-demux= and =pcsampl= equivalence, refer to [[textcite:&issue:itm:5]] and [[textcite:&issue:itm:14]], respectively.

**** Escaping the \glsxtrfull{SWO} transient noise
:PROPERTIES:
:CUSTOM_ID: fut:espace-swo-transient
:END:
Below is a list of possible methods of espacing the transient noise of the [[gls:SWO]] pin described in [[cref:disc:swo-transient]].

- Using the parallel trace port :: [[textcite:&arm-rm Section C1.10]] describes the optional feature of a "parallel trace port".
  This is a synchronous trace exfiltration method that uses one pin for the clock and at least one pin for data communication.
  An optional "control pin" may also be supported by the [[gls:MCU]], but its purpose has not been investigated.

  This approach may remove the noise entirely, but may depend on the order in which the pins are configured.
  It will also require more complex hardware between the target and host in order to adapt the parallel interface to a serial device which =cargo-rtic-scope= can read.
  [[textcite:&orbuculum]] has done some work on this front, and offer hardware designs to demux multiple data pins.

- Using sentinel synchronization packets :: [[textcite:&arm-rm Section D4.2.1]] defines a synchronization packet that "trace capture hardware can [use to] identify the alignment of packet bytes in the bitstream".
  If such a packet is emitted after pin configuration, the decoder may be able to implement support to drop read trace data until this packet is encountered.
  Due to the constitution of this packet (at least 47 zeros followed by a single 1 bit), the possibility of the transient noise generating such a packet may be sufficiently low to ensure a stable trace stream.
  However, this possibility is difficult to find because the induces noise depends on the internal characteristics of the [[gls:MCU]].
  Refer to [[textcite:&issue:itm:11]] for the progress and applicability of this approach.

- Storing trace data on-chip :: [[textcite:&arm-rm Section C1.10]] refers to a [[gls:TPIU]]-alternative dubbed the [[gls:ETB]], described in [[textcite:&coresight]], that stores the trace data in on-chip memory.
  An attached debugger could theoretically read this data, sidestepping the [[gls:TPIU]] (and thus any pin transients) completely.
  =cargo-rtic-scope= relies on =probe-rs=, which can be used to read the on-chip memory, but as of writing it lacks support for the [[gls:ETB]].
  Refer to [[textcite:&issue:cargo-rtic-scope:128]] for the progress of this approach.

**** Review local and global timestamp clock relationship
:PROPERTIES:
:CUSTOM_ID: fut:review-timestamp-relation
:END:
As of writing RTIC Scope assumes that local and global timestamps are incremented via the same clock.
As per [[textcite:&arm-rm p. C1-710]] this may not necessarily be the case: "[Global timestamps] provide absolute timestamp values, based on a system global timestamp clock" whereas "[Local timestamps are generated] from the timestamp clock in the ITM unit".
[[textcite:&arm-rm Figure C1-1]] can on the other hand be interpreted to imply that both local and global timestamps are derived from this global timestamp clock, but it is nowhere unambiguously stated as such.
Due to this ambiguity it is presumed that the relationship between the clocks that generate local and global timestamps is unknown and thus [[gls:MCU]]-specific;
=itm= should be adapted to account for this.
Refer to [[textcite:&issue:itm:12]] regarding the progress on this issue.

**** Graphically representing traces
During experimentation with the Microchip ATSAME51N20A [[gls:MCU]] the want to graphically represent a trace result arose.
Subsequently an ad-hoc fork of =rtic-scope-frontend-dummy= --- =feat/auto-plot= from [[textcite:&rtic-scope:dummy-auto-plot]], =src/main.rs= of chief interest --- was created that converts the trace to a [[gls:CSV]] representation and then plots it.
When the [[gls:RTIC]] application in [[cref:lst:app-atsame-example-src-main]] has been traced and then replayed the dummy produces the plot in [[cref:fig:auto-plot-example]].

From this proof of concept it is immidiately clear that a graphical representation of a recorded trace holds great value for system insight;
further work to this end is warranted.
Refer to [[textcite:&issue:cargo-rtic-scope:135]] and [[textcite:&issue:cargo-rtic-scope:89]].

** Conclusion
:PROPERTIES:
:CUSTOM_ID: conclusion
:END:
The RTIC Scope project fulfills all requirements enumered in [[cref:requirements]] with the delimitations enumerated in [[cref:delimitations]].
While end-user overhead has been minimized as much as possible with the allotted development time overhead may still be considered significant depending on factors of [[gls:HAL]] availability and complexity of the embedded system.
** Backmatter                                                       :ignore:
[[printglossaries:]]
[[printbibliography:]]
** Appendices                                                       :ignore:
#+begin_export latex
\appendix
\addappheadtotoc
#+end_export
*** The source code of a trivial [[gls:RTIC]] application, traced with RTIC Scope, and the trace result
This appendix contains the source code of interest in [[textcite:&rtic-scope:atsame-example]] that relates to the application of RTIC Scope, namely
- =src/main.rs= :: in [[cref:lst:app-atsame-example-src-main]]; and
- =Cargo.toml= :: in [[cref:lst:app-atsame-example-manifest]],
but also the trace results, namely
- [[cref:lst:app-atsame-example-trace-itm]] :: when tracing with =itm= from [[textcite:&itm]];
- [[cref:lst:app-atsame-example-trace-scope]] :: when recording a trace with RTIC Scope;
- [[cref:lst:app-atsame-example-trace-scope-replay-list]] :: when listing the recorded traces; and
- [[cref:lst:app-atsame-example-trace-scope-replay]] :: when replaying the recorded trace.

The output of an experimental fork of =rtic-scope-frontend-dummy=, =feat/auto-plot= from [[textcite:&rtic-scope:dummy-auto-plot]], is also provided that graphically plots the trace replayed in [[cref:lst:app-atsame-example-trace-scope-replay]].
Refer to [[cref:fig:auto-plot-example]].

#+begin_export latex
\inputminted{rust}{rtic-scope-atsame-example/src/main.rs}
\captionof{listing}{Trivial \glsxtrfull{RTIC} application configured for tracing via RTIC Scope (lines 52--68), for execution on the Microship ATSAME51N20A. The spawned \gls{software-task}, \texttt{app::software}, preempts the \gls{hardware-task}, \texttt{app::hardware}, and delays further execution for 100 ms. Note the \texttt{trace} \gls{macro} on \texttt{app::software}. \label{lst:app-atsame-example-src-main}}
#+end_export

#+begin_export latex
\inputminted{toml}{rtic-scope-atsame-example/Cargo.toml}
\captionof{listing}{Crate manifest for the \glsxtrfull{RTIC} application in \cref{lst:app-atsame-example-src-main}. Lines 7--17 declare the metadata required by RTIC Scope. \label{lst:app-atsame-example-manifest}}
#+end_export

#+NAME: lst:app-atsame-example-trace-itm
#+CAPTION: Trace recorded from the executed \glsxtrfull{RTIC} application in \cref{lst:app-atsame-example-src-main} via ~itm-decode~ from [[textcite:&itm]].
#+begin_src text
  $ itm-decode /path/to/dev/tty --itm-freq 1000000
  ExceptionTrace { exception: Interrupt { irqn: 12 }, action: Entered }
  ExceptionTrace { exception: Interrupt { irqn: 13 }, action: Entered }
  LocalTimestamp1 { ts: 24, data_relation: Sync }
  DataTraceValue { comparator: 1, access_type: Write, value: [0] }
  LocalTimestamp1 { ts: 45, data_relation: Sync }
  DataTraceValue { comparator: 2, access_type: Write, value: [0] }
  ExceptionTrace { exception: Interrupt { irqn: 13 }, action: Exited }
  LocalTimestamp2 { ts: 5 }
  ExceptionTrace { exception: Interrupt { irqn: 12 }, action: Returned }
  ExceptionTrace { exception: Interrupt { irqn: 12 }, action: Exited }
  LocalTimestamp2 { ts: 2 }
  ExceptionTrace { exception: ThreadMode, action: Returned }
#+end_src

#+NAME: lst:app-atsame-example-trace-scope
#+CAPTION: Trace recorded from the executed \glsxtrfull{RTIC} application in \cref{lst:app-atsame-example-src-main} via RTIC Scope. The target is traced for ten seconds. ~rtic-scope-frontend-dummy~ is used as the \gls{frontend}.
#+begin_src text
  $ cargo rtic-scope trace --serial /path/to/dev/tty --dont-touch-target
      Building RTIC target application...
    Recovering metadata for rtic-scope-atsame-example (/path/to/rtic-scope-atsame-example/src/main.rs)...
     Recovered 2 task(s) from rtic-scope-atsame-example: 1 hard, 1 soft.
      Frontend dummy: @2000 ns (+2000 ns) [good]: [Task { name: "app::hardware", action: Entered }]
      Frontend dummy: @5750 ns (+3750 ns) [good]: [Task { name: "app::software", action: Entered }]
      Frontend dummy: @6167 ns (+417 ns) [good]: [Task { name: "app::software", action: Exited }]
      Frontend dummy: @6334 ns (+167 ns) [good]: [Task { name: "app::hardware", action: Returned }, Task { name: "app::hardware", action: Exited }]
        Traced rtic-scope-atsame-example: 10 packets processed in 10s (~1.0 packets/s; 0 malformed, 0 non-mappable); 2/2 sinks operational.
#+end_src

#+NAME: lst:app-atsame-example-trace-scope-replay-list
#+CAPTION: Listing of recorded traces after the execution of [[cref:lst:app-atsame-example-trace-scope]]. Only a single trace is available for replay, its index 0.
#+begin_src text
  $ cargo rtic-scope replay --list
  idx     trace file
  0       /path/to/rtic-scope-atsame-example/target/rtic-traces/rtic-scope-atsame-example-gf7dd449-dirty-2022-03-21T11:16:31.trace
#+end_src

#+NAME: lst:app-atsame-example-trace-scope-replay
#+CAPTION: Replay of the trace file of index zero listed in [[cref:lst:app-atsame-example-trace-scope-replay-list]] and recorded by executing [[cref:lst:app-atsame-example-trace-scope]]. ~rtic-scope-frontend-dummy~ is used as the \gls{frontend}.
#+begin_src text
  $ cargo rtic-scope replay 0
      Frontend dummy: @2000 ns (+2000 ns) [good]: [Task { name: "app::hardware", action: Entered }]
      Frontend dummy: @5750 ns (+3750 ns) [good]: [Task { name: "app::software", action: Entered }]
      Frontend dummy: @6167 ns (+417 ns) [good]: [Task { name: "app::software", action: Exited }]
      Frontend dummy: @6334 ns (+167 ns) [good]: [Task { name: "app::hardware", action: Returned }, Task { name: "app::hardware", action: Exited }]
      Replayed rtic-scope-atsame-example: 10 packets processed in 0s (~inf packets/s; 0 malformed, 0 non-mappable); 1/1 sinks operational.
#+end_src

#+NAME: fig:auto-plot-example
#+CAPTION: Graphical representation of the trace yielded by [[textcite:&rtic-scope:dummy-auto-plot]], equivalent to [[cref:lst:app-atsame-example-trace-scope-replay]]. ~app::software~ preempts ~app::hardware~ after approximately 5600 ns. At approximately 6100 ns ~app::hardware~ resumes execution. Task context switch overhead not plotted.
[[file:svgs/auto-plot-example.svg]]
* Footnotes
[fn:not-of-concern] Functionality not of concern for RTIC Scope v0.3.1.

[fn:exception-number-0] During experimentation packets with a zero in this field were encountered. [[textcite:&arm-rm Section B1.3.1]] notes that a /Thread mode/ is entered on target reset.  [[gls:RTIC]] executes its task by help of exceptions which warrant an enter into a /Handler mode/. [[textcite:&arm-rm p. B1-517]] comments that a value of [[gls:IPSR]] is zero if no exception handler is executing. These Thread mode changes were always observed before and after non-preempted [[gls:RTIC]] tasks entered and exited. An exception number of 0 is then ultimately ignored by RTIC Scope v0.3.

[fn:dwt-n] $n$ emphasized for reasons of readability and typesetting.
